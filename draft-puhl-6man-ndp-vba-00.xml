<?xml version="1.0" encoding="utf-8"?>
<!-- 
     draft-rfcxml-general-template-standard-00
  
     This template includes examples of the most commonly used features of RFCXML with comments 
     explaining how to customise them. This template can be quickly turned into an I-D by editing 
     the examples provided. Look for [REPLACE], [REPLACE/DELETE], [CHECK] and edit accordingly.
     Note - 'DELETE' means delete the element or attribute, not just the contents.
     
     Documentation is at https://authors.ietf.org/en/templates-and-schemas
-->
<?xml-model href="rfc7991bis.rnc"?>  <!-- Required for schema validation and schema-aware editing -->

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndp-vba-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndp-vba">IPv6 Voucher-Based Address Generation &amp; Verification</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndp-vba-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>vba</keyword>
    <keyword>spoofing</keyword>
    <keyword>privacy</keyword>
    <abstract>
      <t>
        This document specifies an extensible IPv6 unicast address generation and verification methodology for local
        networks. Individual link-layer identifiers are bound to sets of deterministic output addresses, which
        maintain user privacy regardless of link-layer identifier stability. Vouchers distributed by Router
        Advertisements on-link are used to form a consensus between neighbors of the parameters used in the address
        derivation process. Cryptographic key derivation functions are used to generate pseudo-random addresses and
        to stretch address computation times. Host parameters can be used to derive any number of both stable
        and ephemeral, privacy-focused addresses for each on-link prefix and at the link-local scope. NDP
        exchanges can then verify the interface-identifier-to-IP bindings to prevent on-path attacks in local
        networks.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        Voucher-Based Addressing (VBA) offers an alternative solution to
        the address ownership problem, enables extensible and private unicast address generation, and prevents
        on-path attacks in IPv6 local networks. Using a mutual key derivation function to map input components
        one-to-one to output ciphertexts, link-layer identifiers can be reliably coupled to sets
        of deterministically generated IPv6 addresses and subsequently verified by neighboring nodes. All verifications
        are decentralized and do not require public-key cryptography; only shared consensus on a distributed,
        pseudo-random value used to seed the address generation procedure. The same deterministic algorithm produces
        IPv6 address suffixes appearing statistically random to devices outside the local broadcast domain, who
        are by design unaware of all input parameters associated with the address.
      </t>
      <t>
        This document represents an application of cryptographic key-stretching methodologies to IPv6 address
        generation. The result is a secure, high-impact, low-complexity change bundled with various transition
        capabilities, effectively corroborating IPv6 address ownership to defeat malicious network address spoofing.
      </t>
      <t>
        This document introduces Voucher-Based Addressing (VBA) in IPv6 networks as an optional functionality for Neighbor Discovery Protocol (NDP) <xref target="RFC4861"/>.
      </t>
      <t>
        VBAs operate on the principle that active spoofing requires the impersonation <!-- TODO -->
      </t>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <!-- TODO -->
      <t>
        Many of the terms in this document are defined in Section 2.1 of the most current NDP standard <xref target="RFC4861"/>.
      </t>
      <t>
        An alphabetical glossary of terms related to this document, but not necessarily defined herein
        or appearing in the NDP specification, is specified in this section. Items appearing here may
        or may not be acronymized even in their first appearances in future sections (but never in
        section headers), so knowledge of them is assumed henceforth.
      </t>
      <dl newline="true">
        <dt>Voucher-Based Address (VBA)</dt>
        <dd>An IPv6 address generated by a mixture of Link Voucher details, network interface details, and subnet details.</dd>

        <dt>Neighbors</dt>
        <dd>Other connected nodes adjacent to a client node on the same link.</dd>

        <dt>Key Derivation Function</dt>
        <dd>Definition of the second term [REPLACE/DELETE]</dd>

        <dt>Link</dt>
        <dd></dd>

        <dt>Node</dt>
        <dd>A device that implements IP; specifically IPv6 in the case of this specification.</dd>

        <dt>Link Voucher</dt> 
        <dd>
          A data payload intended to be distributed by a responsible node on-link. Details are statefully maintained
          on host network interfaces and used in both generating and verifying VBAs.
        </dd>

        <dt>Hextet</dt>
        <dd>A 16-bit aggregation; data that is 16 bits in size. Can also be called a 'chomp'.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Voucher-Based Addressing</name>
      <t>
        This section outlines the design goals of Voucher-Based Addressing. It includes concrete processes and
        procedures used by VBA-enabled network nodes to verify address ownership and to simultaneously create
        private, pseudo-random network addresses.
      </t>

      <section anchor="summary-overview">
        <name>Design Overview</name>
        <t>
          A Voucher-Based Address is defined as any IPv6 unicast address derived from on-link voucher information.
          The address derivation process is driven by a static, well-known procedure parameterized by a mixture of
          voucher details and public node information. This same derivation process is used by other on-link nodes
          to independently verify the link-layer binding of the address during the Neighbor Discovery Address
          Resolution process.
        </t>
        <t>
          Because deterministic address generation directly depends on the value of the link-layer identifier of the
          node, purported network and target link-layer addresses cannot be falsified in NDP exchanges. Address
          verification is a process parameterized by (1) data which identifies the node's network interface, and (2)
          data which lies OUTSIDE of the generating node's administration. Such information comprises a part of the
          Link Voucher details agreed upon by all neighbors.
        </t>
        <t>
          Consider the following dishonest transactions a node on a VBA-enabled network might consider:
        </t>
        <ul>
          <li>Generating a false link-layer address. </li>
        </ul>
      </section>

      <section anchor="summary-generate">
        <name>Address Generation</name>
        <t>
          This section discusses the generation procedure and composition of a VBA.
        </t>
        <figure>
          <name>The Voucher-Based Address Generation Procedure</name>
          <!-- TODO -->
          <artwork type="ascii-art" name="vbaGeneration.txt">
            <![CDATA[

Address composition:
          PREFIX    //      SUFFIX (64 bits)
    +------ ~ ------+-------------+---------------------+
    | 64-bit prefix | Z (16 bits) |     H (48 bits)     |
    +------ ~ ------+-------------+---------------------+

... where:
    PREFIX = The 64-bit subnet prefix. If the prefix is shorter
              than 64 bits, the rest of the 64-bit field MUST be
              initialized to 0.
    SUFFIX = The first 8 bytes from the result of a Key Derivation
              Function (KDF) 'K' iterated 'L' times. The leftmost
              hextet is replaced by the bitwise complement of 'Z'.

Formulas:
H      = K(L, Key, Salt)
         |---> K    = A KDF specified by the Link Voucher.
         |---> L    = A random, host-selected 'iterations count'.
         |---> Key  = The 128-bit Link Voucher seed value.
         `---> Salt = [LLID] || 'v' || 'b' || 'a' || [PREFIX]

Z      = ~(L ^ H[2..3])

SUFFIX = hextets{ Z, H[2..3], H[4..5], H[6..7] }
                        `--> (using 0-based indexing)

            ]]>
          </artwork>
        </figure>
        <t>
          The Interface Identifier (IID) for all VBAs, called a SUFFIX, embeds two important details for verification:
        </t>
        <ul>
          <li>
            <t>
              A 16-bit 'Z' value, calculated as a bitwise complement of the XOR of the 'L' value and the second hextet
              of the hash 'H'. This calculation uses XOR with the 'H' result to ensure the same iteration count will be
              unique and provide some resistance to tracking hosts between each generated hash.
            </t>
            <ul>
              <li>
                The 'L' value (also called 'iterations count' in this document) is an important value. This parameter
                controls how many times the KDF function is iterated to produce the resulting hash. Increasing this
                value increases both the work required to generate the VBA and the work required to find potential
                hash collisions.
              </li>
            </ul>
          </li>
          <li>
            48 bits from the resulting hash, or 'H' value, derived from the KDF after 'L' iterations. Implementations
            are REQUIRED to use the FIRST 8 bytes of the hash in formulating the SUFFIX value, replacing the first
            hextet with the 'Z' value as shown in the figure.
          </li>
        </ul>
        <t>
          The address generation algorithm is detailed procedurally as follows:
        </t>
        <ol>
          <li>A host connects to a VBA network and obtains Link Voucher <xref target="addenda-voucher"/> details.</li>
          <li>The 'L' value is chosen based on (1) host preference, (2) intended difficulty, or (3) randomly.</li>
          <li>The Link Voucher details contain instructions for which KDF to use and which seed value to use.</li>
          <li>
            <t>
              The KDF Salt is a variable-length CONCATENATION of a few different values. 'Raw' values indicate
              binary values, NOT hexademical string notations of the values.
            </t>
            <ul spacing="compact">
              <li>
                The raw link-layer identifier of the network interface for which addresses are being generated.
                Note that since the Salt value is a variable-length string, this is NOT REQUIRED to be a MAC
                address, but it MUST represent the link-layer address to which the IPv6 address will be bound.
              </li>
              <li>The string "vba" as a big-endian value.</li>
              <li>The raw PREFIX (subnet prefix) value. This MUST match the prefix for which the VBA will be generated.</li>
            </ul>
          </li>
          <li>
            <t>
              The final address SUFFIX is computed:
            </t>
            <ul spacing="compact">
              <li>The first 16 bits are a bitwise complement of an 'iterations count' value.</li>
              <li>
                The least significant 48 bits are 6 sequential bytes from the result the KDF, skipping the first two
                bytes in the sequence.
              </li>
            </ul>
          </li>
        </ol>
      </section>

      <section anchor="summary-verify">
        <name>Address Verification</name>
        <t>This section provides a procedural overview of VBA address verification. Two important relative terms will
          need to be established for the sake of clarity:</t>
        <dl>
          <dd>Client Node</dd>
          <dt>The node resolving the link-layer address of a neighbor; sends the initial Neighbor Soliciation packet.</dt>
          <dd>Target Node</dd>
          <dt>The node supplying its target link-layer address in a responding Neighbor Advertisement.</dt>
        </dl>
        <t>
          VBA address verification MUST only performed during the Address Resolution phase of an NDP exchange, where
          enabled on the local interface. Verifying an address entails reconstructing the address generation procedure
          run by the target node and ensuring the produced address is equivalent to the one solicited.
        </t>
        <figure>
          <name>The Voucher-Based Address Verification Procedure</name>
          <!-- TODO -->
          <artwork type="ascii-art" name="vbaVerification.txt">
            <![CDATA[

 ,-- [advertise] <--.
 V       (2)        |
|A|{LV}            |B|{LV}{MAC}
 |                  |      |
 +----> [solicit] --'  <===|=== (solicited node multicast)
 |         (1)             |
 |                         |
 |     +~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~+
 `---->| H := K(           |           |
       |   L := iters(B),  |           |
       |   LV->seed,  v----'           |
       |   makeSalt(MAC, prefix(B))    |
       | );                            |
       +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
           |
           `----> +~~~~~~~~~~~~~~~~~~~~~~~+
                  | suffix(Z(L), H) === B |
                  +~~~~~~~~~~~~~~~~~~~~~~~+
                   {????}
                    |  |
DROP <-- false <----'  `---> true --> ACCEPT/CACHE

            ]]>
          </artwork>
        </figure>
      </section>

      <section anchor="summary-binding">
        <name>Link-Layer Bindings &amp; Controversies</name>
        <t>
        </t>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface-level Configurations</name>
        <t>
        </t>

        <section anchor="summary-interfaces-state">
          <name>Preserving Voucher-Related State</name>
          <t>
          </t>
        </section>

        <section anchor="summary-interfaces-mode">
          <name>Enforcement Modes</name>
          <t>
          </t>

          <section anchor="summary-interfaces-ago">
            <name>Address Generation Only (AGO)</name>
            <t>
            </t>
          </section>

          <section anchor="summary-interfaces-agv">
            <name>Address Generation &amp; Verification (AGV)</name>
            <t>
            </t>
          </section>

          <section anchor="summary-interfaces-agvl">
            <name>Address Generation &amp; Verification with Levels (AGVL)</name>
            <t>
            </t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable VBA functionality.</t>

      <section anchor="addenda-voucher">
        <name>Link Voucher Option</name>
        <t>
          The Link Voucher (LV) option specifies the address generation (and consequent verification)
          parameters which on-link hosts should agree upon when generating their addresses.
        </t>

        <figure>
          <name>Structure of the NDP Link Voucher option</name>
          <!-- TODO -->
          <artwork type="ascii-art" name="linkVoucherOption.txt">
            <![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |    Length     |   Pad Length  |   Reserved    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                                                               .
    .                        CGA Parameters                         .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                                                               .
    .                           Padding                             .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>

        <dl newline="true">
          <dt>Type</dt><dd>63</dd>
          <dt>Length</dt><dd>The total length of the LV from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <!-- TODO: Add all parameter definitions per LV specification. -->
        </dl>

        <section anchor="addenda-voucher-senders">
          <name>Processing Rules for Senders</name>
          <t>
            Senders of Link Vouchers MUST maintain stateful information about their LVs at all times, so reliable and consistent
            LV details can be sent at any time. The rotation of stable LV information, such as the Seed value or Expiration details,
            SHOULD be signaled in advance using the LOVMA group <xref target="lovma-packets-pvr"/>. Transferral of LV responsibility
            to another LV identifier SHOULD use similar means <xref target="lovma-packets-vha"/>.
          </t>
          <t>The Sender's LV MUST always be unique on-link and NEVER be forwarded or duplicated copies of other LVs.</t>
          <t>
            Sending nodes wishing to distribute a Link Voucher MUST first check the local link for an already-active LV. This
            entails following a process of router discovery, then only assuming LV responsibility if no LV is already present.
          </t>
          <ol spacing="compact">
            <li>Send a Router Soliciation to the All Routers multicast group at FF02::2.</li>
            <li>Wait for an LV for at least 2 seconds before sending another Soliciation.</li>
            <li>
              <t>Repeat this process 2 more times.</t>
              <ul spacing="compact">
                <li>If an LV is received within a Router Advertisement response, accept and use the parameters of the received LV.
                  This condition means the sender MUST NOT send their own LV, nor should it propagate any instances of LV options.</li>
                <li>
                  <t>If no LV is received after the 3 total attempts, and...</t>
                  <ul spacing="compact">
                    <li>the Sender IS NOT a router: the Sender's LV may be distributed on the local link as an option attached
                      to an appropriate NDP Redirect packet.</li>
                    <li>the Sender IS a router: the Sender may attach its LV to an appropriate NDP Router Advertisement packet.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ol>
          <t>
            On-link nodes responsible for an LV (also known as Voucher Bearers (VBs) -- see the VB section <xref target="bearers"/>)
            MUST respond to Router Soliciation packets. This is true regardless of  whether the VB is using a Redirect or Router
            Advertisement to distribute its LV.
          </t>
          <t>
            Protecting the link from rogue LVs is crucial to securely maintain the full consensus of the local network.
            See the section on RA-Guard <xref target="bearers-vigilance"/> and LV Hijacking <xref target="security-usurp"/>
            for more details.
          </t>
        </section>

        <section anchor="addenda-voucher-receivers">
          <name>Processing Rules for Receivers</name>
          <!-- TODO -->
          <t>
            Receiving nodes MUST statefully maintain and update all LV information per-link, if and only if the received LV is
            successfully verified according to its cryptographic signature.
          </t>
          <t>A Link Voucher option appearing with any packet except NDP Router Advertisements or NDP Redirects MUST be ignored.</t>
          <t>
            Nodes acting as authorized Voucher Bearers <xref target="bearers"/> MUST disregard any received LV options on the links
            for which they are already the responsible VB.
          </t>
        </section>

        <section anchor="addenda-voucher-kdfs">
          <name>Algorithm Settings</name>
          <t>
          </t>

          <section anchor="addenda-voucher-kdfs-pbkdf2">
            <name>PBKDF2</name>
            <t>
            </t>
          </section>

          <section anchor="addenda-voucher-kdfs-argon2d">
            <name>Argon2d</name>
            <t>
            </t>
          </section>

          <section anchor="addenda-voucher-kdfs-scrypt">
            <name>Scrypt</name>
            <t>
            </t>
          </section>
        </section>

        <section anchor="addenda-voucher-signatures">
          <name>Voucher Signatures</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-voucher-expirations">
          <name>Voucher Expirations</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="addenda-summary">
        <name>ND Voucher Summary Option</name>
        <t>
        </t>

        <section anchor="addenda-summary-senders">
          <name>Processing Rules for Senders</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-summary-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
          </t>
        </section>
      </section>
    </section>

    <section anchor="behavioral">
      <name>Behavioral Neighbor Discovery Changes</name>
      <t>
      </t>

      <section anchor="behavioral-send">
        <name>Changes Adopted from SEND</name>
        <t>
        </t>

        <section anchor="behavioral-send-nonce">
          <name>Nonce Option</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-send-levels">
          <!-- See Section 8 of RFC 3971. -->
          <name>Secured &amp; Unsecured Distinctions</name>
          <t>
            Section x of the SEND RFC <xref target="RFC3971"/> defines a
          </t>
        </section>
      </section>

      <section anchor="behavioral-cache">
        <name>Protecting the ND Cache</name>
        <t>
          The primary verification goal of VBAs results in a symmetric computation that can be costly for
          low-power nodes or other embedded systems. By requiring address verification ONLY when interacting
          with the local Neighbor Cache, nodes do not need to perform the entire verification procedure as
          frequently.
        </t>
        <t>
          This section discusses some behavioral NDP changes regarding the host's Neighbor Cache. The changes
          are aimed at a balanced mixture of optimization and security.
        </t>

        <section anchor="behavioral-cache-receiving">
          <name>Receiving Neighbor Solicitations</name>
          <!-- DO NOT EAGERLY CACHE WITHOUT VERIFYING. -->
          <t>
          </t>
        </section>

        <section anchor="behavioral-nud">
          <name>Neighbor Unreachability Detection</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-cache-unsolicited">
          <name>Receiving Unsolicited Traffic</name>
          <t>
            Any node receiving unsolicited traffic from a neighbor, for which no response is required from
            the receiver -- such as UDP-based applications -- does not need to interact with the VBA system
            at all. The receiving node MAY choose to validate the sender according to this specification.
            This would necessitate the neighbor verification process be conducted in reverse.
          </t>
          <t>
            If the sending neighbor is already in the receiver's neighbor cache, then the receiver SHOULD
            NOT verify the address of the sender.
          </t>
          <t>
            As stated in this document's introduction <xref target="intro"/>,
            VBA employment primarily supplies privacy-focused address generation and uses neighbor address
            verification to provide proof of address ownership. The goal is to prevent on-path attackers
            from illegally, ACTIVELY intercepting local network traffic. Therefore, receiving packets for
            which no response is necessary does not merit an explicit requirement that the sending neighbor
            be verified.
          </t>
        </section>
      </section>

      <section anchor="behavioral-dad">
        <name>Duplicate Address Detection</name>
        <t>
          When generating a VBA, the node MUST follow the ordinary means of Duplicate Address Detection (DAD)
          specified by the SLAAC RFC (section 5.4 of <xref target="RFC4862"/>). The DAD procedure SHOULD follow
          any other applicable DAD optimizations (<xref target="RFC4429"/>, <xref target="RFC7527"/>, etc.).
        </t>
        <t>
          Upon detecting a duplicate address, VBA-enabled nodes are forced by necessity to select another
          iterations count value to generate a non-conflicting address. This can become computationally expensive
          to recompute iteratively based on the amount of address collisions, or in the case of denial of service
          attacks. To counter this weakness, implementations MUST keep the 4 leading or trailing address computations
          cached during the DAD procedure. Implementations SHOULD always prefer the leading computations, because
          they are intermediate computations already required in order to produce the address at the final
          iterations count. This is as opposed to computing an extra 4 address values on the trailing side which
          may or may not be used based on DAD results.
        </t>
        <t>A figure representing this process visually is shown below:</t>
        <!-- TODO: Insert ASCII art figure. -->
        <t>
          To further cement this optimization procedure, an example DAD collision follows.
        </t>
        <ol>
          <li>A new network host has received Link Voucher details; the voucher specifies using PBKDF2.</li>
          <li>The host arbitrarily selects 0xFF04 as its input link-local iterations count.</li>
          <li>The host will iterate the PBKDF2 function through 0xFEFF.</li>
          <li>When retrieving the PBKDF2 cipher output for 0xFF00 (L - 4) iterations, it will cache this value.</li>
          <li>It will do the same for the next 3 iterations counts (0xFF01, 0xFF02, &amp; 0xFF03).</li>
          <li>It will compute the final PBKDF2 round at 0xFF04 iterations, and will use the result to generate
            a valid VBA <xref target="summary-generate"/>.</li>
          <li>When following the DAD procedure, a collision is detected.</li>
          <li>The host then falls immediately back to the L - 1 iterations count of 0xFF03 to generate the VBA.</li>
          <li>This new host address is completely different and does not register a DAD collision.</li>
          <li>The optimization has successfully removed he need to recompute the PBKDF2 algorithm up to the new
            iterations count, saving a significant amount of time in the VBA-enabled SLAAC process.</li>
        </ol>
        <t>
          If all 5 iterations counts result in DAD collisions, then the node MUST give up and use some other
          implementation-specific course of action to contact an administrator or log a system management error.
        </t>
        <t>
          Note that truly benign DAD collisions are a dangerous prospect for Voucher-Based Addressing. Address
          collisions imply that a separate link-layer identifier with the SAME iterations count has somehow
          generated a hash suffix collision, exposing the possibility for node impersonation in a rare occurrence.
          Some implementations MAY wish to find trusted ways to detect such an occurrence, possibly by means
          of intermediate device monitoring (such as switching hardware), and take action based on it.
        </t>
        <t>
          Nodes encountering a duplicate address will by necessity require a different iterations count to
          generate their current address. If the node uses a 'sticky' iterations count, then it is RECOMMENDED
          that it send a gratuitous VSR update to the LOVMA with the new count <xref target="lovma-packets-vsr"/>.
        </t>
        <t>
          A discussion regarding denial of service attack vectors related to DAD in VBA networks is found in
          another section <xref target="security-dos-dad"/>.
        </t>
      </section>
    </section>

    <section anchor="lovma">
      <name>Local On-link Voucher Multicast Address (LOVMA)</name>
      <t>
      </t>

      <section anchor="lovma-purpose">
        <name>Definition &amp; Purpose</name>
        <t>
        </t>
      </section>

      <section anchor="lovma-constraints">
        <name>Constraints</name>
        <!-- no sending unicast responses, unidirectional channel; membership optional -->
        <t>
          Care should be taken when utilizing the LOVMA for any purpose, experimental or deployed,
          to regard the following constraints:
        </t>
        <ul spacing="compact">
          <li>LOVMA traffic is considered unidirectional. Nodes SHOULD NOT send unicast responses in reply to multicast traffic.
            This recommended constraint acts to prevent asymmetric traffic volume and potential denial of service vulnerabilites
            leveraging the LOVMA.</li>
          <li>VBA-enabled nodes MUST NOT assume that other VBA-enabled nodes are subscribed to the LOVMA multicast group.</li>
          <li>Subscribing nodes MUST NOT offer any trust of LOVMA packets, unless a datagram validation procedure is explicitly
            declared for the extension protocol using the LOVMA.</li>
        </ul>
      </section>

      <section anchor="lovma-packets">
        <name>Defined Datagrams</name>
        <t>
        </t>

        <section anchor="lovma-packets-vsr">
          <name>Voucher Status Reports (VSRs)</name>
          <t>
          </t>
        </section>

        <section anchor="lovma-packets-vha">
          <name>Voucher Handoff Advertisements (VHAs)</name>
          <t>
          </t>
        </section>

        <section anchor="lovma-packets-pvr">
          <name>Preemptive Voucher Rotations (PVRs)</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="lovma-extensibility">
        <name>Extensibility &amp; Experimentation</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="bearers">
      <name>Voucher Bearers</name>
      <t>
      </t>

      <section anchor="bearers-vigilance">
        <name>Vigilance &amp; RA-Guard</name>
        <t>
        </t>
      </section>

      <section anchor="bearers-unorthodox">
        <name>Unorthodox Bearers</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="optimizations">
      <name>Specification Optimizations</name>
      <t>
      </t>

      <section anchor="optimizations-dad">
        <name>Duplicate Address Detection Caching</name>
        <t>
          The SLAAC DAD process is optimized to reduce the burden of regenerating another VBA from scratch.
          See <xref target="behavioral-dad"/> for how this optimization functions as part of the core VBA
          specification.
        </t>
      </section>

      <section anchor="optimizations-lovma">
        <name>Conveying Voucher-Related Information via the LOVMA</name>
        <t>
        </t>
      </section>

      <section anchor="optimizations-kdfs-et-al">
        <name>Choosing Key Derivation Functions &amp; Parameters</name>
        <t>
        </t>
      </section>

      <section anchor="optimizations-summaries">
        <name>Voucher Summary Options</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Mechanisms</name>
      <t>
      </t>
    </section>
    
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>
      </t>

      <section anchor="security-solutions">
        <name>How VBAs Balance Privacy &amp; Security</name>
        <t>
        </t>

        <section anchor="security-solutions-proof">
          <name>Proof of Address Ownership</name>
          <t>
          </t>
        </section>

        <section anchor="security-solutions-privacy">
          <name>Privacy-Focused Addresses</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="security-binding">
        <!-- From SEND:
            SEND does not compensate for an unsecured link layer.  For instance,
            there is no assurance that payload packets actually come from the
            same peer against which the NDP was run.
            Likewise, VBAs rely on the principle that link-lyer addresses MUST be unique on the same broadcast medium.
            VBAs offer great protection for unsecured L2 setups, but link-layer security would help to remediate further concerns.
        -->
        <name>Use of Link-Layer Bindings</name>
        <t>
        </t>
      </section>

      <section anchor="security-usurp">
        <name>Hijacking Link Vouchers</name>
        <t>
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
        </t>

        <section anchor="security-dos-dad">
          <name>Duplicate Address Detection</name>
          <!-- This spec leans on other DAD protection mechanisms. -->
          <t>
            The computational cost of generating VBAs can be abused by a malicious threat actor using DAD mechanisms.
          </t>
        </section>

        <section anchor="security-dos-grand">
          <name>Gratuitous Neighbor Discovery</name>
          <!-- RFC 9131 considerations. -->
          <t>
          </t>
        </section>
      </section>

      <section anchor="security-static">
        <name>Static Addressing</name>
        <t>
        </t>
      </section>

      <section anchor="security-collisions">
        <name>Hash Collisions</name>
        <t>
        </t>
      </section>

      <section anchor="security-fairness">
        <name>Computational Fairness</name>
        <t>
        </t>
      </section>

      <section anchor="security-pki">
        <name>Certifying Link Vouchers</name>
        <t>
        </t>
      </section>

      <section anchor="security-anycast">
        <name>Anycast Addresses</name>
        <t>
          Anycast addresses are allocated from the unicast address space and are thus indistinguishable to
          nodes establishing connections to them. NDP exchanges with these hosts may therefore respond with
          varying Target Link-Layer Address options and cause VBA verification to be unreliable.
          For this reason, it is NOT RECOMMENDED to utilize anycast addresses for on-link prefixes within
          VBA-enabled networks, because the ownership of the address cannot be bound to a particular
          link-layer identifier.
        </t>
        <t>
          The IPv6 Addressing Architecture RFC <xref target="RFC4291"/> outlines a Required Anycast Address
          in Section 2.6.1. VBA-enabled links SHOULD maintain compatibility with this requirement by disabling
          verification for on-link subnet anycast addresses. For example, a host using SLAAC to generate an
          address in the subnet 2001:db8:700::/64 SHOULD disable VBA expectations and verifications for the
          address 2001:db8:700::. Because VBA protections must be disabled for this target host, implementations
          SHOULD avoid using the subnet Required Anycast Address altogether.
        </t>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
      </t>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4429.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7527.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9131.xml"/>
        <!-- key-derivation crypto resources -->
      </references>
      <!-- <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
          </front>
        </reference>       
      </references> -->
    </references>
    
    <section anchor="appendices">
      <name>Appendices</name>

      <section anchor="appendices-a">
        <name>Appendix A</name>
        <t>
        </t>
      </section>
    </section>
 </back>
</rfc>
