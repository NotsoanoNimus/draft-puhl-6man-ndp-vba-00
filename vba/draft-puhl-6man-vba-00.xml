<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
  <!ENTITY times  "&#215;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-vba-00"
  ipr="trust200902"
  obsoletes=""
  updates="4862"
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <link rel="describedBy" href="https://doi.org/10.3390/network4030016"/>
  <front>
    <title abbrev="vba">IPv6 Voucher-Based Addressing During SLAAC</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-vba-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>
        <email>zpuhl@umich.edu</email>
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <author fullname="Jeremy Duncan" initials="J." surname="Duncan">
      <organization>Tachyon Dynamics</organization>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>slaac</keyword>
    <keyword>privacy</keyword>
    <keyword>vba</keyword>
    <abstract>
      <t>
        Voucher-Based Addressing updates the Stateless Address Autoconfiguration) SLAAC process (RFC4862) with a new, extensible stable IPv6
        address generation and verification methodology called a voucher. A "voucher" is distributed to nodes on
        a local link to provide local-scope generation instructions. Nodes use these instructions,
        their own link-layer identifiers, and self-determined work factor values to create
        sets of pseudo-random, non-reversable, deterministic addresses for each on-link prefix. This process
        is driven by quantum resistant cryptographic key derivation functions which intentionally lengthen
        address computation times. Each output address is bound to its inputs by hashing, with
        binding details being verifiable by neighbors while simultaneously appearing random
        to off-link parties.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        Voucher-Based Addressing (VBA) offers local IPv6 networks both a common procedure
        for binding Link-Layer Identifers (LLID) to IP addresses, as well as privacy-focused
        IP address autoconfiguration for both stable and ephemeral addresses. The usefulness of
        the former is expressed in Neighbor Discovery Protocol (NDP) transactions, which resolve
        LLIDs corresponding to queried IP addresses. The usefulness of the latter is articulated
        well in specifications like <xref target="RFC7217"/>, <xref target="RFC7721"/>,
        <xref target="RFC8064"/>, and <xref target="RFC8981"/>.
      </t>
      <t>
        This document intends to update <xref target="RFC4862"/> to introduce a new address assignment
        methodology. It describes an application of cryptographic key-stretching techniques and
        link-local configuration distribution to the IPv6 SLAAC process (<xref target="RFC4862"/>),
        creating a many-to-one relationship between an interface's IP addresses and its underlying
        LLID. This relationship is created in such a way that only neighbors on the same broadcast
        domain can confirm its validity, and external actors will be unaware of its existence entirely.
      </t>

      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
          "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>",
          "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>

      <section anchor="intro-background">
        <name>Background</name>
        <t>
          This document assumes the reader's basic familiarity with the following specifications.
        </t>
        <ul spacing="compact">
          <li>IP Version 6 Addressing Architecture <xref target="RFC4291"/>.</li>
          <li>IPv6 Stateless Address Autoconfiguration <xref target="RFC4862"/>.</li>
          <li>Semantically Opaque Interface Identifiers <xref target="RFC7217"/>.</li>
          <li>Security and Privacy Considerations for IPv6 Address Generation Mechanisms <xref target="RFC7721"/>.</li>
          <li>Recommendation on Stable IPv6 Interface Identifiers <xref target="RFC8064"/>.</li>
          <li>Temporary Address Extensions for Stateless Address Autoconfiguration in IPv6 <xref target="RFC8981"/>.</li>
          <li>PKCS #5: Password-Based Cryptography Specification Version 2.1 <xref target="RFC8018"/> (primarily Sections 3 and 4).</li>
          <li>The Argon2 Key Derivation Function <xref target="RFC9106"/>.</li>
          <li>The Scrypt Key Derivation Function <xref target="RFC7914"/>.</li>
        </ul>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <t>
        To acquire necessary context, please see Section 2.1 of <xref target="RFC4861"/> for
        definitions of the following terms used equivalently in this document: neighbor, node,
        interface, link, address, router, host, on-link, off-link, IP, ICMP, packet, and target.
      </t>
      <dl newline="true">
        <dt>VBA</dt>
        <dd>Voucher-Based Addressing. The primary address generation and verification concept
          introduced by this document.</dd>

        <dt>LLID</dt>
        <dd>A shorthand representation for the terms "Link Layer Address" or "Link Layer Identifier".
          Both terms are synonymous and describe any individual link-layer identifier for a
          connected network interface.</dd>

        <dt>SLAAC</dt>
        <dd>Stateless Address Autoconfiguration <xref target="RFC4862"/>.</dd>

        <dt>ND(P)</dt>
        <dd>Neighbor Discovery (Protocol) <xref target="RFC4861"/>.</dd>

        <dt>RS, RA, NS, and NA</dt>
        <dd>Respectively: Router Solicitation, Router Advertisement, Neighbor Soliciation, and
          Neighbor Advertisement. A collection of abbreviations for ICMP packet types defined
          by NDP in <xref target="RFC4861"/>.</dd>

        <dt>DAD</dt>
        <dd>Duplicate Address Detection (Section 5.4 of <xref target="RFC4862"/>).</dd>

        <dt>LV</dt>
        <dd>Link Voucher. A data payload disseminated at the link-local scope by a Voucher Bearer,
            containing instructions for assigning interface SLAAC addresses.</dd>

        <dt>VB</dt>
        <dd>Voucher Bearer. The on-link node solely responsible for dissemination of Link Vouchers.</dd>

        <dt>LOVMA</dt>
        <dd>Local On-link Voucher Multicast Address. A multicast group used by VBA-capable hosts
          to get non-essential information from neighbors or the current Voucher Bearer.</dd>

        <dt>VHA</dt>
        <dd>Voucher Handoff Advertisement. A type of data payload sent by the VB to the LOVMA,
          signing off on an election process for new LV parameters and/or a new link VB.</dd>

        <dt>KDF</dt>
        <dd>Key Derivation Function, as defined in Section 5 of <xref target="RFC8018"/>.</dd>

        <dt>Hextet</dt>
        <dd>A 16-bit aggregation; data that is 16 bits in size.</dd>

        <dt>RA-Guard</dt>
        <dd>The Router Advertisement Guard mechanism, as specified in <xref target="RFC6105"/>.</dd>
      </dl>
      <t>
        NOTE: Any use of the terms 'IP', 'DHCP', or 'ICMP' in the following sections of this
        document are synonymous with 'IPv6', 'DHCPv6', and 'ICMPv6', respectively. When
        referencing the legacy IPv4-based versions of these protocols, it will be explicitly noted.
      </t>
    </section>

    <section anchor="summary">
      <name>Voucher-Based Addressing</name>
      <t>
        The following outlines the design goals of Voucher-Based Addressing. It reviews the primary mechanisms
        driving the proposal and discusses related requirements for its adoption. It includes concrete processes
        and procedures used by VBA-capable network nodes to both verify neighbor bindings and to auto-generate
        their own VBAs.
      </t>

      <section anchor="summary-overview">
        <name>Design</name>
        <t>
          A Voucher-Based Address is defined as any unicast IP address derived from a hashed combination of
          known voucher information, a subnet prefix, a work factor selection, and a bound LLID. The address
          derivation process is underpinned by a deterministic procedure parameterized by these values. This
          same derivation procedure is employed independently by neighbors to verify purported address bindings.
        </t>

        <section anchor="summary-overview-binding">
          <name>Link-Layer Address Bindings</name>
          <t>
            Voucher-Based Addresses are generated by using the LLID of the underlying, assigned interface as a
            partial input. VBA assumes two citicial functions on a network: first, that LLIDs must be unique to a 
            single node on the same broadcast domain at any given time in order for higher-level protocols to successfully operate; 
            and second, that the LLID MUST operate with a minumum of 64-bits. In order for VBA to peroperly generate addressing there cannot be less than 64-bits of LLID.
            Also, due to the assumption of link uniquness, any node actively occupying an LLID on-link is considered
            the 'owner' of its LLID. Therefore, VBAs can be directly formed and authenticated from this 'identity'.
          </t>
          <t>
            This new 'identity' becomes instrumental when neighbors must resolve an IP address (or set of them)
            to a valid LLID. For example, during Neighbor Discovery Address Resolution, the goal is to associate
            a Target IP with a corresponding LLID to which frames can be forwarded at the link layer (see Section
            7.2 of <xref target="RFC4861"/>). Because VBAs are bound to (i.e., derived from) an LLID, neighbors
            can directly verify any LLID received during NDP transactions to confirm whether the target IP address
            deterministically descends from it. This becomes a simplistic way to detect address spoofing attacks.
          </t>
        </section>

        <section anchor="summary-overview-cryptography">
          <name>Hash Function Selection &amp; Ephemeral Addressing</name>
          <t>
            Binding LLIDs to IPs by using a simple embedding or hashing scheme would suffice if VBA were only
            for binding verification. For example, modified EUI-64 interface identifiers use a long-established
            address derivation methodology that incorporates the LLID of an underlying interface (Section 2.5.1 of
            <xref target="RFC4291"/>). While these may provide LLID bindings, VBA augments this concept to enforce
            a privacy-focused address generation technique, obscuring the node's LLID while also encouraging ephemeral
            addressing. VBA employs hashing during the address generation process to create pseudo-random addresses.
            A hash-based address forbids outside trackers from determining the original LLID of the node and also
            ensures that any input LLID of arbitrary length can be deterministically reduced to an IP address suffix
            that is fixed at 64 bits in length.
          </t>
          <t>
            A known "voucher" holds certain values that are also used as a component of the hash function's input. VBA
            strikes a careful balance of hiding any voucher information from off-link nodes while ensuring voucher
            visibility to on-link nodes. Off-link actors thus cannot acquire the VBA's bound LLID because they do not
            know the details of the voucher used to generate them, nor can they compute the LLID from the address itself.
            Generated VBAs will always appear to be randomly assigned, with little pattern between selected work factors
            and vouchers.
          </t>
          <t>
            Because hashing would only produce a one-to-one LLID-to-IP binding, this document elevates the use of
            simple hashing for SLAAC address generation to the use of Key Derivation Functions (KDFs). These bring about
            a set of one-to-many LL2IP bindings, since KDFs can accept work factor values specifying how many times
            the pseudo-random function or underlying hash function must be iterated <xref target="RFC8018"/>.
            VBA computes KDFs with various inputs that specifically identify a neighbor's on-link interface, and the
            result of the KDF is planted into its generated VBA(s). Work factor selections are embedded into resultant
            IPs adjacent to KDF outputs, such that the following three components are inherent to any generated VBA:
          </t>
          <ul spacing="compact">
            <li>The interface's Link-Layer Address (LLID).</li>
            <li>A portion of the KDF's hash output.</li>
            <li>The work factor used when computing the KDF hash.</li>
          </ul>
        </section>
        
        <section anchor="summary-overview-64biiid">
          <name>Interface Identifiers &amp; the 64-bit Requirement</name>
          <t>
            There are numerous effrots to extend the 64 bit host boundary to utlize for futher subnetting, or adding an option for a variable-length interface ID. 
            There are current efforts discussing a solution in <xref target="draft-mishra-v6ops-variable-iids-problem-statement"/>. A condition of using VBA means that the network, node, and router
            MUST NOT allow for LLIDs to be less than 64 bits. Meaning if the prefix is further subnetted into a /80 prefix it cannot function properly with VBA as there will not be the proper space 
            to convey both the 48-bit H and 16-bit L value later outlined.
      </section>

      <section anchor="summary-generate">
        <name>Address Generation</name>
        <t>
          The mechanism below outlines the process for VBA composition and the VBA generation procedures.
        </t>
        <figure>
          <name>The Voucher-Based Address Generation Procedure</name>
          <artwork type="ascii-art" name="vbaGeneration.txt">
            <![CDATA[
Address composition:
          PREFIX    //      SUFFIX (64 bits)
    +------ ~ ------+-------------+---------------------+
    | 64-bit prefix | Z (16 bits) |     H (48 bits)     |
    +------ ~ ------+-------------+---------------------+

  where:
    PREFIX is the 64-bit subnet prefix. If the subnet length is
              shorter than 64-bits, then the rest of the 64-bit
              field MUST be initialized to a pseudo-random value.
              If the subnet length is longer than 64-bits then VBA 
              MUST NOT be utilized.
    SUFFIX is the first 8 bytes from the result of a Key Derivation
              Function 'K' iterated 'L' times. The leftmost hextet
              is replaced by 'Z'.

Formulas:
    H  =  K(L, Key, Salt)
          |---> K    = A KDF explicitly specified by a voucher.
          |---> L    = A node-selected KDF work factor.
          |---> Key  = The 128-bit voucher seed value.
          `---> Salt = [LLID] || 'v' || 'b' || 'a' || [PREFIX]

                          (where '||' represents concatenation)

    Z  =  ~(L ^ Key[0..1])

    SUFFIX = hextets{ Z, H[2..3], H[4..5], H[6..7] }
                            `--> (using 0-based indexing)
            ]]>
          </artwork>
        </figure>
        <t>
          The VBA SUFFIX embeds two necessary details for its verification:
        </t>
        <ul>
          <li>
            <t>
              A 16-bit 'Z' value, calculated as a bitwise complement of the XOR of the 16-bit
              'L' value and the first hextet of the interface's current LV seed. This calculation
              uses an XOR operation to ensure that the same work factor 'L' between different LV
              seeds will be unique. This provides some resistance to tracking if a node chooses
              to consistently use the same work factor value.
            </t>
            <ul>
              <li>
                The work factor, or 'L' value, controls how many times the KDF 'K' is iterated
                to produce the resulting hash 'H'. Increasing this value increases the work required
                to generate and verify a VBA, as well as the cost of finding its potential collisions.
              </li>
            </ul>
          </li>
          <li>
            48 bits from the resulting hash, or 'H' value, derived from the KDF after 'L' iterations.
            Implementations are <bcp14>REQUIRED</bcp14> to use the FIRST 8 bytes of the hash when
            formulating the SUFFIX value, replacing the hash's first hextet with the 'Z' value.
          </li>
        </ul>
      </section>

      <section anchor="summary-verify">
        <name>Address Verification</name>
        <t>
          "Verification" of an address can occur whenever a node would like to confirm the
          validity and currency of an IP address according both the current Link Voucher and
          the neighbor's purported LLID. One example of where this process might be useful is
          during the NDP address resolution process, where an LLID is returned by a neighbor
          in an answer to a solicitation of an IP address' link-layer location.
        </t>
        <t>
          Address verification uses public information to locally
          reconstruct VBA(s) with the address generation algorithm. This known information includes
          any neighbor's IP (VBA), their LLID, and the locally stored voucher. The work factor
          used to compute the address can be extracted from the VBA using all known information,
          explained by the function Z' below. If the locally reconstructed
          VBA does not exactly equal the neighbor's VBA, then the bindings
          between the current LV, the IP address, the purported LLID, and the work factor
          <bcp14>MUST</bcp14> be considered invalid.
        </t>
        <dl newline="true">
          <dt><tt>Z'(B, LV) = ~(B[8..9] ^ LV.seed[0..1])</tt></dt>
          <dd>Calculates the original work factor 'L' from the given VBA 'B'. The value 'B[8..9]'
            is equal to bytes 9 and 10 (bits 64-79, inclusive) of 'B'. The 'LV' represents the
            locally-stored Link Voucher on the verifying host, and 'seed[0..1]' is the first hextet
            of the LV's seed value.</dd>
        </dl>
      </section>

      <section anchor="summary-interfaces-state">
        <name>Preserving Link Voucher State</name>
        <t>
          VBA-capable interfaces are <bcp14>REQUIRED</bcp14> to store the full state of the
          most current, validated Link Voucher whenever one's presence is detected. This <bcp14>MUST</bcp14>
          occur even if the node does not intend to use VBA address generation or verification.
          If no LV is available, then no stored LV state is maintained and the node <bcp14>MUST</bcp14>
          fall back to another temporary method to generate its IP addresses. Once an LV subsequently
          becomes available, the node <bcp14>MAY</bcp14> elect to generate VBAs on its interface, but
          it <bcp14>MUST</bcp14> track the voucher's state regardless.
        </t>
        <t>
          LV details <bcp14>MAY</bcp14> also be set statically on an interface. In such cases, the static
          information <bcp14>MUST</bcp14> contain at least a VoucherID, Voucher Seed, and Algorithm Type
          specification. Any interface with static details configured <bcp14>MAY</bcp14> ignore received
          LVs. Static LVs <bcp14>MUST</bcp14> always be considered active and preferred; they <bcp14>MUST
          NOT</bcp14> expire.
        </t>
      </section>

      <section anchor="summary-interfaces-acquisitions">
        <name>Link Voucher Acquisitions</name>
        <t>
          Link Vouchers are <bcp14>REQUIRED</bcp14> to be attached to all Router Advertisement and Redirect messages by VBs.
          Nodes connecting to the link for the first time are <bcp14>REQUIRED</bcp14> to accept and
          cache the first LV received. If the connecting node intends to maintain responsibility for
          the LV as a VB, then it <bcp14>MUST</bcp14> follow the requirements and processes outlined in
          <xref target="addenda-voucher-senders"/>. The current LV can be discovered by sending a plain
          Router Solicitation message, or waiting for a Router Advertisement, per normative SLAAC procedures.
          Nodes receiving multiple valid LVs simultaneously <bcp14>SHOULD</bcp14> use the LV with the most
          recent Timestamp value.
        </t>
        <t>
          An active LV expires when no updated LV with the same 'VoucherID' has been received within the
          amount of seconds specified in the voucher's 'Expiration' field. When an expiration occurs, the
          node <bcp14>MUST</bcp14> again accept the first received LV. The 'Expiration' time can also elapse
          for an interface while it is disconnected from the link. If such an expiration occurs, then that
          interface <bcp14>MUST</bcp14> follow the same LV acquisition process.
        </t>
        <t>
          Because LV distribution to interfaces requires automatic trust of the VB, it is essential for
          more adversarial networks to implement some form of protection against distribution of unauthorized
          LVs at a lower or intermediate level. See <xref target="security-ra-guard"/> for more information.
          In the cases where these protective measures are not available, administrators <bcp14>MAY</bcp14>
          choose to set LV information on each node statically and <bcp14>MAY</bcp14> wish to enable some
          variant of intrusion detection.
        </t>
      </section>

      <section anchor="summary-interfaces-transitions">
        <name>Link Voucher Transitions</name>
        <t>
          The current Voucher Bearer <bcp14>MAY</bcp14> at any time delegate its responsibility to another
          node (see <xref target="lovma-packets-vha"/>). During the period of transition between the previous
          LV and the new one, VBA-capable nodes which are subscribed to the LOVMA channel <bcp14>SHOULD</bcp14>
          receive VHA multicast packets specifying the parameters of the new LV and VB. These LOVMA-connected
          interfaces are strongly <bcp14>RECOMMENDED</bcp14> to allow both LVs to be cached, so that VBAs
          generated using either LV are verifiable. These interfaces are also strongly <bcp14>RECOMMENDED</bcp14>
          to begin VBA generation with the new LV's parameters ahead of time.
        </t>
        <t>
          Link Voucher transitions <bcp14>MAY</bcp14> also be used in the case of the VB modifying the
          requirements for VBA generation, such as the Algorithm Type options or the voucher's seed value.
        </t>
        <figure>
          <name>Link Voucher Transitions</name>
          <artwork type="ascii-art" name="voucherTransitions.txt">
            <![CDATA[
  ==========================================> Time
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  ...   LV_A Validity        |
  ~~~|~~~~~|~~~~~X~~~~~~~~~~~Z
     |     |     +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     |     |     |      LV_B Validity       ...
     |     |     +~~~~~|~~~~~|~~~~~|~~~~~|~~~~~~~
  |==|=====|=====|=====|=====|=====|=====|===> Time
  |  O     O     O     O     O     O     O    ...
  |              |           |
  [ LV_A Active  [ Overlap   [ LV_B Active
 (1)            (2)         (3)

** 'X' marks the final advertisement for LV_A.
    Each 'O' at 'X' until and including 'Z' will
    include a VHA from the VB of LV_A.
** 'Z' marks the time at [X + LV_A.Expiration].
** 'O' indicates the advertisement of an LV on-link.

  Moments:
    1   = Link Voucher A is active for all nodes.
    2   = VHA. LOVMA-subscribed nodes become aware
           of a transition window. Both LV_A and
           LV_B are considered active LVs.
    3   = LV_A expires. Link Voucher B is active for
           neighbors and the transition completes.
            ]]>
          </artwork>
        </figure>
        <t>
          If another VHA appears indicating a third LV as appointed for election, receivers
          <bcp14>MUST</bcp14> ignore the VHA until one of the two LVs from the original VHA
          has expired. This prevents abuse which could flag several active LVs as being valid.
          Once the transition window ends, the amount of valid LVs <bcp14>MUST</bcp14> return
          from 2 to 1 before another transition can begin. The transition ends when the original
          voucher is intentionally not refreshed within its LV-specified Expiration time.
        </t>
        <t>
          The voucher transition provides an opportunity for optimization: if neighbors are
          aware of the upcoming voucher, then they <bcp14>MAY</bcp14> preemptively generate new
          VBAs in anticipation of the completed transition.
          For neighbors that are not receiving LOVMA datagrams, the voucher transition process
          is more akin to a hard handoff. These interfaces will not trust the new voucher until
          the previous one has expired, at which time any voucher becomes acceptable. For this
          reason, any VBAs preemptively generated with the upcoming LV might not be successfully
          verified by neighbors unaware of the transition, until the window has ended and the
          new voucher becomes primary. All implementations <bcp14>SHOULD</bcp14> parse VHAs in
          order to secure the transition process.
        </t>
        <t>
          If the current Voucher Bearer disconnects from the network or lets its voucher expire
          without an election, then the link becomes open and any neighbor can fill in the voucher
          void with its own. If no other VB assumes responsibility while the current VB is away or
          not transmitting updated vouchers, then all VBA-enabled interfaces <bcp14>MUST</bcp14>
          retain the most recent, valid voucher for the purposes of VBA generation and verification,
          until a new voucher becomes available.
        </t>
      </section>

      <section anchor="behavioral-dad">
        <name>Duplicate Address Detection</name>
        <t>
          When generating a VBA, the node <bcp14>MUST</bcp14> follow the ordinary means of
          Duplicate Address Detection (DAD) specified by the SLAAC RFC (section 5.4 of
          <xref target="RFC4862"/>). The DAD procedure <bcp14>SHOULD</bcp14> follow any other
          applicable DAD optimizations (<xref target="RFC4429"/>, <xref target="RFC7527"/>, etc.).
        </t>
        <t>
          Upon detecting a duplicate address during VBA generation, nodes <bcp14>MUST</bcp14>
          select another work factor 'L' value in order to create a non-conflicting address.
          Recomputing each new address for every collision can become computationally expensive,
          and can be abused in the case of denial-of-service attacks. To counter this weakness,
          implementations <bcp14>MUST</bcp14> employ one of two options based on the selected work factor:
        </t>
        <dl newline="true">
          <dt><tt>L &gt;  4</tt></dt>
          <dd>Cache the results of the 4 leading KDF iterations (L-4 through L-1).</dd>
          <dt><tt>L &lt;= 4</tt></dt>
          <dd>Cache the result of the KDF derived at the 'L' value only.</dd>
        </dl>
        <t>
          Implementations <bcp14>SHOULD</bcp14> always prefer the option where the work factor
          is greater than 4, because <tt>L-4</tt> through <tt>L-1</tt> produce intermediate KDF
          hashes that are already necessary in order to calculate the hash at the final 'L' value.
          Conversely, any 'L' value at or under 4 will cache the generated KDF hash at 'L' then
          increment the input 'L' by one for each DAD collision, up to 4 times.
        </t>
        <figure>
          <name>Using DAD with VBAs</name>
          <artwork type="ascii-art" name="duplicateAddressDetection.txt">
            <![CDATA[
COMPUTE & CACHE:
  N = Set of K(L', Key, Salt),
    where L' :=
      if L > 4 :  { L-4, L-3, L-2, L-1, L },
      else     :  { L }

           (1)      +~~~~~~~~~~~~~~+
 |A|{B}------------>| Normal SLAAC | (B :  Duplicate!)
  |     v-----------|  DAD Process | (B':  Success)
  |  [FAIL]  (2)    +~~~~~~~~~~~~~~+
  |                      ^
  `---> [cached (L-1)    |
         or new (L+1)    | (3)
         generates B'] --'
            ]]>
          </artwork>
        </figure>
        <t>
          In the figure, (1) shows node <tt>A</tt> engaged in DAD using the address <tt>B</tt>
          generated with <tt>L</tt>. After a collision is detected in (2), moment (3) shows the
          new VBA <tt>B'</tt> being immediately tried using the already-cached hash value from
          the work factor <tt>L-1</tt>. The DAD process is then successful and there are no
          duplicate addresses. The cost of computing <tt>L-1</tt> or some other input work factor
          has been avoided.
        </t>
        <t>
          If all 5 attempted input work factors result in DAD collisions, then the node
          <bcp14>MUST</bcp14> give up and use some other course of action to either contact
          an administrator or log a system management error.
        </t>
        <t>
          Protections to mitigate denial-of-service attacks based on DAD are beyond the scope of
          this document. However, the cost of the VBA generation procedure is safeguarded from being
          abused by DAD mechanisms or their misuses. Since VBAs do not modify the actual DAD process,
          other works regarding DAD denial of service protections will apply likewise when using VBAs.
        </t>
      </section>
    </section>

    <section anchor="addenda-voucher">
      <name>The Link Voucher Option</name>
      <t>
        The Link Voucher (LV) NDP option type describes the VBA generation and verification
        parameters which neighbors <bcp14>MUST</bcp14> use during the VBA-compliant SLAAC process.
      </t>
      <figure>
        <name>Structure of a local Link Voucher</name>
        <artwork type="ascii-art" name="linkVoucherOption.txt">
          <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |           Expiration          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                       Reserved (64 bits)                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                                                               |
  |                      128-bit Voucher Seed                     |
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                       TLV Algorithm Type                      <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  >                          DER-encoded                          <
  >                     PublicKey & Signature                     <
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]>
        </artwork>
      </figure>
      <dl newline="true">
        <dt>Type</dt>
        <dd>Link Voucher options are identified by Type ID 63</dd>
        <dt>Length</dt>
        <dd>The total length of the LV from the Type through its end, inclusive, in units of 8 octets.</dd>
        <dt>Reserved</dt>
        <dd>Denotes space reserved for future use. This value <bcp14>MUST</bcp14> be initialized to
          0 by senders and <bcp14>MUST</bcp14> be ignored by receivers.</dd>
        <dt>Expiration</dt>
        <dd>
          <!-- TODO: Point of attention. Should there be a minimum and maximum Expiration defined by this document? -->
          A 16-bit big-endian value storing the amount of time in seconds that the LV should be considered
          legitimate when an update has not been received. This value <bcp14>SHOULD</bcp14> be a minimum
          of 600 (10 minutes).
        </dd>
        <dt>Timestamp</dt>
        <dd>
          <!-- TODO: This might need to be more explicit about the time (e.g. units, epoch, etc.) -->
          A 64-bit value representing the system time of the sender upon sending the option.
        </dd>
        <dt>VoucherID</dt>
        <dd>
          A pseudo-random 32-bit value which uniquely identifies an LV instance. This <bcp14>MUST
          NOT</bcp14> change between distributions of the same LV instance and seed value.
        </dd>
        <dt>Seed</dt>
        <dd>
          A 128-bit pseudo-random value used as an input in VBA generation. This value <bcp14>MUST</bcp14>
          be the same for each distribution of an LV instance identified by a VoucherID. It <bcp14>MUST
          NOT</bcp14> be the same value across different LV instances.
        </dd>
        <dt>Algorithm Type</dt>
        <dd>
          Specifies the type and difficulty of the KDF to use in VBA generation.
          See <xref target="addenda-voucher-kdfs"/> for more details.
        </dd>
        <!-- TODO: Choose a different or variable asymm crypto type. Since it's a DER field, we can do w/e we want. -->
        <dt>ECDSA PublicKey &amp; Signature</dt>
        <dd>
          <t>
            A variable-length field containing a DER-encoded ECDSA <xref target="ECDSA"/> public key of
            type <tt>SubjectPublicKeyInfo</tt> according to Section 2 of <xref target="RFC5480"/>.
          </t>
          <t>
            The public key structure is followed immediately by an adjacent DER-encoded ECDSA signature,
            derived using the Private Key corresponding to PublicKey. The signature is computed over a
            series of sequential octets, constructed in the following order:
          </t>
          <ol spacing="compact">
            <li>The 16-bit 'Expiration' value.</li>
            <li>The 64-bit 'Timestamp' value.</li>
            <li>The 32-bit 'VoucherID' value.</li>
            <li>The 128-bit 'Seed' value.</li>
            <li>The full variable-length contents of the 'Algorithm Type' field,
              including its Type and Length values.</li>
          </ol>
          <t>
            The algorithm used in signature computation is ecdsa-with-SHA256, as defined in Section 3.2
            of <xref target="RFC5758"/>. The Signature <bcp14>MUST</bcp14> be a DER-encoded <xref target="ITU.X690.2002"/>
            ASN.1 structure of the type ECDSA-Sig-Value (Section 2.2.3 of <xref target="RFC3279"/>).
          </t>
          <t>
            The final field appears as the following two immediately adjacent DER structures:
          </t>
          <figure>
            <artwork type="ascii-art" name="keyStructure.txt">
              <![CDATA[
SubjectPublicKeyInfo  ::=  SEQUENCE  {
  algorithm         ::=  SEQUENCE {
    algorithm   OBJECT IDENTIFIER,
    parameters  ANY DEFINED BY algorithm OPTIONAL
  },
  subjectPublicKey  BIT STRING
}
ECDSA-Sig-Value  ::=  SEQUENCE  {
  r  INTEGER,
  s  INTEGER
}
              ]]>
            </artwork>
          </figure>
        </dd>
        <dt>Padding</dt>
        <dd>
          Any extra padding added to the structure in order to round its total length to an even
          8-octet boundary. Senders <bcp14>MUST</bcp14> initialize this value to 0. Receivers
          <bcp14>MUST</bcp14> ignore this field.
        </dd>
      </dl>

      <section anchor="addenda-voucher-senders">
        <name>Processing Rules for Senders</name>
        <t>
          Current Voucher Bearers <bcp14>MUST</bcp14> always respond to Router Soliciation messages
          with the most current LV instance. Nodes wishing to be VBs <bcp14>MUST</bcp14> always
          follow a sequence of steps before transmitting:
        </t>
        <ol spacing="compact">
          <li>Send a Router Soliciation to the All Routers multicast group at <tt>FF02::2</tt>.</li>
          <li>Wait for an existing voucher for at least 2 seconds before sending another RS.</li>
          <li>
            <t>Repeat this process 2 more times.</t>
            <ul spacing="compact">
              <li>
                If an LV is received within an RA or Redirect response, accept and use the
                parameters of the received LV. This condition means the Sender <bcp14>MUST NOT</bcp14>
                use or send its own vouchers, nor should it propagate any instances of received vouchers.
              </li>
              <li>
                <t>If no LV is received after the 3 total attempts, and...</t>
                <ul spacing="compact">
                  <li>the Sender IS NOT a router: the Sender's LV option will be distributed on the local
                    link as an option attached to an appropriate NDP Redirect message.</li>
                  <li>the Sender IS a router: the Sender will attach its LV option to an appropriate
                    NDP RA message.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        <t>
          A change of any "stable" voucher information -- i.e., the VoucherID, Seed value, or Algorithm
          Type details -- <bcp14>MUST</bcp14> be signaled in advance using the voucher transition process,
          per <xref target="summary-interfaces-transitions"/>. Expiration values <bcp14>MUST</bcp14> be
          set to an appropriate value. Senders <bcp14>MAY</bcp14> adjust this value without requiring a
          transition.
        </t>
        <t>
          The Sender's LV option <bcp14>MUST</bcp14> always be unique and <bcp14>MUST NOT</bcp14> be a
          forwarded or duplicated copy of another LV. Additionally, the voucher's Seed value <bcp14>MUST
          NOT</bcp14> be preserved between different VoucherIDs or handoffs. It <bcp14>MUST</bcp14>
          always be a random value when first associated with an LV VoucherID.
        </t>
      </section>

      <section anchor="addenda-voucher-receivers">
        <name>Processing Rules for Receivers</name>
        <t>
          An LV option appearing with any message except NDP Router Advertisements or Redirects
          <bcp14>MUST</bcp14> be discarded and ignored. Nodes acting as authorized VBs <bcp14>MUST</bcp14>
          disregard any received LV options on the links for which they are already the active VB.
        </t>
        <t>
          Receivers <bcp14>MUST NOT</bcp14> accept vouchers which contain any other public key details
          or signatures which do not use the same public key as the current VB. Received vouchers which
          contain different VBA generation parameters (VoucherID, Seed, Algorithm Type details)
          <bcp14>MUST</bcp14> be ignored and <bcp14>MUST NOT</bcp14> update any stored voucher state,
          even if the LV signature is valid. Likewise, expired vouchers <bcp14>MUST</bcp14> be ignored.
        </t>
        <t>
          Vouchers with invalid timestamp values <bcp14>MUST</bcp14> be ignored. Timestamps
          <bcp14>MUST</bcp14> be considered invalid if the value falls outside of the range
          <tt>[CURRENT_TIMESTAMP - LV_Expiration]</tt> to <tt>[CURRENT_TIMESTAMP + LV_Expiration]</tt>,
          where <tt>CURRENT_TIMESTAMP</tt> is the precise 64-bit system time measured by the Receiver.
          In cases where the precise system time is measured in sub-second intervals like microseconds,
          the unit of 'seconds' in the <tt>LV_Expiration</tt> time still applies and <bcp14>MUST</bcp14>
          be converted properly for accurate arithmetic with <tt>CURRENT_TIMESTAMP</tt>. This
          timestamping process ensures that voucher validity remains flexible even with minor clock
          drifting between neighbors.
        </t>
        <t>
          When a Receiver is subscribed to the LOVMA and is notified of a new voucher transition (by
          receipt of a valid VHA), it <bcp14>MUST</bcp14> ignore further LV options with the previous
          LV's VoucherID. This ensures the VB follows through with its commitment to expire the previous
          LV once the transition began.
        </t>
      </section>

      <section anchor="addenda-voucher-kdfs">
        <name>The Algorithm Type Field</name>
        <t>
          This section specifies the default algorithms and KDF types that <bcp14>MUST</bcp14> be
          packaged with all VBA implementations. Future versions or extensions of this document
          <bcp14>MAY</bcp14> add new KDF algorithms corresponding and Type IDs. Any Algorithm Type
          option not specified in this document or in future versions <bcp14>MUST</bcp14> be ignored
          by receivers.
        </t>
        <t>
          An Algorithm Type choice is formatted as a Type-Length-Value (TLV) object, where Type is a
          numeric identifier uniquely representing a KDF, Length is the width of the total Algorithm
          Type in units of 4 octets, and Value is a compact data format zero-padded to the nearest
          32-bit (4-octet) boundary. Receivers <bcp14>MUST</bcp14> always ignore padding and Senders
          <bcp14>MUST</bcp14> always initialize padded areas to 0.
        </t>
        <figure>
          <name>Structure of an Algorithm Type Option</name>
          <artwork type="ascii-art" name="algorithmOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Type             |             Length            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                             Value                             <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <t>
          The list of default KDF Algorithm Type Types and their associated parameters is given below. All
          fields named "Padding" <bcp14>MUST</bcp14> be initialized to 0 by senders and <bcp14>MUST</bcp14>
          be ignored by receivers.
        </t>
        <dl newline="true">
          <dt>PBKDF2_SHA256</dt>
          <dd>
            <t>
              The Password-Based Key Derivation Function (PBKDF2) is defined in Section 5.2 of <xref target="RFC8018"/>.
              It is a CPU-bound KDF, use of which can result in significant computation speed disparities
              across varying degrees of system resources. It is included primarily for portability,
              universality, and ease of implementation. This document explicitly uses PBKDF2 with SHA-256.
              Implementations using this Type <bcp14>MUST</bcp14> use SHA-256 as the underlying PBKDF2
              pseudo-random function.
            </t>
            <dl newline="true" spacing="compact">
              <dt>Type</dt><dd>1</dd>
              <dt>Length</dt><dd>2</dd>
              <dt>Value</dt>
              <dd>
                <dl newline="true" spacing="compact">
                  <dt>ITERATIONS_FACTOR</dt>
                  <dd>
                    A big-endian, 16-bit, unsigned integer as the multiplier of the selected work factor 'L'.
                    This value <bcp14>MUST</bcp14> be greater than 0; receivers of 0 values <bcp14>MUST</bcp14>
                    assume 1 instead.
                  </dd>
                  <dt>Padding (16 bits)</dt><dd></dd>
                </dl>
              </dd>
            </dl>
          </dd>
          <dt>Argon2d</dt>
          <dd>
            <t>
              The Argon2 algorithm is specified in Section 3 of <xref target="RFC9106"/>. It is a Memory-bound
              KDF which will ideally provide less disparate address computation speeds than CPU-bound algorithms
              like PBKDF2. Note that VBA explicitly opts to use Argon2d, rather than Argon2i or Argon2id.
              The work factor 'L' value is used as the 't' input for Argon2d computations. The Argon2 't' parameter
              indicates the number of passes and is used to increase the algorithm's running time regardless of
              MemorySize. To give the LV parameters in the Value field more weight, 't' <bcp14>MUST</bcp14> always
              be reduced from the input 'L' value as follows:
            </t>
            <t><tt>t := (L &gt;&gt; 8) + 1</tt></t>
            <t>
              The Argon2 parameters for Secret Value 'K' and Associated Data 'X' <bcp14>MUST NOT</bcp14> be used.
              The Tag Length 'T' for Argon2d <bcp14>MUST</bcp14> be set to 32 and <bcp14>MUST NOT</bcp14> vary.
            </t>
            <dl newline="true" spacing="compact">
              <dt>Type</dt><dd>10</dd>
              <dt>Length</dt><dd>2</dd>
              <dt>Value</dt>
              <dd>
                <dl newline="true" spacing="compact">
                  <dt>Parallelism</dt>
                  <dd>
                    An 8-bit, unsigned integer specifying how many degrees of parallelism (lanes) are allowed to
                    run during KDF computation. This value <bcp14>SHALL NOT</bcp14> be set to 0. Receivers
                    <bcp14>MUST</bcp14> consider values of 0 to automatically indicate a value of 1.
                  </dd>
                  <dt>MemorySize</dt>
                  <dd>
                    A big-endian, 24-bit, unsigned integer dictating the number of kibibytes (KiB) used in the KDF
                    computation. This value <bcp14>MUST</bcp14> be a minimum of <tt>8 * Parallelism</tt> and
                    <bcp14>MUST NOT</bcp14> be set to 0. Receivers <bcp14>MUST</bcp14> adjust the minimum MemorySize
                    accordingly if the value does not meet the minimum threshold for the specified Parallelism value.
                  </dd>
                </dl>
              </dd>
            </dl>
          </dd>
          <dt>Scrypt</dt>
          <dd>
            <t>
              The Scrypt KDF algorithm is specified in Section 6 of <xref target="RFC7914"/>. It is also a
              Memory-bound KDF. The work factor 'L' value is used in parts of the 'N', 'r', and 'p' inputs for
              Scrypt computations, as opposed to being used more linearly. Input KDF parameters are set by the
              following conversions:
            </t>
            <ul>
              <li><tt>N (Cost) := MAX(1 &lt;&lt; (MIN(11, MAX(1, ((L &amp; 0xFF00) &gt;&gt; 8) / 24))), 2) &lt;&lt; SCALING_FACTOR</tt></li>
              <li><tt>p (Parallelization) := MAX( 1, (L &amp; 0x00F0) )</tt></li>
              <li><tt>r (BlockSize) := MAX{ 1, (L &amp; 0x000F) )</tt><br /></li>
            </ul>
            <t>
              The Scrypt parameter 'dkLen' (derived key length) <bcp14>MUST</bcp14> always be set to 32 and
              <bcp14>MUST NOT</bcp14> vary.
            </t>
            <dl newline="true" spacing="compact">
              <dt>Type</dt><dd>20</dd>
              <dt>Length</dt><dd>2</dd>
              <dt>Value</dt>
              <dd>
                <dl newline="true" spacing="compact">
                  <dt>SCALING_FACTOR</dt>
                  <dd>
                    An 8-bit integer controlling the difficulty scaling of the Scrypt algorithm. This value
                    <bcp14>MUST</bcp14> only be 0 through 5 inclusive. Receivers <bcp14>MUST</bcp14> adjust
                    the maximum value to 5 if the received value is greater than 5.
                  </dd>
                  <dt>Padding (24 bits)</dt><dd></dd>
                </dl>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>
    </section>

    <section anchor="lovma">
      <name>Local On-link Voucher Multicast Address</name>
      <t>
        The LOVMA group is introduced to convey voucher-related updated between neighbors.
        All VBA-capable neighbors are strongly <bcp14>RECOMMENDED</bcp14> to join this group.
        However, current link VBs are always <bcp14>REQUIRED</bcp14> to join the LOVMA channel.
      </t>
      <t>
        This multicast group is located at the IP address <tt>FF02::ABBA</tt>. A helpful
        mnemonic to remember this address is to think of <tt>ABBA</tt> as a hexademical rendition
        of "a VBA".  The designated UDP port on which all LOVMA data is sent and received is <tt>2196</tt>.
      </t>

      <section anchor="lovma-constraints">
        <name>Constraints</name>
        <t>
          Nodes <bcp14>MUST</bcp14> regard these constraints when interacting with the LOVMA channel:
        </t>
        <ul>
          <li>LOVMA messages are considered unidirectional. Neighbors <bcp14>MUST NOT</bcp14> send
            unicast responses in reply to multicast traffic.</li>
          <li>LOVMA messages <bcp14>MUST</bcp14> be User Datagram Protocol (UDP) <xref target="RFC768"/>
            datagrams.</li>
          <li>Subscribing nodes <bcp14>MUST NOT</bcp14> assume that any other VBA-capable nodes
            are subscribed to the LOVMA group for any reason. However, neighbors <bcp14>MAY</bcp14>
            assume the presence of the current link VB on the LOVMA.</li>
          <li>Subscribing nodes <bcp14>MUST NOT</bcp14> offer unconditional trust of LOVMA messages.
            Each message type may specify its own method of establishing trust for its recipients.</li>
          <li>Senders are <bcp14>REQUIRED</bcp14> to send messages from a link-local VBA bound to the
            sending interface.</li>
        </ul>
      </section>

      <section anchor="lovma-packets">
        <name>Message Types</name>
        <t>
          All LOVMA datagrams <bcp14>MUST</bcp14> use a Type-Length-Value (TLV) format. Type is an
          8-bit integer identifying the datagram type, Length is an 8-bit integer specifying the
          length of the packet (including the Type and Length fields) in units of 4 octets, and
          Value is the data to be handled.
        </t>
        <t>
          The Type and Length fields <bcp14>MUST NOT</bcp14> be set to 0. Receivers <bcp14>MUST</bcp14>
          ignore datagrams with a Type of 0 or a Length of 0.
        </t>
        <figure>
          <name>Structure of LOVMA Datagrams</name>
          <artwork type="ascii-art" name="lovmaDatagramFormat.txt">
            <![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type     |     Length    |             Value             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+              ...              |
>                              ...                              <
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>

        <section anchor="lovma-packets-vci">
          <name>Voucher Capability Indications (VCIs)</name>
          <t>
            A node <bcp14>MAY</bcp14> notify the LOVMA channel about its potential candidacy
            as a Voucher Bearer by sending a VCI datagram. The VCI is an informational datagram
            <bcp14>REQUIRED</bcp14> for consideration of election by the current VB. An "election"
            means the VB will transfer ownership of the active LV to the candidate.
            Neighbors <bcp14>MUST NOT</bcp14> consider VCI packets as valid vouchers. The VB
            <bcp14>MAY</bcp14> maintain a state of unexpired VCI messages, especially when it
            intends to appoint a new neighbor as a successor VB. VBs <bcp14>MUST NOT</bcp14>
            elect a new VB without first receiving a VCI datagram indicating the Sender's readiness.
          </t>
          <t>
            Sending nodes <bcp14>MUST NOT</bcp14> assume that issuance of a VCI packet is a
            guaranteed appointment as the VB. The decision for election <bcp14>MUST</bcp14> be
            indicated by receipt of a signed VHA datagram from the VB, whose signature's public
            key matches that of the current, active LV.
          </t>
          <figure>
            <name>Structure of a VCI Datagram</name>
            <artwork type="ascii-art" name="lovmaVci.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                      Link Voucher Contents                    <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>1</dd>
            <dt>Length</dt><dd>Variable. The datagram length rounded up to the nearest 4 octets.</dd>
            <dt>Reserved</dt><dd>Space reserved for future use.</dd>
            <dt>Link Voucher Contents</dt>
            <dd>
              The entirety of the candidate ND Link Voucher option to be attached to future RAs or
              Redirects. This <bcp14>MUST</bcp14> also include the LV's Type and Length fields.
              Validation of this field follows the same rules outlined by <xref target="addenda-voucher"/>.
              Receivers <bcp14>MUST NOT</bcp14> expect the signature or public key of the LV to be
              the same as that of the current LV. Receivers <bcp14>MUST</bcp14> ignore the entire datagram
              if validation of the embedded LV fails for any reason, including invalid cryptographic
              signatures, null IDs, et al.
            </dd>
          </dl>
        </section>

        <section anchor="lovma-packets-vha">
          <name>Voucher Handoff Advertisements (VHAs)</name>
          <t>
            The VB <bcp14>MAY</bcp14> elect a new VB using the VHA message. This communication
            notifies subscribing VBA-capable nodes of a upcoming change in the active LV and possibly
            the VB of the LV. Candidates from election <bcp14>MUST</bcp14> be gathered from either manual
            sources or from senders of recent VCI datagrams. If the signature on the VHA is valid,
            listening nodes <bcp14>MUST</bcp14> accept the start of the handoff process whereby both
            VoucherID fields become temporarily valid. If the message signature field is not verifiable
            using the current VB's public key, then receivers <bcp14>MUST</bcp14> ignore the datagram.
            If there is no current LV and a VHA is received, then it <bcp14>MUST</bcp14> be ignored.
          </t>
          <t>
            The transition window duration is based on the 'Expiration' value of the current VB's LV at
            the time the VHA is sent. VHA retransmission frequency is variable but is <bcp14>RECOMMENDED</bcp14>
            to follow the same frequency as the node's previous RA or Redirect issuances. VBs initiating a
            transition <bcp14>MUST</bcp14> send at least one VHA notification every 5 seconds for a minimum
            of 3 minutes.
          </t>
          <t>
            When the elected node becomes aware of its upcoming appointment, it <bcp14>MUST</bcp14>
            begin sending RAs or Redirects with its LV attached. Sending these messages will always
            echo the receipt of a valid, unexpired VHA from the appointing VB. After 2 minutes,
            the new VB <bcp14>MUST</bcp14> consider LVs of the previous VB as invalid, and therefore
            <bcp14>MUST NOT</bcp14> trigger any more voucher advertisements driven by receipt of VHAs.
          </t>
          <t>
            VHAs <bcp14>MUST</bcp14> also be used to indicate a change in active voucher details by using
            the 'Refresh' bit. This indicates a transition between LV parameters from the same VB rather
            than a change of the responsible VB. Using the VHA for this purpose affords neighbors enough
            time to fully transition interface VBAs between varying voucher details, like in ordinary
            elections.
          </t>
          <figure>
            <name>Structure of a VHA Datagram</name>
            <artwork type="ascii-art" name="lovmaVha.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    |R|          Reserved           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    32-bit Signer VoucherID                    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                   32-bit Upcoming VoucherID                   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                                                               <
  >                     DER-encoded Signature                     <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>2</dd>
            <dt>Length</dt><dd>Variable. The datagram length rounded up to the nearest 4 octets.</dd>
            <dt>R (Refresh Bit)</dt>
            <dd>
              A single bit. When set, it indicates that the transition is only an LV refresh and is not
              a change of the VB.
            </dd>
            <dt>Reserved</dt><dd>15 bits of space reserved for future use.</dd>
            <dt>Timestamp</dt>
            <dd>
              <t>The current precise system time encoded as a 64-bit value.</t>
              <t>
                Timestamps <bcp14>MUST</bcp14> be considered invalid if the value is outside the range
                <tt>[CURRENT_TIMESTAMP - 120]</tt> to <tt>[CURRENT_TIMESTAMP + 120]</tt>, where
                <tt>CURRENT_TIMESTAMP</tt> is the precise 64-bit system time measured by the receiving
                node and <tt>120</tt> is in units of seconds. If the <tt>CURRENT_TIMESTAMP</tt> is
                measured in sub-second units like microseconds, then the <tt>120</tt> value
                <bcp14>MUST</bcp14> be converted appropriately.
              </t>
            </dd>
            <dt>Signer VoucherID</dt>
            <dd>
              The VoucherID of the VB's active LV. Nodes using this ID for their active LV
              <bcp14>MUST</bcp14> disregard any further advertised LVs with this value upon receiving a
              valid VHA datagram. A receiver <bcp14>MUST</bcp14> ignore this packet if the Signer VoucherID
              is not equal to that of the active LV.
            </dd>
            <dt>Upcoming VoucherID</dt><dd>The VoucherID of the new LV which is being appointed.</dd>
            <dt>ECDSA Signature</dt>
            <dd>
              <t>
                A variable-length field containing a DER-encoded ECDSA <xref target="ECDSA"/> signature,
                derived using the private key of the VB corresponding to the Signer VoucherID. The value
                of the public key is implied and expected to be known by receivers. The signature is
                computed over a series of sequential octets constructed in the following order:
              </t>
              <ol spacing="compact">
                <li>The 64-bit 'Timestamp' value.</li>
                <li>The 32-bit 'Signer VoucherID' value.</li>
                <li>The 32-bit 'Upcoming VoucherID' value.</li>
              </ol>
              <t>
                The algorithm used in signature computation is ecdsa-with-SHA256, as defined in Section 3.2
                of <xref target="RFC5758"/>. This field <bcp14>MUST</bcp14> be a DER-encoded
                <xref target="ITU.X690.2002"/> ASN.1 structure of the type ECDSA-Sig-Value (Section 2.2.3 of
                <xref target="RFC3279"/>).
              </t>
            </dd>
            <dt>Padding</dt><dd>Padding necessary to round the message size up to the nearest 4-octet boundary.</dd>
          </dl>
        </section>
      </section>
    </section>

    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This section covers VBA security topics which may not have had adequate exploration
        in the rest of the document.
      </t>

      <section anchor="summary-overview-collisions">
        <name>Collision Resistance &amp; Time-Memory Tradeoffs</name>
        <t>
          VBA generation only preserves 48 bits from a resultant hash. While a collision is
          unlikely, nodes treat this as they do the DAD process: even if it is unlikely, it
          is a possibility and must be handled appropriately. Potential hash collisions are
          a weakness of VBA verification because LLID binding is done through a deterministic
          hashing process and nothing else. In other words, any other spoofable LLID producing
          the same 48-bit 'H' portion of the VBA suffix will result in an equally valid VBA
          according to the verification procedure.
        </t>
        <t>
          KDFs are used for VBA generation for the added purpose of slowing collision discoveries.
          The tradeoff of requiring slightly more time for address computation in order to protect
          against brute-force collision enumeration is a strategy also recommended for use in
          password storage systems to protect user secrets (see <xref target="SP.800-132"/>).
          To prevent any possible time-memory tradeoff attacks, the voucher is rotated semi-regularly
          to maintain an ever-moving 128-bit salt value, so VBAs can never be pared down to a simple
          dictionary attack.
        </t>
        <t>
          An attacker searching for inputs that produce a colliding address is therefore subjected
          to the misery of enumerating many different LLIDs in order to generate a VBA that matches
          the target's 48-bit hash suffix. This resultant VBA must also embed the same work factor
          as its target because it is an explicit part of the VBA itself. If the target IP address
          contains a high work factor value, then this brute-force process will be even slower and
          more unlikely to succeed. All the while, collision-producing inputs must be obtained before
          the rotation of the curremt voucher, which will reset the attacker's marathon entirely.
        </t>
        <t>
          For example, 1-millisecond VBA generation times for the most resource-rich neighbors equates
          to attempting only 1,000 spoofed LLIDs per second (3,600,000 LLIDs per hour). If the LLID in
          this case were an IEEE 802 MAC address, then 3.6M attempted MAC addresses is equivalent to
          only about a millionth of a percent of all possible addresses (2<sup>48</sup> when not
          accounting for reserved MAC address ranges). At the same time, a 1-millisecond delay to
          verify the LLID as a legitimate binding to a given VBA is a very negligible amount of time.
        </t>
      </section>

      <section anchor="security-ra-guard">
        <name>Employing RA-Guard</name>
        <t>
          RA-Guard is an important addition to the voucher distribution system. An excerpt from
          the RA-Guard RFC is noted:
        </t>
        <blockquote>
          <xref target="RFC6105"/> describes a solution framework for
          the rogue-RA problem <xref target="RFC6104"/> where network segments are designed
          around a single L2-switching device or a set of L2-switching devices
          capable of identifying invalid RAs and blocking them.
        </blockquote>
        <t>
          Use of RA-Guard is primarily suggested for networks with a more adversarial security posture.
          The RA-Guard system <bcp14>SHOULD</bcp14> be augmented and deployed with VBA awareness,
          capable of tracking the state of LVs and LOVMA messages. This will allow an intermediate
          network device to only require RA-Guard Learning Mode for a short initial period. It can
          then subsequently "follow" the authorized LV around the link, blocking any other malicious
          or spurious LV option transmissions that do not make sense. This would mean the system
          should monitor all Router Advertisement and Redirect NDP messages and their attached
          options.
        </t>
        <t>
          One notable exception to this, however, is that an RA-Guard implementation <bcp14>MAY</bcp14>
          drop its protections if and only if the most recent and legitimate LV has expired without
          a successor. This is because some responsible VB needs to be free to supersede an expired LV.
        </t>
      </section>

      <section anchor="security-usurp">
        <name>Hijacking or Desynchronizing Link Vouchers</name>
        <t>
          Hijacking the VB role can be achieved by a few different means. Without RA-Guard, false VBs
          are free to constantly advertise their own vouchers onto the network. For neighbors already
          having an active voucher, this is only a problem if VHAs in the LOVMA are not being used and
          the current LV expires. For neighbors joining the network for the first time, there is a
          timing opportunity for attackers to "lock them in" before the legitimate VB can advertise.
        </t>
        <t>
          If a legitimate VB goes offline and is not able to transmit any updated vouchers to the network,
          then its current voucher can expire. When a voucher expires, VBA requires nodes to acquire the
          next available voucher. If a malicious neighbor uses denial-of-service attacks to force a VB
          offline for long enough, then it can force an expiration of the current voucher and gain control
          of it.
        </t>
        <t>
          There are numerous threat vectors available to wannabe malicious VBs:
        </t>
        <ul>
          <li>
            Denial of service attacks could result from setting LV parameters to an excessive difficulty.
            By asking local nodes to verify and generate VBAs according to absurd KDF options, ridiculous
            amounts of computing resources could be consumed and wasted. This could potentially consume
            enough resources on targets to temporarily force them offline.
          </li>
          <li>
            Having multiple vouchers on the same link will inevitably lead to different logical subnetworks,
            where nodes using one voucher are generating and verifying addresses according to a different
            set of parameters than another. If verifications are being used to verify neighbor identities,
            then this could potentially stop communications between neighbors entirely.
          </li>
          <li>
            If the difficulty of address generation is set to its absolute minimum, then bindings are
            cheapened for neighbors that use low work factor values because collisions would become easy
            to calculate.
          </li>
        </ul>
      </section>

      <section anchor="security-dos-overrotate">
        <name>Voucher Rotation Intervals</name>
        <t>
          Short voucher Expiration values are disallowed in LV options because of possible time
          synchronization issues between neighbors and to prevent an 'address generation storm'. This
          mechanism intends to prevent malicious VBs from over-rotating the current voucher and
          exhausting resources of neighbors who will be very busy trying to keep up with address
          generation. Employing long 'Expiration' windows also allows the VB to "go away" or disconnect
          for a longer period of time without dropping the current voucher.
        </t>
        <t>
          Likewise, excessive durations for Expirations <bcp14>SHOULD</bcp14> be limited in more
          adversarial networks in order to prevent threat actors from discovering address collisions
          which they could use to make some VBA verifications useless. A happy medium will ensure a
          plentiful pool of addresses for each neighbor, while also not letting it get stagnant.
        </t>
      </section>
    </section>

    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        This document defines a new Neighbor Discovery Protocol option type and one new link-local multicast
        address. The introduced Link Voucher option type contains another set of Type-Length-Value (TLV) packet options.
        The multicast address also uses other assigned TLV packets to convey important (but optional) protocol
        information.
      </t>
      <t>
        One new Neighbor Discovery Protocol option is defined in this document and must have a new Option Type
        value assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet Control
        Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Link Voucher option (63), described in <xref target="addenda-voucher"/>.</li>
      </ul>
      <t>
        The Link Voucher option includes a new option type used to convey KDF algorithm selections.
        Assigned in the "Algorithm Type Options" subregistry are string identifiers corresponding to integers
        which indicate their Algorithm Type values. Future values <bcp14>MUST</bcp14> be assigned according to the
        Standards Action policy of <xref target="RFC8126"/>. Default registrations are defined in this document:
      </t>
      <table anchor="IANA-algo-type-registrations">
        <name>Initial Values of the "Algorithm Type Options" Subregistry</name>
        <thead>
          <tr>
            <th>Type</th>
            <th>Name/Identifier</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td>VBAKDF_PBKDF2_SHA256</td>
          </tr>
          <tr>
            <td>10</td>
            <td>VBAKDF_ARGON2D</td>
          </tr>
          <tr>
            <td>20</td>
            <td>VBAKDF_SCRYPT</td>
          </tr>
        </tbody>
      </table>
      <t>
        See <xref target="lovma"/> for information about the Local On-link Voucher Multicast
        Address subscribed to by VBA-enabled network interfaces. This section will also contain
        specific packet formats.
      </t>
      <t>
        Assigned in the "Link-Local Scope Multicast Addresses" subregistry of the "IPv6 Multicast
        Address Space Registry":
      </t>
      <blockquote>
        Address(es): FF02::ABBA<br />
        Description: Local On-link Voucher Multicast Address<br />
        Reference: draft-puhl-6man-vba-00
      </blockquote>
      <t>
        The well-known UDP port 2196 is used for multicast traffic on the LOVMA channel. Assigned
        in the "Service Name and Transport Protocol Port Number Registry":
      </t>
      <blockquote>
        Service Name: vba_lovma<br />
        Port Number: 2196<br />
        Transport Protocol: UDP<br />
        Description: IPv6 Voucher-Based Addressing multicast updates<br />
        Reference: draft-puhl-6man-vba-00
      </blockquote>
      <t>
        A set of three TLV packet types used specifically in the new LOVMA channel are defined in
        this document. Assigned in the "LOVMA Message Types and Options" subregistry of the
        "Voucher-Based Addressing (VBA) Parameters" registry.
      </t>
      <t>
        The values in the "LOVMA Message Types and Options" subregistry are string identifiers
        corresponding to integers which indicate their packet Type values. Future values
        <bcp14>MUST</bcp14> be assigned according to the Standards Action policy of
        <xref target="RFC8126"/>. Default registrations are defined in this document:
      </t>
      <table anchor="IANA-lovma-registrations">
        <name>Initial Values of the "LOVMA Message Types and Options" Subregistry</name>
        <thead>
          <tr>
            <th>Type</th>
            <th>Name/Identifier</th>
            <th>Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td>LOVMA_VCI</td>
            <td><xref target="lovma-packets-vci"/></td>
          </tr>
          <tr>
            <td>2</td>
            <td>LOVMA_VHA</td>
            <td><xref target="lovma-packets-vha"/></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor="future">
      <name>Future Work</name>
      <t>
        This section provides an overview of related topics that might be explored in future work.
      </t>

      <section anchor="future-dhcp">
        <name>Deployments using DHCP</name>
        <t>
          Future work might wish to add features into DHCP servers that support delegating VBAs by
          using something like DHCP Snooping to ensure that only legitimate servers are assigning
          addresses. Because of its centrality and responsibility, a DHCP server would also be
          well-suited as the VB, especially if no connected router supports VBA.
        </t>
        <t>
          One notable change of generating VBAs server-side is the removal of client-side work factor
          selections. Allowing nodes to choose their own work factor values affords them
          the ability to randomize it according to their whims or retain a preferred work factor
          value. In a future proposal, DHCP client options could be amended to allow clients to
          request a work factor value, along with providing other important details to the server.
        </t>
      </section>

      <section anchor="future-pki">
        <name>Certifying Link Vouchers</name>
        <t>
          Future additions to this document could investigate the feasibility of PKI and certificates for signatures
          appearing on LV messages. This could include amendments to the LV structure which would extend the
          fields to convey trust anchor or certification path information. While VBA generally seeks to avoid
          the complexities introduced by PKI, it is perhaps a necessity for first-contact trust wherever RA-Guard
          or similar protections cannot be used. This is still a very performant use of certification paths
          since the certificate details are only verified during LV parsing when initially received.
        </t>
      </section>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/> <!-- NDP -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/> <!-- SLAAC -->
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8018.xml"/> <!-- PKCS#5: PW-based Crypto v2.1 -->
        <xi:include href="https://datatracker.ietf.org/doc/draft-mishra-v6ops-variable-iids-problem-statement/"/> <!-- SLAAC Prefixes with Variable Interface ID (IID) Problem Statement -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9106.xml"/> <!-- Argon2 -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7914.xml"/> <!-- Scrypt PBKDF -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/> <!-- IPv6 Addr Architecture -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7217.xml"/> <!-- Opaque IIDs with SLAAC -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7721.xml"/> <!-- Sec+Priv Consid for IPv6 Gen -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8064.xml"/> <!-- Rec. on Stable IPv6 IIDs -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8981.xml"/> <!-- Temp Addr Ext for SLAAC -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6104.xml"/> <!-- Rogue IPv6 RA Problem -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6105.xml"/> <!-- RA Guard -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4429.xml"/> <!-- Optimistic DAD -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7527.xml"/> <!-- Enhanced DAD -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5758.xml"/> <!-- X.509 PKI: EC/DSA -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.768.xml"/>  <!-- UDP -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3279.xml"/> <!-- Algos+IDs for X.509 PKI CRL -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5480.xml"/> <!-- ECC SubjectPublicKeyInfo -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/> <!-- IANA Section Guidelines -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/> <!-- BCP14 keywords -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/> <!-- BCP14 ambiguities -->
        <reference anchor="ITU.X690.2002" target="https://www.itu.int/rec/T-REC-X.690">
          <front>
            <title>Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER),
              Canonical Encoding Rules (CER), and Distinguished Encoding Rules (DER)</title>
            <author>
              <organization>International Telecommunications Union</organization>
            </author>
          </front>
        </reference>
        <reference anchor="ECDSA" target="https://doi.org/10.1007/s102070100002">
          <front>
            <title>
              The Elliptic Curve Digital Signature Algorithm (ECDSA)
            </title>
            <author fullname="Don Johnson" initials="D." surname="Johnson">
              <organization>Certicom Research, Canada</organization>
            </author>
            <author fullname="Alfred Menezes" initials="A." surname="Menezes">
              <organization>Certicom Research, Canada</organization>
            </author>
            <author fullname="Scott Vanstone" initials="S." surname="Vanstone">
              <organization>Certicom Research, Canada</organization>
            </author>
            <date year="2001" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/s102070100002"/>
        </reference>
        <reference anchor="SP.800-132" target="https://doi.org/10.6028/NIST.SP.800-132">
          <front>
            <title>
              Recommendation for Password-Based Key Derviation, Part 1: Storage Applications
            </title>
            <author>
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <date year="2010" month="December"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-132"/>
        </reference>
      </references>
    </references>

    <section anchor="appendix-code">
      <name>Code Snippets</name>
      <t>
        Source code demonstrating the VBA address generation and verification procedures,
        with assumed Neighbor Discovery Protocol support, can be found at
        https://github.com/NotsoanoNimus/voucher-based-addressing.
      </t>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The author would like to thank Dr. Jinhua Guo of the University of Michigan
        for his valuable, constructive feedback and support of this work.
      </t>
    </section>
  </back>
</rfc>
