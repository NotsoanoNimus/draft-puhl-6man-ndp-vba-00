<?xml version="1.0" encoding="utf-8"?>
<!-- 
     draft-rfcxml-general-template-standard-00
  
     This template includes examples of the most commonly used features of RFCXML with comments 
     explaining how to customise them. This template can be quickly turned into an I-D by editing 
     the examples provided. Look for [REPLACE], [REPLACE/DELETE], [CHECK] and edit accordingly.
     Note - 'DELETE' means delete the element or attribute, not just the contents.
     
     Documentation is at https://authors.ietf.org/en/templates-and-schemas
-->
<?xml-model href="rfc7991bis.rnc"?>  <!-- Required for schema validation and schema-aware editing -->

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
  <!ENTITY times  "&#215;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="exp"
  docName="draft-puhl-6man-ndp-vba-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndp-vba">IPv6 Voucher-Based Address Generation &amp; Verification</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndp-vba-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>vba</keyword>
    <keyword>spoofing</keyword>
    <keyword>privacy</keyword>
    <abstract>
      <t>
        This document specifies an extensible IPv6 unicast address generation and verification methodology for local
        networks. Individual link-layer identifiers are bound to sets of deterministic output addresses, which
        maintain user privacy regardless of link-layer identifier stability. Link Vouchers distributed by Router
        Advertisements form a shared consensus between neighbors of the parameters used in the SLAAC address
        generation process. Cryptographic key derivation functions are used to generate pseudo-random addresses and
        to intentionally stretch address computation times. Host parameters can be used to derive any number of both stable
        and ephemeral, privacy-focused addresses for each on-link prefix and at the link-local scope. NDP
        exchanges can then verify the link-layer-address-to-IP bindings to prevent on-path attacks in local
        networks.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <!-- TODO -->
      <t>
        Voucher-Based Addressing offers an alternative solution to the address ownership problem,
        enables extensible and private unicast address generation, and prevents on-path attacks in IPv6 local networks.
        Using a mutual key derivation function to map public input components to deterministic outputs, link-layer
        identifiers are reliably coupled to sets of IPv6 addresses and subsequently verified by neighboring nodes. All
        verifications are decentralized and do not require public-key cryptography; only shared consensus on a distributed,
        pseudo-random value used to seed the address generation procedure. Despite its determinism, this generation and
        verification process creates IPv6 addresses appearing statistically random to off-link devices, who are by design
        unaware of all input parameters associated with the address.
      </t>
      <t>
        This document thus represents a cross-application of cryptographic
        key-stretching techniques to link-layer address bindings in generating random IPv6 network addresses. The result
        is a secure, high-impact, low-complexity, optional complement to the Neighbor Discovery Address Resolution process,
        with very minimal changes to Neighbor Discovery options, formats, or behaviors. It is a proposed alternative to
        SEND <xref target="RFC3971"/>, CGAs <xref target="RFC3972"/>, and Semantically Opaque Interface Identifiers
        <xref target="RFC7217"/> in traditional LANs using "reactive" NDP, and it does not intend to obsolete any other document.
      </t>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <!-- TODO -->
      <t>
        Many of the terms in this document are defined in Section 2.1 of the most current NDP standard <xref target="RFC4861"/>.
      </t>
      <t>
        An alphabetical glossary of terms related to this document, but not necessarily defined herein, is specified in this
        section. Items appearing here may or may not be acronymized even in their first appearances in future sections (but
        never in section headers), so knowledge of them is assumed henceforth.
      </t>
      <dl newline="true">
        <dt>Voucher-Based Address (VBA)</dt>
        <dd>An IPv6 address generated by a mixture of Link Voucher details, network interface details, and subnet details.</dd>

        <dt>Link Voucher (LV)</dt> 
        <dd>A data payload intended to be distributed by a responsible node on-link. Details are statefully maintained
          on host network interfaces and used in both generating and verifying VBAs.</dd>

        <dt>Local On-link Voucher Multicast Address (LOVMA)</dt>
        <dd>A multicast group used by VBA-enabled hosts to get gratuitous information from the current Voucher Bearer or from
          other VBA-enabled neighbors.</dd>

        <dt>Voucher Bearer (VB)</dt>
        <dd>
          The on-link node solely responsible for dissemination of the LV and authorized by any potential link guarding to
          transmit Router Advertisements or Redirects with an LV attached.
        </dd>

        <dt>Voucher Status Report (VSR)</dt>
        <dd>A type of data payload sent by VBA-enabled nodes to the LOVMA. Shares information about the node's VBA-related
          preferences. Mainly used in optimizations and is an optional protocol feature.</dd>

        <dt>Interface Enforcement Mode (IEM)</dt>
        <dd>The operating mode of the VBA-enabled network interface controlling interface reactions to unverified neighbors.</dd>

        <dt>Neighbor</dt>
        <dd>Another connected node on the same link.</dd>

        <dt>Key Derivation Function</dt>
        <dd>Definition of the second term [REPLACE/DELETE]</dd>

        <dt>Link</dt>
        <dd></dd>

        <dt>Node</dt>
        <dd>A device that actively implements and uses IPv6 on the local network.</dd>

        <dt>Hextet</dt>
        <dd>A 16-bit aggregation; data that is 16 bits in size. Can also be called a 'chomp'.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Voucher-Based Addressing</name>
      <t>
        This section outlines the design goals of Voucher-Based Addressing. It reviews the primary mechanisms driving
        the specification and their design considerations. It discusses related requirements for network interfaces
        on-link. Lastly, it includes concrete processes and procedures used by VBA-enabled network nodes to verify
        address ownership and to simultaneously create private, pseudo-random network addresses.
      </t>

      <section anchor="summary-overview">
        <name>Protocol Design</name>
        <t>
          A Voucher-Based Address is defined as any IPv6 unicast address derived from on-link voucher information.
          The address derivation process is underpinned by a static, well-known procedure parameterized by a mixture
          of Link Voucher details and public node information. This same derivation process is used by other on-link
          nodes to independently verify the link-layer binding of the address during the ND Address Resolution process.
        </t>
        <t>
          This section will outline fundamental design goals aspiring to synergistically balance privacy and local
          network security. It will also discuss the mechanisms by which Voucher-Based Addressing realizes these
          goals.
        </t>

        <section anchor="summary-overview-binding">
          <name>Link-Layer Bindings</name>
          <t>
            VBAs are generated by using the link-layer identifier of the underlying, assigned interface as an input.
            They operate on the assumption that link-layer identifiers MUST be unique on the same broadcast domain at
            any moment in time, in order for higher-level protocols to successfully operate. Thus, VBAs are directly
            derived from this on-link 'identity'.
          </t>
          <t>
            The derivation process necessarily binds a generated IP address to a link-layer identifier. During the NDP
            Address Resolution process, the goal is to associate a Target Address with a corresponding link-layer address
            to which frames can be forwarded at the link layer (see Section 7.2 of <xref target="RFC4861"/>).
          </t>
          <t>
            Because deterministic VBA generation directly depends on the value of the link-layer identifier of the
            node, purported network and target link-layer addresses cannot be falsified in NDP address resolutions. Address
            verification is a process parameterized by (1) data which identifies the node's network interface, and (2)
            data which lies OUTSIDE of the generating node's administration. Such 'outside' information is listed in the
            Link Voucher details agreed upon by all neighbors.
          </t>
          <t>
            Due to this principle of link-layer address binding in generating VBAs, it is impossible to report an association
            of an IP address to a link-layer address that cannot be bound to it. This means NDP Address Resolution exchanges
            are safe from issues of impersonation. A host wishing to contact a particular IP address can no longer be subversively
            redirected to a different receiver at a lower level of the network stack.
          </t>
        </section>

        <section anchor="summary-overview-cryptography">
          <name>Key Derivation Functions &amp; Address Privacy</name>
          <!-- Touch on addresses using a hash function to gen PR addrs. Briefly review KDFs vs plain hashing. -->
          <t>
            Link-layer bindings using a simple embedding or hashing scheme should suffice if the goals of VBAs stopped at
            address ownership. For example, modified EUI-64 interface identifiers are formed by a long-established address
            derivation methodology which uses the link-layer identifier of an underlying interface; see Section 2.5.1 of
            <xref target="RFC4291"/>. However, a design goal of this document is to contemporaneously establish a
            privacy-focused address generation procedure that will obscure the link-layer identifier and create rotatable
            addresses.
          </t>
          <t>
            For this requirement, VBAs employ cryptographic hashing during the address generation process to create a
            pseudo-random output address. This address, while still relatively fixed and lacking dynamic derivation,
            does not immediately allow outside trackers to know the link-layer identifier of the node. Using cryptographic
            hashing and key derivation techniques also ensures that any link-layer identifier of arbitrary length could be
            reliably bound to an address suffix that is fixed at 64 bits in length.
          </t>
          <t>
            Hashing a link-layer identifier and producing an output will only create a one-to-one binding, but many IPv6
            address generation schemes already offer ways to derive MANY privacy-focused addresses from the link-layer
            identifier (see, e.g., section 5 and Appendix A.3 of  <xref target="RFC7217"/>). These addresses are usually NOT reversible,
            by design, unless reversing nodes are aware of all input parameters for the underpinning PRF. This is intended
            to preserve the privacy of the address.
          </t>
          <t>
            But VBAs strike a careful balance of (1) keeping off-link nodes unaware of local Link Voucher information used in
            private address derivation, and (2) ensuring on-link nodes ARE aware of all parameters used to generate an address.
            Off-link nodes will be unaware of the VBA's bound link-layer identifier -- because they cannot receive NDP messages
            nor can they determine it from the address itself -- and VBAs will always appear as random as a consequence of
            using the outputs of deterministic hash functions.
          </t>
          <t>
            More to the point, simple hashing is elevated to using key derivation techniques, which allow a set of one-to-many
            link-layer identifier to IP address bindings. This is because KDFs often accept an input iterations count that
            specifies how many times the PRF or hashing function should be iterated <xref target="RFC8018"/>. Iterations counts
            can then be embedded in resultant IP addresses, such that the following three components are an inherent value
            exchanged in any NDP Address Resolution communication:
          </t>
          <ul spacing="compact">
            <li>The Target Link Layer Address.</li>
            <li>A portion of the KDF output (using the other on-link input parameters).</li>
            <li>The Iterations Count used to compute the address.</li>
          </ul>
          <t>
            Addresses using this generation process therefore enforce that all three items are each the same input values -- along
            with on-link Link Voucher details -- to produce the same output address. Each increment or decrement of the embedded
            Iterations Count value produces an entirely new, seemingly random address. Nodes falsifying any of the input values
            will be rejected by enforcing neighbors seeking to resolve and verify link-layer addresses for certain target IP addresses.
          </t>
          <t>
            The VBA verification requirement in this document simply repeats the address generation procedure, using
            inputs known to the verifying node about the target node. As stated in the previous section, some of these
            parameters are indeed under the control of the target node; others are distributed on the network in a Link
            Voucher by a trusted authority.
          </t>
        </section>

        <section anchor="summary-overview-collisions">
          <name>Address Collisions</name>
          <t>
            VBA derivation only preserves 48 bits from a resultant hash. While a collision is unlikely, nodes treat
            this as they do the Duplicate Address Detection process: even if it is unlikely, it is possible and MUST
            be handled appropriately.
          </t>
          <t>
            Potential hash collisions expose a weakness of Voucher-Based Addressing. VBAs inherently bind 
            link-layer addresses upward to interface IP addresses through a deterministic process and nothing else
            -- i.e., there is no other mechanism used for certifying the resultant addresses. Thus, any other spoofable
            link-layer identifier producing the same 48-bit 'H' portion of the address suffix will result in an
            equally valid address according to the verification process.
          </t>
          <t>
            The employment of cryptographic KDFs drastically reduces the capacity for would-be attackers to discover
            address collisions and use them for malicious purposes (i.e., on-path attacks). Section 3 of <xref target="RFC8018"/>
            defines a Key Derivation Function in the exact manner it applies to this specification:
          </t>
          <blockquote>
              Another approach to password-based cryptography is to construct key
              derivation techniques that are relatively expensive, thereby
              increasing the cost of exhaustive search.  One way to do this is to
              include an iteration count in the key derivation technique,
              indicating how many times to iterate some underlying function by
              which keys are derived.
          </blockquote>
          <t>
            Thus KDFs are applied to VBAs for the added purpose of slowing collision discoveries. This same tradeoff
            of requiring slightly more time for address computation in order to protect against brute-force enumeration
            is a strategy also utilized by myriad password storage systems to protect user secrets (<!-- ref -->).
          </t>
          <t>
            To prevent any time-memory tradeoff attacks, the Link Voucher is distributed between nodes to ensure that
            generated addresses are always generously salted by a 128-bit pseudo-random value, as well as the subnet
            prefix, so they can never be pared down to a simple dictionary attack. This same value from the Link Voucher
            also rotates occasionally to prevent long-term attacks.
          </t>
          <t>
            An attacker searching for inputs producing a colliding address is therefore subjected to the misery of enumerating
            many different link-layer addresses in order to generate an IP address that matches the target's 48-bit hash suffix.
            This spoofed IP address must also embed the same iterations count as its target because it needs to be an equivalent
            IP. If the target IP address contains a high iterations count, then this searching process will be even slower and
            more unlikely to be successful. All the while, these collision-producing inputs must be obtained before the rotation
            of the Link Voucher seed, which will reset the attacker's marathon entirely.
          </t>
          <t>
            Link Vouchers also allow the specification of required on-link KDF algorithms and difficulties. This permits a
            dynamic adjustment of the base computation time required to derive or verify a VBA. For example, adjusting computation
            time to be approximately 20 milliseconds per address for the least powerful network node, and an estimated 1
            millisecond for the fastest, produces a negligible delay in processing legitimate Neighbor Discovery messages
            for all hosts. Simultaneously, this theoretical time taken to compute each address hamstrings any node,
            regardless of computing power, from being able to compute collisions expeditiously. This guarantees
            responsiveness while also protecting node address ownership.
          </t>
          <t>
            Following the above example, 1-millisecond address generation times for the most powerful on-link hosts
            equates to trying a mere 1,000 variable link-layer identifiers per second (3,600,000 addresses per hour). If
            the link-layer identifier in this case were a MAC address, 3.6M tried MAC addresses is equivalent to about a
            millionth of a percent of all possible addresses (2<sup>48</sup> when not accounting for reserved MAC addresses).
          </t>
        </section>

        <section anchor="summary-overview-adversaries">
          <name>Concerning Adversaries</name>
          <t>
            In an ideal network, VBA deployments would be unnecessary for the purpose of securing address ownership. One sample
            trust model which may disregard VBA verifications is a small enterprise network wherein all link-layer-address-to-IP
            bindings are entered statically. Another might be a private home network, where on-path attackers are very unlikely
            to be lurking.
          </t>
          <t>
            Address ownership applications notwithstanding, VBAs still offer a locally-verifiable manner of producing private
            unicast addresses which share no potential correlation in user activity between rotations. Such a method might find
            its own specific utilizations in other IPv6 protocols, the deployment of which could be easily adapted into support
            for this specification's address ownership mechanisms when are where such proof of ownership becomes necessary.
          </t>
          <t>
            The design choices for this specification cooperate to grant both: (1) a brute-force-resistant solution to IP
            address ownership in local networks, and (2) a deterministic generation of rotatable, privacy-focused addresses
            bound to link-layer identifiers. Item 2 is achieved as a byproduct of the VBA generation procedure, but Item 1
            requires some modifications to the way Neighbor Discovery functions; in particular, it places greater emphasis
            on guarding the Neighbor Cache.
          </t>
          <t>
            The application of VBAs against adversaries must be explored from a broad perspective before protocol
            specificities are introduced. Notably, this exploration assumes a hypothetical VBA deployment that is using the
            AGV Interface Enforcement Mode to enact full, strict protections on IPv6 address ownership
            (<xref target="summary-interfaces-mode"/>).
            With the context of the design goals of this document, of various NDP problem statements (Section 4 of
            <xref target="RFC3756"/>), and of IPv6 address privacy concerns (<xref target="RFC8064"/>):
            consider how Voucher-Based Addressing either proposes a resolution for a potential issue or encounters a
            drawback.
          </t>

          <section anchor="summary-overview-adversaries-false">
            <name>Falsifying Neighbor Discovery Messages</name>
            <t><tt>Sending Neighbor Advertisements or Solicitations with false link-layer addresses.</tt></t>
            <t>
              The sender of a NS can use a false Source Link-Layer Address option, while the sender of a NA can use a false
              Target Link-Layer Address option. Since NDP specifies optimizations or instructions to enter these into the Neighbor
              Cache on receipt (without verification), the protocol becomes vulnerable to abuse.
            </t>
            <t>
              VBAs on-link are a way to force this purported binding in NA/NS packets to be verified. This specification
              dictates that any cache-affecting ND instruction, or optimization to automatically accept link-layer address options,
              be shimmed with the VBA verification process first. NDP packets which fail VBA verification are subsequently
              dropped and do not update the Neighbor Cache.
            </t>
          </section>

          <section anchor="summary-overview-adversaries-nud">
            <name>Prolonging Attacks &amp; Lies</name>
            <t><tt>Asserting a false link-layer address in Neighbor Unreachability Detection packets.</tt></t>
            <t>
              Malicious nodes can extend impersonation attacks against the target node by responding to NUD probes in order
              to indicate continued reachability. Again, with VBAs this attack is not possible because of the imposed verification
              requirements. If a NUD probe detects any change in address bindings -- i.e., the malicious node responds with
              an IP or link-layer address that is different from the original cache entry -- the target node will drop the packet
              and will not update nor refresh its Neighbor Cache with the unverified information.
            </t>
          </section>

          <section anchor="summary-overview-adversaries-correlate">
            <name>Tracking Address or Device Activity</name>
            <t><tt>Correlating unicast address activities long-term on the public internet.</tt></t>
            <t>
              <xref target="RFC8064"/> discusses four primary problems of deriving IP addresses from link-layer identifiers:
              network activity correlation, location tracking, address scanning, and device-specific vulnerability exploitation.
              The applicability of this discussion, however, only applies to addresses from which ANY off-link node can derive
              the link-layer identifier directly. VBAs are created using an irreversible hashing function, and therefore
              link-layer identifiers are not recoverable by off-link nodes.
            </t>
            <t>
              Stable VBAs do not truly exist unless the Link Voucher on-link is also stable. In such a case, addresses being
              generated by the VBA derivation process are still considered statistically random. Nodes employing these addresses
              also have the choice to choose a different iterations count embedded within their addresses, changing them at-will
              despite the stable Link Voucher details.
            </t>
          </section>

          <section anchor="summary-overview-adversaries-kill">
            <name>Forcing Neighbors Offline</name>
            <t><tt>Nodes who are 'killed' or go offline are impersonated.</tt></t>
            <t>
              When a node goes offline, there is no consequence for a malicious node spoofing its link-layer identifier. This
              is a problem for this specification and for any other address ownership methodology relying on link-layer address
              bindings. It is indeed where more convoluted solutions relying on asymmetric cryptography, like Cryptographically
              Generated Addresses <xref target="RFC3972"/>, tend to thrive by certifying addresses NOT coupled to any link-layer
              attributes.
            </t>
            <t>
              VBA address ownership mechanisms are designed primarily to prevent active, TRANSPARENT spoofing; that is,
              to stop the interception of traffic between two online links without disrupting traffic between either party.
              As mentioned previously, VBAs do NOT certify link-layer address bindings, and they are based on the
              principle that two link-layer devices CANNOT share the same identifier at the same time. Certifying addresses
              or using other monitoring technologies to detect when nodes are 'killed'/spoofed at the link layer are topics
              beyond the scope of this specification.
            </t>
            <t>
              A point of emphasis about VBAs in this regard is their ability to control NDP traffic redirection attacks, without
              relying on a trust model that uses MAC address filtering or something similar. VBAs assume the network is always open
              to any link-layer address, and they aim to prevent the openness of the link-layer from being abused to spoof Neighbor
              Cache entries and to redirect Address Resolutions.
            </t>
            <t>
              To enforce long-term ownership in the face of this link-layer impersonation problem, Neighbor Discovery Sessions
              <!-- ref --> can be implemented as a complement to VBAs. See <xref target="security-sessions"/> for a deeper
              exploration of ND Sessions as applied to Voucher-Based Addressing.
            </t>
          </section>
        </section>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface-level Processes &amp; Configurations</name>
        <t>
          This section outlines different interface-level configurations and options which MUST be available in
          any implementation of this specification. It also discusses topics specific to caching Link Voucher
          information on local interfaces and outlines some specific details of the process. It is intended to
          explicitly dictate receiving-interface perspectives on different mechanisms presented in this document.
        </t>
        <t>
          Link Vouchers are defined in <xref target="addenda-voucher"/>.
        </t>

        <section anchor="summary-interfaces-mode">
          <name>Interface Enforcement Modes</name>
          <t>
            Per-interface modes (IEMs) are able to granularly dictate the local NDP behaviors related to VBAs.
            This flexibility in per-interface behavior grants VBAs more transition and adoption capabilities.
            A tiny state machine diagram would depict all of these states as being transitionable to any of
            the others.
          </t>
          <t>
            Implementations MUST allow nodes to independently opt into any one of the following IEMs for EACH
            of their local interfaces. The IEM state MAY also be specified on each interface statically, in which
            case all other automatic IEM state transitions MUST NOT apply.
          </t>
          <dl newline="true">
            <dt><tt>AAD - Address Awareness Disabled</tt></dt>
            <dd>The VBA-aware interface MUST NOT generate or verify any addresses, regardless of the incoming
              packets. It MUST NOT participate in any LOVMA traffic exchanges. In this mode, VBAs are ignored.
              This mode SHALL always be used by VBA-enabled interfaces on links without an established LV.</dd>

            <dt><tt>AGO - Address Generation Only</tt></dt>
            <dd>The address generation procedure is followed for unicast addresses. The NDP Address Resolution
              process MUST NOT be supplemented by VBA optimization or verification procedures.</dd>

            <dt><tt>AGV - Address Generation &amp; Verification</tt></dt>
            <dd>The address generation and verification procedures are followed as per this document. Address
              Resolution is REQUIRED to fail if the advertised target link-layer address cannot be successfully
              bound to the target IP address. This SHOULD be the default Enforcement Mode for interfaces.</dd>

            <dt><tt>AGVL - Address Generation &amp; Verification with Levels</tt></dt>
            <dd>Both address generation and verification procedures are employed, but verification failures MUST
              NOT be strictly enforced during NDP Address Resolution. Neighbors whose VBA(s) successfully verify
              MUST be marked or indicated locally as "Secured". A neighbor which fails to verify
              MUST be indicated as "Unsecured" and given less trust or authority than "Secured" responses.</dd>
          </dl>
          <t>
            For AGVL mode, the Secured and Unsecured distinction is adopted from SEND <xref target="RFC3971"/>.
            If an AGVL interface receives multiple Neighbor Advertisement responses, it MUST strongly prefer Secured
            NAs over Unsecured NAs to determine which link-layer address is legitimate during the Address Resolution
            process. If multiple Secured responses are received, each with different link-layer addresses, then there
            is a VBA collision and the behavior of the interface is undefined. In this rare case, the pool of Secured
            responses are equally valid VBAs, so it is left to the implementation to decide the correct course of action.
          </t>
        </section>

        <section anchor="summary-interfaces-state">
          <name>Preserving Voucher-Related State</name>
          <t>
            VBA-enabled interfaces for all nodes, regardless of their selected Interface Enforcement Modes, are
            REQUIRED to store the full state of the most current, validated Link Voucher. If a Link Voucher is not
            available on-link, then no stored LV state is required and the node MUST enter the Address Awareness
            Disabled state (see <xref target="summary-interfaces-mode"/>). If a LV subsequently becomes available,
            the node MAY choose to enter a different state or IEM based on the implementation.
          </t>
          <t>
            Link Voucher details MAY also be set statically on an interface. In such cases, the static information
            MUST contain at least a VoucherID, Voucher Seed, and Algorithm Type specification. Any interface with
            static details configured MUST ignore any received LVs on-link. Static LVs MUST always be considered in
            an 'active' state and MUST NOT expire.
          </t>
        </section>

        <section anchor="summary-interfaces-acquisitions">
          <name>Link Voucher Acquisitions</name>
          <t>
            Interfaces connecting to the network for the first time are REQUIRED to accept and cache the FIRST
            LV received on-link. If the interface intends to maintain responsibility for the LV as a VB, it MUST
            follow the process outlined in <xref target="addenda-voucher-senders"/>.
          </t>
          <t>
            If an active LV expires -- i.e., no updated LV has been received on-link within the amount of seconds
            specified in the 'Expiration' field of the most recent LV -- then the interface MUST again accept the
            first received LV. The Expiration time can also elapse while a non-VB host interface is disconnected
            from the link, and so that interface MUST follow the same process regardless of how LV expiration occurred.
          </t>
          <t>
            Because Link Voucher distribution to interfaces uses a 'first-come-first-serve' trust methodology,
            it is essential for adversarial networks, especially public networks, to implement some form of
            protection against rogue LVs at a lower or intermediate level. See <xref target="bearers-vigilance"/>
            for more information.
          </t>
          <t>
            In the cases where these protective mechanisms are not available, administrators MAY choose to set LV
            information on each node statically. Administrators in this sitation SHOULD also choose to employ
            some form of intrusion detection to better mitigate rogue LVs from appearing and affecting the
            local network.
          </t>
        </section>

        <section anchor="summary-interfaces-transitions">
          <name>Host Recipients &amp; Link Voucher Transitions</name>
          <t>
            The node responsible for the Link Voucher MAY at any time issue a handoff of that responsibility to
            another node (see <xref target="lovma-packets-vha"/>). During the period of transition between the
            previous Link Voucher and the upcoming one, VBA-enabled nodes which are subscribed to the LOVMA channel
            SHOULD receive VHA multicast packets specifying the new responsible node and LV. These LOVMA-connected
            nodes are strongly RECOMMENDED to allow both LVs to be cached so that VBAs generated using either LV
            are immediately valid. They are also strongly RECOMMENDED to begin address generation in anticipation
            of the upcoming LV becoming active.
          </t>
          <figure>
            <name>Link Voucher Transitions</name>
            <artwork type="ascii-art" name="voucherTransitions.txt">
              <![CDATA[
  ==========================================> Time
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  ...   LV_A Validity        |
  ~~~|~~~~~|~~~~~X~~~~~~~~~~~Z
     |     |     +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     |     |     |      LV_B Validity       ...
     |     |     +~~~~~|~~~~~|~~~~~|~~~~~|~~~~~~~
  |==|=====|=====|=====|=====|=====|=====|===> Time
  |  O     O     O     O     O     O     O    ...
  |              |           |
  [ LV_A Active  [ Window    [ LV_B Active
 (1)            (2)         (3)

** 'X' marks the final advertisement for LV_A.
    Each 'O' at 'X' until and including 'Z' will
    include a VHA from the VB of LV_A.
** 'Z' marks the time at [X + LV_A.Expiration].
** 'O' indicates the advertisement of a LV on-link.

  Moments:
    1   = Link Voucher A is active for all nodes.
    2   = VHA. LOVMA-subscribed nodes become aware
           of a transition window. Both LV_A and
           LV_B are considered active LVs.
    3   = LV_A expires. Link Voucher B is active for
           neighbors and the transition completes.
              ]]>
            </artwork>
          </figure>
          <t>
            If another VHA appears indicating a third LV as appointed for election, receivers MUST ignore the VHA
            until one of the two LVs from the original VHA has expired. This prevents VHA abuse which flags several
            active LVs on the same link as being valid, causing an 'address storm' that drains available computing
            resources from network nodes.
          </t>
          <t>
            Once the transition window ends, the amount of valid LVs will return from 2 to 1. The transition window
            ends when the original responsible node fails to refresh its LV within its LV-specified Expiration time
            (thus purposefully letting its LV expire).
          </t>
          <t>
            For nodes that do NOT receive or regard LOVMA VHA datagrams, the 'transition' process becomes more
            akin to a 'hard handoff'. Due to LV requirements, these nodes will not trust the new LV until the previous
            LV has expired, at which time any LV becomes acceptable. For this reason, any VBAs preemptively generated
            with the upcoming LV will not be successfully verified by neighbors unaware of the handoff, until the
            transition window has ended and the new LV becomes primary. All implementations SHOULD therefore parse VHAs
            to secure the handoff process, preventing rogue LVs from partially hijacking the VB role on the link.
          </t>
          <t>
            When a handoff completes, the Link Voucher has changed. Any time the stored VoucherID of the active
            LV transitions to another, the Neighbor Cache MUST be cleared and all VBAs, whether generated or verified,
            MUST be derived from the parameters of the newly active LV ONLY. This is true even in the case of a hard
            handoff.
          </t>
          <t>
            The handoff and transition window provides an opportunity for optimization. If neighbors are aware of the
            upcoming voucher, they MAY opt to preemptively generate their new VBAs in anticipation of the completed LV
            transition. Implementations MAY also choose to utilize this transition window for pre-caching the computed
            addresses of cached neighbors who have a Preferred Iterations Count specified in LOVMA VSR packets.
          </t>
          <t>
            Finally, if the current node responsible for the LV either disconnects from the network or lets its LV
            expire without an election process, then the link becomes open and allows other nodes to fill in the LV
            void with their own. If no other VB assumes responsibility on the link while the primary VB is away or not
            transmitting updated LVs, all VBA-enabled nodes MUST retain the most recent valid LV for the purposes of
            address generation and verification.
          </t>
        </section>
      </section>

      <section anchor="summary-generate">
        <name>Address Generation</name>
        <t>
          This section discusses the generation procedure and composition of VBAs.
        </t>
        <figure>
          <name>The Voucher-Based Address Generation Procedure</name>
          <artwork type="ascii-art" name="vbaGeneration.txt">
            <![CDATA[
Address composition:
          PREFIX    //      SUFFIX (64 bits)
    +------ ~ ------+-------------+---------------------+
    | 64-bit prefix | Z (16 bits) |     H (48 bits)     |
    +------ ~ ------+-------------+---------------------+

  where:
    PREFIX is the 64-bit subnet prefix. If the subnet length is
              shorter than 64 bits, the rest of the 64-bit field
              MUST be initialized to a pseudo-random value.
    SUFFIX is the first 8 bytes from the result of a Key Derivation
              Function (KDF) 'K' iterated 'L' times. The leftmost
              hextet is replaced by 'Z'.

Formulas:
    H  =  K(L, Key, Salt)
          |---> K    = A KDF specified by the Link Voucher.
          |---> L    = A random, host-selected 'iterations count'.
          |---> Key  = The 128-bit Link Voucher seed value.
          `---> Salt = [LLID] || 'v' || 'b' || 'a' || [PREFIX]

    Z  =  ~(L ^ Key[0..1])

    SUFFIX = hextets{ Z, H[2..3], H[4..5], H[6..7] }
                            `--> (using 0-based indexing)
            ]]>
          </artwork>
        </figure>
        <t>
          The Interface Identifier (IID) for all VBAs, called a SUFFIX, embeds two important details for verification:
        </t>
        <ul>
          <li>
            <t>
              A 16-bit 'Z' value, calculated as a bitwise complement of the XOR of the 'L' value and the first hextet
              of the LV seed. This calculation uses this XOR computation to ensure the same iterations count 'L' between
              different LV seeds will be unique and provide some resistance to tracking hosts between each varying LV
              seed. This is especially true if the host locally advertises a well-known or Preferred Iterations Count
              (<xref target="lovma-packets-vsr"/>).
            </t>
            <ul>
              <li>
                The 'L' value, also called 'iterations count' in this document, is an important value. This parameter
                controls how many times the KDF function is iterated to produce the resulting hash. Increasing this
                value increases both the work required to generate the VBA and the work required to find potential
                hash collisions.
              </li>
            </ul>
          </li>
          <li>
            48 bits from the resulting hash, or 'H' value, derived from the KDF after 'L' iterations. Implementations
            are REQUIRED to use the FIRST 8 bytes of the hash in formulating the SUFFIX value, replacing the first
            hextet with the 'Z' value as shown in the figure.
          </li>
        </ul>
        <t>
          The address generation algorithm is detailed procedurally as follows:
        </t>
        <ol>
          <li>A host connects to a VBA network and obtains Link Voucher details (<xref target="addenda-voucher"/>).</li>
          <li>The 'L' value is chosen based on (1) host preference, (2) intended difficulty, or (3) random selection.</li>
          <li>The Link Voucher details contain instructions for which KDF to use and which 128-bit seed value to use.</li>
          <li>
            <t>
              The KDF Salt is a variable-length CONCATENATION of a few different values, in the order specified
              below. 'Raw' values indicate binary values, NOT hexademical string notations of the values.
            </t>
            <ul spacing="compact">
              <li>
                The raw link-layer identifier of the network interface for which addresses are being generated.
                Note that since the Salt value is a variable-length string, this is NOT REQUIRED to be an IEEE 802 MAC
                address, but it MUST represent the link-layer address to which the IPv6 address will be bound.
              </li>
              <li>The string "vba".</li>
              <li>The raw PREFIX (subnet prefix) value. This MUST match the prefix for which the VBA will be generated.</li>
            </ul>
          </li>
          <li>
            <t>
              The final address SUFFIX is computed:
            </t>
            <ul spacing="compact">
              <li>
                The first 16 bits are the bitwise complement of an XOR between the iterations count 'L' and the
                first hextet of the LV seed.
              </li>
              <li>
                The least significant 48 bits are 6 sequential bytes from the KDF hash, skipping the first two
                bytes (hextet) in the sequence.
              </li>
            </ul>
          </li>
        </ol>
        <t>
          See <xref target="appendix-code-generation"/> for sample code in the C programming language which
          might better demonstrate VBA address generation.
        </t>
      </section>

      <section anchor="summary-verify">
        <name>Address Verification</name>
        <t>
          This section provides a procedural overview of VBA address verification. Two important relative terms will
          need to be established for the sake of clarity:
        </t>
        <dl newline="true">
          <dt>Client Node</dt>
          <dd>The node resolving the link-layer address of a neighbor; sends the initial Neighbor Soliciation packet.</dd>
          <dt>Target Node</dt>
          <dd>The node supplying its target link-layer address in a responding Neighbor Advertisement.</dd>
        </dl>
        <t>
          VBA address verification MUST only performed during the Address Resolution phase of an NDP exchange, where
          enabled on the local interface. Verifying an address entails reconstructing the address generation procedure
          run by the Target Node and ensuring the produced address is equivalent to the one solicited by the Client Node.
        </t>
        <t>
          The Target Node address being resolved MAY be any unicast address, but MUST be within the address space of an
          on-link prefix.
        </t>
        <t>
          The following figure shows how VBA verification integrates into the NDP Address Resolution process. Node 'A' is
          the Client Node and node 'B' is the Target Node.
        </t>
        <figure>
          <name>The Voucher-Based Address Verification Procedure</name>
          <artwork type="ascii-art" name="vbaVerification.txt">
            <![CDATA[
 ,-- [advertise] <---.
 V       (2)         |
|A|{LV}             |B|{LV}{MAC}
 |   |               |      |
 +---+-> [solicit] --' <====|=== (solicited-node)
 |   |      (1)             |
 |   |                      |
 |   +---------+-------.    |
 |   |         |       |    |
 |   |  +~~~~~~V~~~~~~~|~~~~+~~~~~~~~~~~+
 `---+->| H := LV.K(   V    | [rebuild  |
 (3) |  |   L := Z'(B, LV), |  addr B]  |
     `--+-> LV.seed,   v----'           |
        |   makeSalt(MAC, prefix(B))    |
        | );                            |
        +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            |
            |      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            `----> | [prefix(B) || suffix(Z(L, LV), H)] == B |
                   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                        (4)  {????}
                              |  |
           DROP <-- false <---'  '---> true --> ACCEPT/CACHE
            ]]>
          </artwork>
        </figure>
        <t>
          The Link Voucher 'LV' MUST always be used from the state preserved on the verifying interface. Nodes
          SHALL NOT request the Link Vouchers of others for any reason. If the verification procedure fails due
          to an LV mismatch between nodes A and B, then there is most likely either (1) a synchronization problem
          or (2) an issue with multiple same-link LVs being distributed.
        </t>
        <t>
          In the above figure, the "Z'" (Z-prime) function returns the iterations count embedded in Host B's address.
          This function is the opposite of 'Z'; it uses an input address to determine 'L' rather than using
          an input 'L' to determine an output hextet. Despite the different inputs, the naming alludes to the
          opposite purposes for each function.
        </t>
        <dl newline="true">
          <dt><tt>Z(L, LV) = ~(L ^ LV.seed[0..1])</tt></dt>
          <dd>Returns a hextet to insert into a generated address. A bitwise complement of the result of an iterations
            count XOR'd with the first hextet of a Link Voucher seed value.</dd>
          <dt><tt>Z'(B, LV) = ~(B[8..9] ^ LV.seed[0..1])</tt></dt>
          <dd>Returns an iterations count derived from a full IPv6 address. In this case, 'B[8..9]' is equal to
            the length and position of the embedded hextet calculated by the function 'Z' above.</dd>
        </dl>
        <t>
          <tt>Z'</tt> is necessarily computed for each VBA verification because the 'L' value is a required component
          to reconstruct the solicited address of the Target Node.
        </t>
        <t>
          See <xref target="appendix-code-verification"/> for sample code in the C programming language which
          might better demonstrate VBA address verification.
        </t>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable VBA functionality.</t>

      <section anchor="addenda-voucher">
        <name>Link Voucher Option</name>
        <t>
          The Link Voucher (LV) option specifies the address generation (and consequent verification)
          parameters which on-link hosts MUST agree upon when generating or verifying local VBAs.
        </t>
        <figure>
          <name>Structure of the NDP Link Voucher option</name>
          <artwork type="ascii-art" name="linkVoucherOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |           Expiration          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                                                               |
  |                      128-bit Voucher Seed                     |
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                       TLV Algorithm Type                      <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  >                          DER-encoded                          <
  >                     PublicKey & Signature                     <
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>63</dd>
          <dt>Length</dt><dd>The total length of the LV from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>Expiration</dt>
          <dd>
            A 16-bit big-endian value storing the amount of time in seconds that the Link Voucher should be considered legitimate
            when an update has not been received. This value MUST be between 3,600 (1 hour) and 43,200 (12 hours).
          </dd>
          <dt>Reserved</dt>
          <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
          <dt>Timestamp</dt>
          <dd>
            A 64-bit value representing the system time of the sender at the moment an LV is constructed.
          </dd>
          <dt>VoucherID</dt>
          <dd>
            A pseudo-random 64-bit value that uniquely identifies a Link Voucher instance. This MUST NOT change between distributions
            of the same unique LV.
          </dd>
          <dt>Seed</dt>
          <dd>
            A 128-bit pseudo-random value used as an input for neighbor VBA generation. This value MUST be the same for each
            distribution of an LV identified by a VoucherID. It MUST NOT be the same value across different VoucherID values.
          </dd>
          <dt>Algorithm Type</dt>
          <dd>
            Specifies exactly which type of key derivation function to use in address generation and its corresponding difficulty.
            See <xref target="addenda-voucher-kdfs"/> for more details.
          </dd>
          <dt>PublicKey (named field; NOT present in option data)</dt>
          <dd>
            This value MUST NOT be directly present in LV options. Extended ECDSA signatures have a public key recovery feature which
            allows the PublicKey value to be implied within the encoded signature value <!-- ref -->.
            Receivers are REQUIRED to extract the PublicKey value each time they validate an LV signature, to ensure it has not changed.
            This implied public key value used to sign LVs MUST NOT change in distributions of the same LV identified by the VoucherID value.
          </dd>
          <dt>ECDSA Signature</dt>
          <dd>
            <t>
              A variable-length field containing a DER-encoded ECDSA signature, derived using the Private Key corresponding to
              the sender's LV public key. The signature is computed over a series of sequential octets, constructed in the following order:
            </t>
            <ol spacing="compact">
              <li>The 16-bit 'Expiration' value.</li>
              <li>The 64-bit 'Timestamp' value.</li>
              <li>The 32-bit 'VoucherID' value.</li>
              <li>The 128-bit 'Seed' value.</li>
              <li>The variable-length contents of the 'Algorithm Type' value, including its Type and Length values.</li>
            </ol>
            <t>
              The algorithm used in signature computation is ecdsa-with-SHA256, as defined in Section 3.2 of <xref target="RFC5758"/>.
              This field MUST be a DER-encoded <xref target="ITU.X690.2002"/> ASN.1 structure of the type ECDSA-Sig-Value
              (Section 2.2.3 of <xref target="RFC3279"/>).
            </t>
          </dd>
          <dt>Padding</dt>
          <dd>
            Any extra padding set on the datagram to round its total length to an even 8-octet boundary. Senders MUST initialize this
            value to 0. Receivers MUST ignore this field.
          </dd>
        </dl>

        <section anchor="addenda-voucher-senders">
          <name>Processing Rules for Senders</name>
          <t>
            On-link nodes responsible for an LV (<xref target="bearers"/>) MUST respond to Router Soliciation packets. This is
            true regardless of whether the VB is using a Redirect or Router Advertisement to distribute its LV.
          </t>
          <t>
            Sending nodes wishing to distribute a Link Voucher MUST first check the local link for an already-active LV. This
            entails following a process of router discovery, then only assuming LV responsibility if no LV is already present.
          </t>
          <ol spacing="compact">
            <li>Send a Router Soliciation to the All Routers multicast group at FF02::2.</li>
            <li>Wait for an LV option for at least 2 seconds before sending another Soliciation.</li>
            <li>
              <t>Repeat this process 2 more times.</t>
              <ul spacing="compact">
                <li>If an LV is received within a Router Advertisement or Redirect response, accept and use the parameters of the received LV.
                  This condition means the sender MUST NOT send their own LV, nor should it propagate any instances of LV options.</li>
                <li>
                  <t>If no LV is received after the 3 total attempts, and...</t>
                  <ul spacing="compact">
                    <li>the Sender IS NOT a router: the Sender's LV may be distributed on the local link as an option attached
                      to an appropriate NDP Redirect packet.</li>
                    <li>the Sender IS a router: the Sender may attach its LV to an appropriate ND Router Advertisement packet.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ol>
          <t>
            Senders of Link Vouchers MUST maintain stateful information about their LVs, so reliable and consistent LVs
            can be sent as demanded. The rotation of stable LV information -- the ID, Seed value, or Algorithm details --
            MUST be signaled in advance using the LOVMA group <xref target="lovma-packets-vha"/> which will initiate a transition
            window to the new address generation parameters.
          </t>
          <t>
            Expiration values MUST be set to an appropriate value. Senders MAY adjust this value without requiring a handoff.
            Timestamp values MUST always be sent to the precise system time as a big-endian 64-bit value.
          </t>
          <t>
            The Sender's LV MUST always be unique on-link and NEVER be forwarded or duplicated copies of other LVs. Additionally,
            the Voucher Seed MUST NOT be preserved between different LV VoucherIDs or handoffs. It MUST always be a random value
            when first assigned to an LV VoucherID.
          </t>
          <t>
            Protecting the link from rogue LVs is crucial to securely maintain the full consensus of the local network.
            See <xref target="bearers-vigilance"/> on RA-Guard and <xref target="security-usurp"/> about LV Hijacking
            for more details. <xref target="security-pki"/> also discusses considerations for incorporating trust anchors and PKI.
          </t>
        </section>

        <section anchor="addenda-voucher-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
            A Link Voucher option appearing with any packet except NDP Router Advertisements or NDP Redirects MUST be ignored.
          </t>
          <t>
            Nodes manually set to Address Awareness Disabled mode on their receiving interface MUST ignore LVs. Similarly, nodes
            with static LV details assigned on their interface(s) MUST ignore LVs.
          </t>
          <t>
            Nodes acting as authorized Voucher Bearers MUST disregard any received LV options on the links for which they are
            already the active, responsible VB.
          </t>
          <t>
            Receiving nodes MUST statefully maintain and update all LV information per interface, if and only if the received LV
            is successfully verified according to its cryptographic signature. The most recent, valid, and unexpired version of
            the LV is what MUST always be cached and preferred on the receiving interface. A received LV that does not contain a
            valid signature MUST be ignored.
          </t>
          <t>
            Nodes receiving a new LV for the first time are "locked" to the LV and its public key. They MUST NOT accept LVs which
            contain any other PublicKey details or signatures which do not use the same PublicKey. This period of "locking" remains
            until the cached LV is expired or VB responsibility is delegated to another LV.
          </t>
          <t>
            Received LVs which contain different address generation parameters (VoucherID, Seed, Algorithm Type option details)
            MUST be ignored and MUST NOT update any cached LV entries. Likewise, any difference in the PublicKey field MUST cause
            the LV to be ignored.
          </t>
          <t>
            LVs with invalid timestamps MUST be ignored. Timestamps MUST be considered invalid if the value falls outside the
            range [CURRENT_TIMESTAMP - LV_Expiration] to [CURRENT_TIMESTAMP + LV_Expiration], where 'CURRENT_TIMESTAMP' is the
            64-bit system time (in seconds) measured by the receiving node. This ensures timestamp validity remains flexible even
            with minor clock drifting across the local network.
          </t>
          <t>
            Segment VBs may occasionally wish to hand off responsibility for the Link Voucher to another VB through gratuitous
            Voucher Handoff Advertisements (see <xref target="lovma-packets-vha"/>). These VHAs serve to enable a "sliding window"
            where two LVs MAY be active on the same link at one time. During this window, both Link Vouchers MUST be considered
            valid and cached accordingly. This same window MAY also be used for updating the Algorithm Type and other current LV
            options.
          </t>
        </section>

        <section anchor="addenda-voucher-kdfs">
          <name>Algorithm Type Options</name>
          <t>
            Section 5 of <xref target="RFC8018"/> specifies the definition of a Key Derivation Function (KDF):
          </t>
          <blockquote>
               A key derivation function produces a derived key from a base key and
               other parameters.  In a password-based key derivation function, the
               base key is a password, and the other parameters are a salt value and
               an iteration count...
          </blockquote>
          <t>
            This section will discuss the default algorithms and KDF types that SHOULD be packaged with basic implementations
            of this specification. Future versions or extensions of this document MAY add new Key Derivation Function algorithms.
          </t>
          <t>
            Any Algorithm Type option not specified in this document or in future versions MUST be ignored by receivers.
          </t>
          <t>
            Any TLV Algorithm Type choice is formatted as a Type-Length-Value object, where Type is a numeric identifier
            uniquely representing a chosen KDF, Length is the width of the total TLV Algorithm Type in units of 4 octets,
            and Value is a compact data format zero-padded to the nearest 32-bit boundary. Receivers MUST always ignore padding
            and senders MUST always initialize padded areas to zero.
          </t>
          <figure>
            <name>Structure of an Algorithm Type Option</name>
            <artwork type="ascii-art" name="algorithmOption.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Type             |             Length            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                             Value                             <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <t>
            The list of default KDF Algorithm Type choices is given below.
          </t>
          <!-- Might it be better to use ASN1 notation here or DER to convey some object details? -->
          <dl newline="true">
            <dt>PBKDF2_SHA256</dt>
            <dd>
              <t>
                The Password-Based Key Derivation Function (PBKDF2) is defined in Section 5.2 of <xref target="RFC8018"/>.
                It is a CPU-bound cryptographic function which might incur significant computation speed disparities
                between embedded systems and high-performance hardware. It is included primary for portability,
                universality, and ease of implementation.
              </t>
              <t>
                This specification explicitly uses PBKDF2 with SHA-256 as its PRF: implementations using this Type MUST
                use SHA-256 as the PBKDF2 Pseudo-Random Function.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>1</dd>
                <dt>Length</dt><dd>2</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>ITERATIONS_FACTOR</dt>
                    <dd>
                      A 16-bit integer representing the multiplier of an input KDF iterations count, specified in big-endian
                      format. This value MUST be greater than 0; receivers of 0 values MUST use 1 instead. This factor can be
                      used by a Link Voucher to automatically scale the 'difficulty' of the PBKDF2 KDF on the network.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
            <dt>Argon2d</dt>
            <dd>
              <t>
                The Argon2 algorithm is specified in Section 3 of <xref target="RFC9106"/>. It is a Memory-bound cryptographic
                function which will ideally provide less disparate address computation speeds than CPU-bound algorithms like
                PBKDF2. Implementations SHOULD always prefer to use this Type over others, provided all participating network
                devices have Argon2 support.
              </t>
              <t>
                This specification explicitly opts to use Argon2d instead of Argon2i or Argon2id because the generation of
                VBAs does not require any resistance to side-channel attacks. The in-memory data used by the KDF SHOULD NOT be
                treated as secret for any reason. All Implementations with this Type MUST specifically use Argon2d.
              </t>
              <t>
                The iterations count 'L' value is used as the 't' input for Argon2d computations. The Argon2 't' parameter
                indicates the number of passes and is used to increase the algorithm's running time regardless of MemorySize.
              </t>
              <t>
                The Argon2 parameters for Secret Value 'K' and Associated Data 'X' MUST NOT be used or distributed by the LV.
                The Tag Length 'T' for Argon2d MUST be set to 32 and MUST NOT be changed.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>10</dd>
                <dt>Length</dt><dd>3</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>Parallelism</dt>
                    <dd>
                      A 24-bit integer determining how many degrees of parallelism (lanes) are allowed to run during KDF
                      computation. This value SHALL NOT be set to 0. Receivers MUST consider Parallelism values of 0 to
                      automatically indicate a Parallelism of 1.
                    </dd>
                    <dt>Padding</dt>
                    <dd>
                      8 bits (one octet) of padding initialized to zero. Senders MUST set this to 0. Receivers MUST ignore
                      this padding.
                    </dd>
                    <dt>MemorySize</dt>
                    <dd>
                      A 32-bit integer representing the number of kibibytes used in the KDF computation. This value SHOULD be
                      carefully controlled and take into consideration the computing resources across the link on which the LV
                      will be distributed. This value MUST be a minimum of 8*Parallelism and MUST NOT be set to 0. Receivers MUST
                      adjust the minimum MemorySize accordingly if the value does not meet the minimum threshold for the ACTUAL
                      degree of parallelism being used.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
            <dt>Scrypt</dt>
            <dd>
              <t>
                The Scrypt KDF algorithm is specified in Section 6 of <xref target="RFC7914"/>. It is a Memory-bound cryptographic
                function which, similar to Argon2, ideally providing less disparate address computation durations than CPU-bound
                key derivation techniques.
              </t>
              <t>
                The iterations count 'L' value is used in part for both the 'N' and 'r' inputs for Scrypt computations. The Scrypt
                'N' parameter indicates the CPU/Memory cost of running the computation. This value MUST ultimately be a power of 2.
                The 'r' Scrypt parameter indicates the desired block size. Actual values are computed by the following conversion:
              </t>
              <t>
                r (Parallelism) := MAX{ 16, (L &amp; 0xFF00) &gt;&gt; 4 }<br />
                N (Cost) := MAX{ 2, 1 &lt;&lt; (L &amp; 0x00FF) }
              </t>
              <t>
                The Scrypt parameter 'dkLen' (derived key length) MUST always be set to 32 and MUST NOT differ between
                implementations. The Parallelization parameter 'p' MUST always be set to 1 and MUST NOT differ between
                implementations.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>20</dd>
                <dt>Length</dt><dd>1</dd>
                <dt>Value</dt>
                <dd>There are no extra parameters to control for the Scrypt Algorithm Type option.</dd>
              </dl>
            </dd>
          </dl>
        </section>
      </section>

      <section anchor="addenda-summary">
        <name>Voucher Summary Option</name>
        <t>
          The Voucher Summary (VS) option SHOULD be included with Neighbor Solicitation and Advertisement packets to
          hint to recipients which active Link Voucher ID is being statefully used on the target or source interface.
        </t>
        <figure>
          <name>Structure of the NDP Voucher Summary option</name>
          <artwork type="ascii-art" name="voucherSummaryOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>64</dd>
          <dt>Length</dt><dd>Set to 1. The total length of the VS from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>IEM</dt>
          <dd>
            <t>
              A 3-bit identifier representing the current Interface Enforcement Mode of the sending interface (see
              <xref target="summary-interfaces-mode"/>).
            </t>
            <table anchor="iem-mappings">
              <name>IEM Identifier Mappings</name>
              <thead>
                <tr><th>Value</th><th>IEM</th></tr>
              </thead>
              <tbody>
                <tr><td>0</td><td>AAD</td></tr>
                <tr><td>1</td><td>AGO</td></tr>
                <tr><td>2</td><td>AGV</td></tr>
                <tr><td>3</td><td>AGVL</td></tr>
                <tr><td>4</td><td>Reserved</td></tr>
                <tr><td>5</td><td>Reserved</td></tr>
                <tr><td>6</td><td>Reserved</td></tr>
                <tr><td>7</td><td>Reserved</td></tr>
              </tbody>
            </table>
          </dd>
          <dt>Reserved</dt><dd>A 13-bit field reserved for future use. This MUST be initialized to zero by the sender and MUST
            be ignored by the receiver.</dd>
          <dt>VoucherID</dt><dd>The 32-bit ID of a valid Link Voucher retained on the sending interface.</dd>
        </dl>

        <section anchor="addenda-summary-senders">
          <name>Processing Rules for Senders</name>
          <t>
            Senders SHOULD always include this option with all NDP Neighbor Solicitations or Advertisements. When a valid
            LV is NOT currently available on the sending interface, senders MUST set the IEM to AAD mode and initialize
            the VoucherID to 0.
          </t>
          <t>
            The IEM value MUST be accurately set to the current IEM of the sending interface. The 32-bit VoucherID field MUST
            be equal to the cached Link Voucher ID for the sending interface.
          </t>
        </section>

        <section anchor="addenda-summary-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
            The VS option is NOT REQUIRED and SHALL NOT become required at any future time. Any NDP packets not including it MUST
            be treated as they normally would by the receiver's IEM and other processes. The same is true for VS options which are
            'ignored' due to incorrect formatting or some other validation decision.
          </t>
          <t>
            If the receiver's IEM is AAD, the VS option MUST be ignored.
          </t>
          <t>
            Processing of valid VS options is affected by which NDP packet types they are attached to:
          </t>
          <dl newline="true">
            <dt>Neighbor Solicitations</dt>
            <dd>
              <t>
                The receiving interface MUST disregard the NS if there is a non-zero VoucherID present and it does not match the
                ID of the active Link Voucher of the receiving interface. To 'disregard' means to not respond to the NS at all.
              </t>
              <t>
                If the receiver is aware of a current Voucher Handoff on the link, then either the current voucher ID or the
                upcoming voucher ID MUST be considered valid.
              </t>
            </dd>
            <dt>Neighbor Advertisements</dt>
            <dd>
              <t>
                Processing affects VBA verification procedures on the receiving interface based on the receiver's IEM.
              </t>
              <t>
                Receivers MUST first inspect the IEM field to acquire the mode of the sending interface. If the IEM indicates an
                AAD mode at the sender, the receiver MUST behave according to their own IEM:
              </t>
              <dl newline="false" spacing="normal">
                <dt>AAD</dt><dd>Ignore the VS option entirely.</dd>
                <dt>AGO</dt><dd>Ignore the VS option since VBA verification is not being performed anyway.</dd>
                <dt>AGV</dt><dd>Drop the packet. Do not cache the neighbor's details. Completely deny them.</dd>
                <dt>AGVL</dt><dd>Regard the neighbor as Unsecured and skip the VBA verification process.</dd>
              </dl>
              <t>
                If the VoucherID field is initialized to zero, the VS option MUST be ignored. If the VoucherID value does not match
                the ID of the active Link Voucher on the receiving interface, the VS option MUST be ignored. Otherwise, processing
                proceeds to VBA verification per the receiver's IEM.
              </t>
              <t>
                If the receiver is aware of a current Voucher Handoff on the link, then either the current voucher ID or the
                upcoming voucher ID MUST be considered valid.
              </t>
            </dd>
            <dt>Any other NDP packet types</dt>
            <dd>The receiver MUST ignore the VS option.</dd>
          </dl>
        </section>
      </section>
    </section>

    <section anchor="behavioral">
      <name>Behavioral Neighbor Discovery Changes</name>
      <t>
        This section describes the requirements and implications of VBAs with regard to ordinary NDP. Simple
        amendments to NDP are necessary to secure the Address Resolution process.
      </t>

      <section anchor="behavioral-cache">
        <name>Protecting the Neighbor Cache</name>
        <t>
          The primary verification goal of VBAs results in a symmetric computation that can be costly for
          low-power nodes or other embedded systems. By requiring address verification ONLY when interacting
          with the local Neighbor Cache, nodes do not need to perform the entire verification procedure as
          frequently.
        </t>
        <t>
          This section discusses some behavioral NDP changes regarding the host's Neighbor Cache. The changes
          are aimed at a balanced mixture of optimization and security.
        </t>

        <section anchor="behavioral-cache-rxns">
          <name>Receiving Neighbor Solicitations</name>
          <!-- DO NOT EAGERLY CACHE WITHOUT VERIFYING. -->
          <t>
          </t>
        </section>

        <section anchor="behavioral-cache-unsolicitedna">
          <name>Unsolicited Neighbor Advertisements</name>
          <!-- Section 7.2.5 of RFC4861. -->
          <t>
          </t>
        </section>

        <section anchor="behavioral-nud">
          <name>Neighbor Unreachability Detection</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-cache-unsolicited">
          <name>Receiving Unsolicited Traffic</name>
          <t>
            Any node receiving unsolicited traffic from a neighbor, for which no response is required from
            the receiver -- such as UDP-based applications -- does not need to interact with the VBA system
            at all. The receiving node MAY choose to validate the sender according to this specification.
            This would necessitate the neighbor verification process be conducted in reverse.
          </t>
          <t>
            If the sending neighbor is already in the receiver's neighbor cache, then the receiver SHOULD
            NOT verify the address of the sender. The cache MAY be refreshed if the link-layer IP address
            bindings have not changed for the sender's cache entry.
          </t>
          <t>
            VBA employment primarily supplies privacy-focused address generation and uses neighbor address
            verification to provide proof of address ownership. The goal is to prevent on-path attackers
            from illegally, ACTIVELY intercepting local network traffic. Therefore, receiving packets for
            which no response is necessary does not merit an explicit requirement that the sending neighbor
            be verified.
          </t>
        </section>
      </section>

      <section anchor="behavioral-send-levels">
        <!-- See Section 8 of RFC 3971. -->
        <name>Secured &amp; Unsecured Distinctions</name>
        <t>
          Section x of the SEND RFC <xref target="RFC3971"/> defines a
        </t>
      </section>

      <section anchor="security-dos-grand">
        <name>Gratuitous Neighbor Discovery</name>
        <t>
          Gratuitious ND <xref target="RFC9131"/> allows routers to create STALE Neighbor Cache entries from received
          Neighbor Advertisements, as an optimization to expedite the exchange of link-layer address bindings. VBAs
          SHOULD support this option, as routers preemptively verifying a host's address bindings will allow the host to
          communicate off-link much faster than if the router required a reverse Address Resolution process for the host.
        </t>
        <t>
          Implementations SHOULD be flexible with Gratuitious ND as it applies to IEMs requiring address verification. If
          a flurry of NA packets is received in an ostensible attack, the router might quickly find itself with too much
          work and could start dropping packets. Therefore, implementations MAY want to toggle this feature reactively and
          dynamically.
        </t>
      </section>

      <section anchor="behavioral-dad">
        <name>Duplicate Address Detection</name>
        <t>
          When generating a VBA, the node MUST follow the ordinary means of Duplicate Address Detection (DAD)
          specified by the SLAAC RFC (section 5.4 of <xref target="RFC4862"/>). The DAD procedure SHOULD follow
          any other applicable DAD optimizations (<xref target="RFC4429"/>, <xref target="RFC7527"/>, etc.).
        </t>
        <t>
          Upon detecting a duplicate address, VBA-enabled nodes MUST by necessity to select another iterations
          count 'L' value to generate a non-conflicting address. This can become computationally expensive
          to recompute each new value based on the amount of address collisions, or in the case of denial of
          service attacks.
        </t>
        <t>
          To counter this weakness, implementations MUST employ one of two options based on the selected 'L' value:
        </t>
        <dl newline="true">
          <dt>L &gt;= 4</dt>
          <dd>Cache the 4 leading KDF computations (L-4 through L-1) during the DAD procedure.</dd>
          <dt>L &lt;  4</dt>
          <dd>Cache the result of the 'L' value only.</dd>
        </dl>
        <t>
          Implementations SHOULD always prefer the option where the 'L' value is &gt;= 4, because
          L-4 through L-1 are intermediate KDF results already required in order to produce the result at the final
          iterations count. Conversely, any 'L' value under 4 will simply cache 'L' then increment the KDF iterations
          by one for each DAD collision, up to 4 times.
        </t>
        <t>A figure representing this process visually is shown below:</t>
        <figure>
          <name>Using DAD with VBAs</name>
          <artwork type="ascii-art" name="duplicateAddressDetection.txt">
            <![CDATA[
COMPUTE & CACHE:
  N = Set of K(L', Key, Salt),
    where L' :=
      if L >= 4 :  { L-4, L-3, L-2, L-1, L },
      else      :  { L }

           (1)      +~~~~~~~~~~~~~~+
 |A|{B}------------>| Normal SLAAC | (B :  Duplicate!)
  |     v-----------|  DAD Process | (B':  Success!)
  |  [FAIL]  (2)    +~~~~~~~~~~~~~~+
  |                      ^
  |                      |
  `---> [cached (L-1)    | (3)
         generates B'] --'
            ]]>
          </artwork>
        </figure>
        <t>
          In the figure, (1) shows host 'A' engaged in DAD using the address 'B' generated with the iterations count 'L'.
          After the collision is detected in (2), step (3) shows the new address "B'" being immediately tried using the
          already-cached value 'L-1' as the input iterations count. The DAD process is then successful and there are no
          on-link duplicate addresses.
        </t>
        <t>
          To further cement this important optimization procedure, a written example process follows.
        </t>
        <ol>
          <li>A new network host has received Link Voucher details; the voucher specifies using PBKDF2.</li>
          <li>The host arbitrarily selects 0xFF04 as its input link-local iterations count.</li>
          <li>The host will iterate the PBKDF2 function through 0xFEFF.</li>
          <li>When retrieving the PBKDF2 cipher output for 0xFF00 (L - 4) iterations, it will cache this value.</li>
          <li>It will do the same for the next 3 iterations counts (0xFF01, 0xFF02, &amp; 0xFF03).</li>
          <li>It will compute the final PBKDF2 round at 0xFF04 iterations, and will use the result to generate
            a valid VBA <xref target="summary-generate"/>.</li>
          <li>When following the DAD procedure, a collision is detected.</li>
          <li>The host then falls immediately back to the L - 1 iterations count of 0xFF03 to generate the VBA.</li>
          <li>This new host address is completely different and does not register a DAD collision.</li>
          <li>The optimization has successfully removed the need to recompute the PBKDF2 algorithm up to some new
            iterations count, saving a significant amount of time in the VBA-enabled SLAAC process. Reducing the
            chosen 'L' value by 1 results in a completely different pseudo-random address.</li>
        </ol>
        <t>
          If all 5 attempted iterations counts result in DAD collisions, then the node MUST give up and use some other
          implementation-specific course of action to contact an administrator or log a system management error.
        </t>
        <t>
          Note that truly benign DAD collisions are a dangerous prospect for Voucher-Based Addressing. Address
          collisions imply that a separate link-layer identifier with the SAME iterations count has somehow
          generated a hash suffix collision, exposing the possibility for node impersonation in a rare occurrence.
          Some implementations MAY wish to find trusted ways to detect such an occurrence, possibly by means
          of intermediate device monitoring (such as switching hardware), and take action based on it.
        </t>
        <t>
          Nodes encountering a duplicate address will by necessity require a different iterations count to
          generate their current address. If the node uses a 'sticky' iterations count, then it is RECOMMENDED
          that it send a gratuitous VSR update to the LOVMA with the new count (<xref target="lovma-packets-vsr"/>).
        </t>
        <t>
          Protections to mitigate denial of service attacks based on DAD are beyond the scope of this document.
          Since VBAs do not modify the actual DAD process, further research into DAD denial of service protections
          will apply likewise when using VBAs.
        </t>
      </section>
    </section>

    <section anchor="lovma">
      <name>Local On-link Voucher Multicast Address</name>
      <t>
        The LOVMA group is defined for the express purpose of sharing gratuitous, independent VBA details between nodes.
        All nodes with VBA awareness, regardless of Interface Enforcement Mode (<xref target="summary-interfaces-mode"/>)
        are strongly RECOMMENDED to join this group. Nodes are NOT REQUIRED to make practical use of any LOVMA traffic.
        Current link Voucher Bearers are always REQUIRED to join the LOVMA group.
      </t>
      <t>
        This multicast group is located at the IPv6 address FF02::ABBA. A helpful mnemonic to remember this address is to
        think of "ABBA" as the closest possible hexademical rendition of "a VBA".
      </t>
      <t>
        The designated UDP port on which all LOVMA traffic is received is 2196.
      </t>
      <t>
        Senders of LOVMA traffic are REQUIRED to send packets from a link-local addresses bound to the interface being used
        to communicate on the LOVMA channel.
      </t>

      <section anchor="lovma-constraints">
        <name>Constraints</name>
        <t>
          When utilizing the LOVMA for any purpose, experimental or deployed, implementations MUST regard these constraints:
        </t>
        <ul>
          <li>LOVMA traffic is considered unidirectional. Nodes SHOULD NOT send unicast responses in reply to multicast traffic.
            This recommended constraint acts to prevent asymmetric traffic volumes and potential denial of service vulnerabilites
            leveraging the LOVMA.</li>
          <li>All LOVMA datagrams MUST be User Datagram Protocol (UDP) <xref target="RFC768"/> packets.</li>
          <li>VBA-enabled nodes MUST NOT assume that any other VBA-enabled nodes are subscribed to the LOVMA multicast group or
            receiving any of its related datagrams. However, nodes MUST assume the presence of the current link VB in the LOVMA.</li>
          <li>Subscribing nodes MUST NOT offer any trust of LOVMA packets, unless a datagram validation procedure is explicitly
            declared in the Defined Datagram using the LOVMA.</li>
        </ul>
      </section>

      <section anchor="lovma-packets">
        <name>Defined Datagrams</name>
        <t>
          This section outlines and formalizes some initial datagrams which should be expected to appear on LOVMA at any time.
        </t>
        <t>
          All packets MUST use a Type-Length-Value (TLV) format. Type is an 8-bit integer identifying the datagram type, Length
          is the length of the packet (including the Type and Length fields) in units of 4 octets, and Value is the following
          object to be parsed.
        </t>
        <t>
          The Type or Length fields MUST NOT be set to 0. Receivers MUST ignore datagrams with a Type of 0 or a Length of 0.
        </t>

        <section anchor="lovma-packets-vsr">
          <name>Voucher Status Reports (VSRs)</name>
          <t>
            A node might opt to occasionally send VSRs to the LOVMA channel to gratuitously let other nodes know of its presence
            as a VBA-enabled interface in addition to a few VBA state-related fields.
          </t>
          <t>
            Sending interfaces are REQUIRED to add their link-layer identifier onto VSR packets. This allows receivers to easily
            identify the sending interface by ID, rather than associating the sender to one of its potentially many IP addresses
            on-link.
          </t>
          <t>
            Senders MUST adhere to the rules defined in the below figure. Receivers are NOT REQUIRED to parse any of the fields.
          </t>
          <figure>
            <name>Structure of a VSR Datagram</name>
            <artwork type="ascii-art" name="lovmaVsr.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Pref. Iterations Count    |          LLID Length          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                              LLID                             <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>1</dd>
            <dt>Length</dt><dd>Variable. The length of the datagram in its totality rounded up to the nearest 4 octets.</dd>
            <dt>IEM</dt>
            <dd>
              A 3-bit value identifying the IEM of the sending interface. See <xref target="iem-mappings"/> for the possible IEM
              values. This value MUST be set to AAD mode if the sending interface does not have a currently cached, active Link Voucher.
            </dd>
            <dt>Reserved</dt>
            <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
            <dt>VoucherID</dt>
            <dd>
              The ID of the cached, active Link Voucher on the sending interface. Senders MUST initialize this to 0 if no LV is present
              or if they are operating in the AAD IEM.
            </dd>
            <dt>Preferred Iterations Count</dt>
            <dd>
              Also known as the 'sticky' iterations count. Senders MAY use this field to indicate a preferred 'L' value when generating
              on-link addresses for each prefix. Receivers MAY associate this field with the Link Layer ID (LLID) field which the generated
              address is bound to, to preemptively calculate VBAs for a neighbor. See <xref target="optimizations"/> for more details.
            </dd>
            <dt>LLID Length</dt><dd>The length in bytes of the LLID field. Stored as a big-endian value.</dd>
            <dt>LLID</dt><dd>A variable-length field representing the node's on-link Link Layer identifier.</dd>
            <dt>Padding</dt>
            <dd>
              Any extra padding set on the datagram to round its total length to an even 4-octet boundary. Senders MUST initialize this
              value to 0. Receivers MUST ignore this field.
            </dd>
          </dl>
        </section>

        <section anchor="lovma-packets-vci">
          <name>Voucher Capability Indications (VCIs)</name>
          <t>
            A node may notify the LOVMA channel about its potential candidacy as a link Voucher Bearer (<xref target="bearers"/>)
            by sending a VCI datagram. The VCI is an informational packet REQUIRED to be considered for election by the current VB.
          </t>
          <t>
            Receivers are typically intended to be the current VB, but any node MAY make use of VCI details. Nodes MUST NOT consider
            VCI packets as valid Link Vouchers. The current VB MAY maintain a state of unexpired VCI packets, especially when
            it intends to elect a new node responsible for the LV. Current VBs SHOULD NOT elect a new VB without first receiving a
            VCI datagram indicating the sender's readiness to be elected.
          </t>
          <t>
            Sending nodes MUST NOT assume that issuance of a VCI packet is guaranteed to lead to their eventual election as a link VB.
            The decision for election MUST be indicated by receipt of a signed VHA datagram.
          </t>
          <figure>
            <name>Structure of a VCI Datagram</name>
            <artwork type="ascii-art" name="lovmaVci.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                      Link Voucher Contents                    <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>2</dd>
            <dt>Length</dt><dd>Variable. The length of the datagram in its totality rounded up to the nearest 4 octets.</dd>
            <dt>Reserved</dt>
            <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
            <dt>Link Voucher Contents</dt>
            <dd>
              The entirety of the NDP Link Voucher option to be attached to Router Advertisements or Redirects. This also MUST include
              the NDP Option Type and Length values. Validation of this field follows the same rules outlined by <xref target="addenda-voucher"/>.
              Receivers MUST NOT expect the signature or public key of the LV option to be the same as that of the current LV, because
              this packet type is only announcing a node's candidacy for future election and it is NOT attempting to delcare a network LV.
              Receivers MUST ignore the entire VCI if validation of the embedded Link Voucher fails for any reason, including invalid
              cryptographic signatures, null IDs, etc.
            </dd>
          </dl>
        </section>

        <section anchor="lovma-packets-vha">
          <name>Voucher Handoff Advertisements (VHAs)</name>
          <t>
            The node responsible for the Link Voucher MAY at any time elect a new link Voucher Bearer (<xref target="bearers"/>)
            using the VHA datagram. This 'handoff' communication notifies VBA-enabled hosts of a change in VB and thus public-key
            information used to sign the new LV. If the public-key signature on the VHA is valid and nodes are 
          </t>
          <t>
            The transition window duration is based on the 'Expiration' value of the current VB's LV packet. Exceedingly long
            Expirations will entail exceedingly long transition windows, and there is no limit to the duration of a transition.
            VHA frequency is variable but is RECOMMENDED to follow the same frequency as the node's previous RA or Redirect issuances.
            Nodes initiating a handoff MUST send at least one VHA notification every 5 seconds for a minimum of 3 minutes OR the
            length of the 'Expiration' value, whichever is shorter. If the 'Expiration' value is high, nodes handing off VB
            responsibility MAY choose to stop transmitting VHAs after this minimum threshold.
          </t>
          <t>
            Candidate nodes considered for VB election MUST be gathered from either (1) manually configured details or (2) senders
            of recent, unexpired VCI notifications.
          </t>
          <t>
            When the elected node observes the VHA packet granting it VB responsibility, it MUST begin sending gratuitous Router
            Advertisements or Redirects to the local network for which it is now a VB. Sending a RA to the local network always
            follows the receipt of a valid, unexpired VHA from the previous VB. After 2 minutes, the new VB MUST consider the LV
            parameters (including the public key) of the previous VB as invalid, and no longer trigger RAs based on receipt of VHAs.
          </t>
          <t>
            VHAs MUST also be used to indicate a change in active Link Voucher details using the 'Refresh' bit. This indicates that
            the handoff represents a transition between LV parameters from the same VB rather than a change of issuing VB nodes.
            Using the VHA for this purpose affords neighbors enough time to fully transition addresses between varying LV parameters.
          </t>
          <t>
            See <xref target="summary-interfaces-transitions"/> for more details regarding the handoff process at the per-interface
            scope.
          </t>
          <figure>
            <name>Structure of a VHA Datagram</name>
            <artwork type="ascii-art" name="lovmaVha.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    |R|          Reserved           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    32-bit Signer VoucherID                    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                   32-bit Upcoming VoucherID                   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                                                               <
  >                     DER-encoded Signature                     <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>3</dd>
            <dt>Length</dt><dd>Variable. The length of the datagram in its totality rounded up to the nearest 4 octets.</dd>
            <dt>Refresh Bit</dt>
            <dd>
              A single bit. When set to '1', it indicates that the transition is only a Link Voucher refresh and does not represent a
              LV handoff to a new or different Voucher Bearer node. This field is mostly used for informational purposes and for any
              further implementation-specific optimizations.
            </dd>
            <dt>Reserved</dt>
            <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
            <dt>Timestamp</dt>
            <dd>
              <t>The current precise system time encoded as a 64-bit value.</t>
              <t>
                Timestamps MUST be considered invalid if the value falls outside the range [CURRENT_TIMESTAMP - 120] to
                [CURRENT_TIMESTAMP + 120], where 'CURRENT_TIMESTAMP' is the 64-bit system time (in seconds) measured by the receiving node.
                This ensures timestamp validity remains flexible even with minor clock drifting across the local network.
              </t>
            </dd>
            <dt>Signer VoucherID</dt>
            <dd>
              The VoucherID of the active LV which is signing the handoff to the Upcoming VoucherID. Nodes using this ID for their active
              LV SHOULD disregard any further advertised LVs with this ID upon receiving this packet. A receiver MUST ignore this packet
              if the Signer VoucherID does not represent the active LV held in the cache of its receiving interface.
            </dd>
            <dt>Upcoming VoucherID</dt>
            <dd>
              The VoucherID of the upcoming LV which will be assuming 'active' status on the network after the transition window completes.
            </dd>
            <dt>ECDSA Signature</dt>
            <dd>
              <t>
                A variable-length field containing a DER-encoded ECDSA signature, derived using the Private Key corresponding to
                the sender's Signer VoucherID. The signature is computed over a series of sequential octets, constructed in the following order:
              </t>
              <ol spacing="compact">
                <li>The 64-bit 'Timestamp' value.</li>
                <li>The 32-bit 'Signer VoucherID' value.</li>
                <li>The 32-bit 'Upcoming VoucherID' value.</li>
              </ol>
              <t>
                The algorithm used in signature computation is ecdsa-with-SHA256, as defined in Section 3.2 of <xref target="RFC5758"/>.
                This field MUST be a DER-encoded <xref target="ITU.X690.2002"/> ASN.1 structure of the type ECDSA-Sig-Value
                (Section 2.2.3 of <xref target="RFC3279"/>).
              </t>
            </dd>
            <dt>Padding</dt>
            <dd>
              Any padding necessary to round the packet size up to the nearest 32-bit boundary. This value MUST be initialized to 0 by
              senders and MUST be ignored by receivers.
            </dd>
          </dl>
        </section>
      </section>
    </section>

    <section anchor="bearers">
      <name>Voucher Bearers</name>
      <t>
        A Voucher Bearer (VB) is the on-link node responsible for the current, majority-accepted Link Voucher. This
        section introduces any VB constraints, recommendations, or other procedures for VBA implementations and deployments.
      </t>

      <section anchor="bearers-appointment">
        <name>Appointments</name>
        <t>
          Any node MAY be elected to serve as the link's VB, whether by manual configuration or by a process of election
          and appointment from the current VB (see <xref target="lovma-packets-vci"/>). Current network VBs wishing to
          transfer LV ownership to another responsible candidate VB MUST use the LOVMA channel and issue handoffs per the
          election process (see <xref target="lovma-packets-vha"/>). Nodes MUST NOT be forced into VB responsibilities
          without first offering their capability through their own LV option attachments or through valid LOVMA VCI packets.
        </t>
        <t>
          If the current VB is NOT a router or responsible for routing subnet traffic, then it MUST distribute the LV via
          an NDP Redirect packet with an LV option, instead of using an NDP RA packet with the LV option. The Redirect is
          expected to behave similarly to the defined NDP process (Section 8 of <xref target="RFC4861"/>).
        </t>
        <t>
          VBs MAY at any time let their own LVs expire if they do not wish to elect another VB, or if there are no other
          candidates available on the LOVMA channel. VBs SHOULD NOT let their own LVs expire without first appointing a
          responsible successor node. If there is no successor, the most recent LV MUST remain current in the network until
          another node assumes VB responsibility.
        </t>
      </section>

      <section anchor="bearers-vigilance">
        <name>Employing RA-Guard</name>
        <t>
          Fake or malicious Link Vouchers can cause issues for nodes who do not yet have the state of an LV stored in
          their local interface(s) on-link. Illegitimate VBs represent a threat more thoroughly explored in
          <xref target="security-usurp"/>. Undesired or "bogus" RAs/Redirects are a known problem in local IPv6 networks
          with no active protections, causing potential failure of on-link nodes. An excerpt from the RA-Guard RFC is noted:
        </t>
        <blockquote>
          <xref target="RFC6105"/> describes a solution framework for
          the rogue-RA problem <xref target="RFC6104"/> where network segments are designed
          around a single L2-switching device or a set of L2-switching devices
          capable of identifying invalid RAs and blocking them.  The solutions
          developed within this framework can span the spectrum from basic
          (where the port of the L2 device is statically instructed to forward
          or not to forward RAs received from the connected device) to advanced
          (where a criterion is used by the L2 device to dynamically validate
          or invalidate a received RA, this criterion can even be based on SEND
          mechanisms).
        </blockquote>
        <t>
          The RA-Guard system SHOULD be augmented and deployed with VBA-aware functions, capable of tracking the state
          of Link Vouchers and LOVMA channel elections. This will allow an intermediate network device, such as
          a switch, to only require RA-Guard Learning mode for a short initial period and then to subsequently "follow"
          the correct LV around, similar to what other network nodes do.
        </t>
        <t>
          The difference with RA-Guard in this scenario is to of course enable and disable RA/Redirect packet forwarding
          when and where appropriate based on what the system understands about the state of vouchers on the network. One
          notable exception to this, however, is that a RA-Guard implementation MAY drop its protections if and only if
          the most recent and legitimate LV has expired without a successor VB. This is because some responsible VB needs
          to be able to supersede a "dead" or expired LV.
        </t>
        <t>
          In the case where the elected VB is NOT a link router nor responsible for routing traffic, and NDP Redirect
          packets are being used with the LV option, a Redirect-aware flavor of RA-Guard is strongly RECOMMENDED to also
          include these in its learning processes.
        </t>
        <t>
          The exact deployment of RA-Guard is beyond the scope of this document, but it is strongly RECOMMENDED in
          order to ensure VBAs faithfully serve their purpose during the ND Address Resolution process. Appointments
          or elections of new VBs should be considered with caution, because the lack of PKI introduces a problem with
          bogus claims of INITIAL identity.
        </t>
      </section>
    </section>

    <section anchor="optimizations">
      <name>Specification Optimizations</name>
      <t>
        This section briefly lists and references the various optimizations built into this specification.
      </t>

      <section anchor="optimizations-summary">
        <name>Summary</name>
        <dl newline="true">
          <dt><tt>Avoiding Repeat Verifications</tt></dt>
          <dd>
            Neighbor Discovery NUD features are used to avoid continuous verification of active neighbors between Link Voucher
            instances. Neighbors do not need to be re-verified when there has been no change to their already-verified bindings
            in a previous Address Resolution exchange. <xref target="behavioral-nud"/> provides more details about this crucial
            performance optimization.
          </dd>

          <dt><tt>Duplicate Address Detection</tt></dt>
          <dd>
            The SLAAC DAD process <xref target="RFC4862"/> is optimized to reduce the burden of regenerating another VBA
            from scratch. See <xref target="behavioral-dad"/> for how this optimization reduces the costs of DAD collisions.
          </dd>

          <dt><tt>The LOVMA Channel &amp; Preemption</tt></dt>
          <dd>
            The LOVMA group affords various optimizations to the network. It enables the use of gratuitous handoffs for
            VBA-enabled nodes to detect upcoming voucher changes (<xref target="lovma-packets-vha"/>). It allows hosts to
            note their preferred iterations counts for upcoming address generations, new prefixes, and LV VB transitions
            (<xref target="lovma-packets-vsr"/>). Lastly, it allows candidate nodes to become capable for VB election when
            the current VB no longer wishes to maintain responsibility for the Link Voucher (<xref target="lovma-packets-vci"/>).
          </dd>

          <dt><tt>Key Derviation Function Selections</tt></dt>
          <dd>
            The options presented in <xref target="addenda-voucher-kdfs"/> permits VBs the flexibility to choose a baseline
            "difficulty" setting for address generation and verification in their distributed LVs. From this baseline, which
            implementations MAY establish through either default settings or some other network benchmarking, network nodes
            are permitted to scale the difficulties of each address they generate based on their chosen iterations counts.
          </dd>

          <dt><tt>Voucher Summary Options</tt></dt>
          <dd>
            VS options (<xref target="addenda-summary"/>) allow hosts to exchange identifying information about the LVs used
            to construct or verify the target address related to the current NDP Address Resolution exchange. This saves
            computation time if the two hosts disagree on the ID of the active (and possibly upcoming) Link Voucher. Behavior
            with this option is of course based on the IEMs of the two communicating interfaces during this exchange.
          </dd>
        </dl>
      </section>

      <section anchor="optimizations-preemption">
        <name>A Note About Packet Loss &amp; Speed</name>
        <t>
          This document proposes various optimizations to ensure the performance of VBAs is commensurate with the simplicity
          of its integration into pre-established LANs. However, the cost of address verification can be notable depending on
          the selected Algorithm Type options of a Link Voucher, in addition to the relative computing power of the verifying
          node. Such a process might easily create a situation where addresses simply cannot be verified fast enough.
        </t>
        <t>
          As such, it is important to highlight that optimizations become inversely proportional to security. In other words,
          preemptive caching of neighbor information -- from, e.g., Gratuitious Neighbor Discovery <xref target="RFC9131"/> --
          results in fewer lost packets when enabled. But it also grants the ability for malicious attackers to spoof thousands
          of gratuitous advertisements per second, inundating routers with a backlog of address bindings to verify (assuming
          some IEM on the receiving interface mandates verification).
        </t>
        <t>
          It is left to both (1) other works and (2) per-implementation details to balance these issues. While this document
          attempts to find a happy medium, it can only make generic suggestions due to its umbrella of affected technologies.
        </t>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Considerations</name>
      <t>
        This document would be unrealistic to assume that VBAs could be deployed simultaneously across all hosts in even
        relatively tiny local subnets. There will undoubtedly be network devices present which have no support for VBAs.
        While that is especially true at the time of writing this document, it is certain that -- like IPv6 itself -- some
        hardware vendors and software developers will never implement the protocol or provide necessary operable support.
      </t>
      
      <section anchor="transitions-dualstack">
        <name>Dual-Stack Communications</name>
        <t>
          A pure IPv6 local network using the AGV IEM across its nodes will simply not be able to communicate
          bidirectionally with node(s) lacking VBA support. Bidirectional traffic between the VBA-unaware node and the
          network gateway will be dropped due to the requirements of address verifications. However, in the case of
          dual-stack LANs, IPv4 traffic can be used as an insecure (read: spoofable) failsafe protocol when connecting
          hosts are explicitly aware of a route in both protocol stacks, such as between a LAN client and a gateway router.
        </t>
        <t>
          The Happy Eyeballs algorithm from <xref target="RFC6555"/> specifies a connection methodology that simultaneously
          attempts IPv4 and IPv6 connections, preferring IPv6 communication. Destination hosts are often selected from a
          pool of Domain Name System (DNS) query results in a round-robin fashion. For local networks using AGV mode, the
          IPv6 network will appear unavailable and broken to the unsupporting node(s): thus, they should fall back to using
          IPv4 in the case where both stacks are supported.
        </t>
        <t>
          This will permit some degree of communication for unsupporting nodes, both on the local link and off-link,
          wherever IPv4 traffic is allowed.
        </t>
      </section>

      <section anchor="transitions-iem">
        <name>Tweaking Interface Enforcement Modes</name>
        <t>
          Local IEMs can be adjusted on hosts communicating directly with unsupporting nodes to better accommodate their
          lack of verified VBAs on-link. For example, two local VBA-enabled nodes corresponding with an ancient device might
          opt to use the AGVL IEM. This could allow them to strongly prefer Secured devices for the rest of the network (such
          as the default gateway) while being accepting of ND Address Resolution traffic that does not contain any Secured
          responses.
        </t>
        <t>
          In the case of a subnet router in a mixed network -- that is, a LAN consisting of VBA-enabled and unaware nodes
          alike -- using the AGVL IEM can once again prove very advantageous for the sake of accommodation. Assuming most
          nodes use VBAs and a few cannot, the only those few are at risk of ND Address Resolution spoofing attacks.
        </t>
      </section>
    </section>
    
    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on various subjects related to the security of Voucher-Based Addresses.
        It also serves to clarify certain VBA processes or tangential protocol-related topics that may not have
        had adequate exploration in the rest of this document.
      </t>

      <section anchor="security-binding">
        <!-- From SEND:
            SEND does not compensate for an unsecured link layer.  For instance,
            there is no assurance that payload packets actually come from the
            same peer against which the NDP was run.
            Likewise, VBAs rely on the principle that link-lyer addresses MUST be unique on the same broadcast medium.
            VBAs offer great protection for unsecured L2 setups, but link-layer security would help to remediate further concerns.
        -->
        <name>Privacy of Link-Layer Bindings</name>
        <t>
          <!-- TODO -->
        </t>
        <t>
          The Appendix of this document contains a detailed statistical evaluation of address randomness;
          see <xref target="appendix-randomness"/>.
        </t>
      </section>

      <section anchor="security-usurp">
        <name>Hijacking or Desynchronizing Link Vouchers</name>
        <!-- Discuss de-sync in LV state as well: nodes in certain IEMs will NOT be able to communicate -->
        <t>
          Theft of the Voucher Bearer role can be achieved by a few different means based on the level of
          employed security in the local network. Without RA-Guard, false VBs are free to constantly advertise
          their own rogue LVs to other hosts. For hosts already on the network with an active LV, this is only
          a problem if VHAs in the LOVMA are not being used and the current LV expires. For hosts joining the
          network for the first time, there is an easy opportunity for an abuse of 'first-come-first-serve'
          trust.
        </t>
        <t>
          If the legitimate VB goes offline and is not able to transmit any updated LVs to the network, the
          current LV can expire. When a LV expires, the design of VBAs requires nodes to accept any incoming LV
          as providing direction and consensus for the nodes on-link. If a malicious host uses other denial of
          service methodologies to force the current VB offline for long enough, the malicious host can force an
          expiration of the current LV and gain control of it.
        </t>
        <t>
          Another less feasible -- but not impossible -- attack would involve theft of the cryptographic private
          key associated with the current LV. Any compromise of the voucher key will result in directly impersonable
          LVs or VHAs that would not be questioned by any network node.
        </t>
        <t>
          Relatively short 'Expiration' windows for LVs are disallowed in LVs because of (1) possible time
          synchronization issues between nodes, (2) 'address storm' prevention, and (3) compensating for possibly
          slow VBs who cannot send LVs to the network fast enough. Most relevant to this section are 2 and 3.
          The 'address storm' prevention relying on this mechanism aims to stop malicious VBs from over-rotating
          the current LV and completely exhausting network nodes who will be very busy trying to keep up with
          VBA generation and verification optimizations. Compensating for a slow VB requires malicious nodes to
          force that same legitimate VB off the network for longer in order to usurp them as the link VB.
        </t>
        <t>
          Hijacking, tampering with, or otherwise desynchronizing the LV can be used for either malicious denial
          of service attacks or to set the difficulty of VBA computation to a very low threshold.
        </t>
        <ul>
          <li>
            Denial of service attacks could result from setting LV parameters to an excessive difficulty. By
            asking local nodes to verify and generate according to absurd KDF demands, even for low iterations
            counts chosen on each host, outrageous amounts of computing power could be wasted on node interfaces.
            This could potentially bind up enough resources on a node to disconnect it from the network entirely.
          </li>
          <li>
            Consider a situation where Group<sub>A</sub> represents hosts aware of legitimate LV<sub>A</sub> and
            Group<sub>B</sub> represents hosts aware of malicious LV<sub>B</sub>. Having multiple LVs active on the
            same link will inevitably lead to different logical subnetworks, where Group<sub>A</sub> hosts are 
            generating and verifying VBAs according to a completely different LV than Group<sub>B</sub>. Depending
            on per-interface IEMs, hosts from one group will be completely barred from communicating with hosts in
            another.
          </li>
          <li>
            Malicious VBs could transmit an LV dictating use of a KDF algorithm with very minimal requirements. For
            example, PBKDF2_SHA256 with an ITERATIONS_FACTOR of 1. Targeting hosts with low iterations counts would
            of course be most efficient for discovering a valid link-layer identifier that produces an address
            collision. Weakening the entire subnet in this way affords the attacker a greater advantage by greatly
            reducing the computation costs of on-path attacks.
          </li>
        </ul>
        <t>
          All of the concerns in this section allude to the importance of guarding the local network from rogue
          LV options in the first place. Though on-path attacks are still LESS feasible with VBAs enabled, regardless
          of LV control, that still does not outweigh the risks assessed above. <xref target="bearers-vigilance"/>
          has more information about RA-Guard and protecting against the rogue LV problem.
        </t>
        <t>
          Other solutions for (1) denial of service attacks disconnecting the current VB from the network, and for
          (2) the deployment of accurate and VBA-aware intrusion detection systems, are beyond the scope of this
          document.
        </t>
      </section>

      <section anchor="security-pki">
        <name>Certifying Link Vouchers</name>
        <t>
          Link Vouchers are susceptible to impersonation despite the use of asymmetric cryptography in signing their
          details. Once a host becomes aware of a valid public-key and signature, it becomes "locked" to this key and
          will not accept LVs from senders NOT using it in their signatures (unless the current LV expires or a VHA is
          issued). However, the initial exchange -- or first-contact -- between a VB and a neighbor is still vulnerable.
          This is because any malicious node on-link could craft a public key for its own LV and advertise it, if the
          node is not first blocked by infrastructure-based solutions like RA-Guard.
        </t>
        <t>
          Section 6 of <xref target="RFC3971"/> dictates the use of Public Key Infrastructure to ensure communication
          is genuine between hosts and routers, and that each router is authorized to provide router information. Trust
          anchors are used to determine whether a certificate presented by a router validates its role in SEND: if the
          router presents a certificate that is trusted by the anchor, then on-link hosts sharing the same trust anchor
          must consider it as legitimate. The same validation of certification paths can also be used to verify RSA
          Signature options between on-link hosts.
        </t>
        <t>
          Establishing certification paths that validate SEND traffic is done through the use of two new ICMP messages:
        </t>
        <ul spacing="compact">
          <li>Certification Path Solicitation (ICMP type 148). Solicits routers with a set of trust anchors and expects
            an advertisement including certificates authorized by one or more of the trust anchors.</li>
          <li>Certification Path Advertisement (ICMP type 149). Routers use these to respond to valid solicitations
            indicating the need for one or more certificate(s) from a set of specified Trust Anchor options.</li>
        </ul>
        <t>
          Future additions to this specification MAY invoke these ICMP options to integrate with public-key signatures
          appearing on Link Vouchers. This might include amendments to the ND Link Voucher option which would extend the
          field by some extra length to convey trust anchor or certification path information. Similar amendments might
          just consider adding trust anchor or certification path information to LVs and letting each neighbor use their
          own certificate stores to validate them.
        </t>
        <t>
          While this proposal seeks to AVOID the complexities introduced by certificates and trust anchors, this same
          supporting infrastructure might be crucial for first-contact trust assurance where RA-Guard or similar mechanisms
          cannot be used to protect the link from malicious VBs. This is probably a much more performant use of certification
          paths than SEND, simply because the trust of a public key only needs to be verified ONCE at each receiver when an
          initial LV, or LV handoff, is received and stored.
        </t>
        <t>
          Such an amendment to LV options is beyond the scope of this document. It is suggested as a possible future endeavor
          that could make VBAs a more secure, isolated, and end-to-end solution, instead of a specification which relies on
          first-come-first-serve trust.
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
          This brief section discusses concerns about potential denial of service attack vectors when
          employing VBAs. Solutions may or may not be provided along with each section.
        </t>

        <section anchor="security-dos-ns-floods">
          <name>Neighbor Solicitation Flooding</name>
          <t>
            Section 4.3.2 of <xref target="RFC3756"/> outlines an attack targeting last-hop routers that inundates the network
            with traffic destined to on-link hosts that do not exist. VBAs do not suffer from this attack vector, as there is
            no extra cost incurred in creating Neighbor Solicitation packets. Mitigations of this attack are therefore left to
            other applied techniques proposed elsewhere.
          </t>
        </section>

        <section anchor="security-dos-na-floods">
          <name>Neighbor Advertisement Flooding</name>
          <t>
            Neighbor Advertisement floods, either with (1) randomized addresses and Target Link Layer Address options or (2) 
            randomized Target Link-Layer Address options for a known address, will NOT affect VBAs and the address verification
            process for enforcing interfaces. This is because VBA NC behavior dictates that all unsolicited NAs be ignored, outside
            of optional support for Gratuitious ND <xref target="RFC9131"/>. NA flooding is therefore not a topic of concern.
          </t>
        </section>

        <section anchor="security-dos-syn-floods">
          <name>Spoofed, High-Iteration Connection Flooding</name>
          <t>
            A malicious node may initiate a series of sessions from bogus IP addresses that demand return traffic at higher layers
            of the network stack, such as TCP SYN floods. This would necessitate that the attack target perform a reverse Address
            Resolution to determine the link-layer address of the supposed initiating IP.
          </t>
          <!-- TODO: moar -->
        </section>

        <!-- TODO: Add more sections. -->
      </section>

      <section anchor="security-fairness">
        <name>Computational Fairness</name>
        <t>
          The selection of an appropriate Key Derivation Function is essential to scale the difficulty of
          discovering hash collisions. The choice of KDF is also essential for the notion of fairness in
          computing the generated result. As described in <xref target="addenda-voucher-kdfs"/>, choosing a
          CPU-bound KDF algorithm is significantly more likely to result in very disparate computation times
          than choosing a Memory-bound KDF for VBA-related calculations. <!-- ext ref -->
        </t>
        <t>
          Even when using memory-bound KDFs like Argon2d, the proper delegation of baseline algorithm
          parameters in the Link Voucher SHOULD always tend toward being more forgiving for low-power or
          embedded systems. The balance of low compute latencies with high security might be difficult to
          determine, but implementations SHOULD attmept to discover and apply defaults that achieve this goal.
        </t>
      </section>

      <section anchor="security-proxies">
        <!-- See RFCs 4389 & 5909 -->
        <name>Neighbor Discovery Proxies</name>
        <t>
        </t>
      </section>

      <section anchor="security-sessions">
        <name>Integrating Neighbor Discovery Sessions</name>
        <t>
          As noted in <xref target="summary-overview-adversaries-kill"/>, VBAs are vulnerable to Identity Assumption
          attacks where an active link-layer-address-to-IP binding could be hijacked by malicious hosts. This is
          accomplished by denying connectivity to the legitimate host owning a link-layer address, then assuming its
          link-layer address in its absence. The malicious host can then intercept all frames destined for the original
          node WITHOUT needing to perform a classic traffic redirection attack.
        </t>
        <t>
          Networks using SEND can also experience Identity Assumption attacks, but only in the short-term because SEND
          relies on CGAs <xref target="RFC3972"/> to enforce knowledge of a private cryptographic key in ND messages. SEND
          itself declares this problem in Section 9.1 <xref target="RFC3971"/>.
          When a new request for ND arrives -- such as during the NUD process -- impersonating nodes will not be able to sign
          ND responses because they do not know the original private key. These concerns are more considerable for VBAs than
          SEND for this very reason: VBAs do NOT require knowledge of some private value that is publicly verifiable.
        </t>
        <t>
          ND Session options <!-- ref --> are used to exchange session details using Zero-Knowledge
          Password Proof (ZKPP) techniques. These options do not interfere with the VBA verification process between two
          nodes, and act to further bolster confidence in neighbor verification over a long-term session. ZKPP allows a
          node to express knowledge of a particular password without exposing the password itself; this typically happens
          through a clever hashing mechanism known as 'reverse hash chain revealing'.
        </t>
        <t>
          An ND Session is a long-term exchange bound to one single instance of Address Resolution between a set of link-layer
          addresses and IP addresses. Changing any of those four variables will necessitate a new Session be formed. A per-session,
          random password is chosen on each session node, whose hash value is repeatedly iterated with a salt value consisting of
          session variables and then given to the session peer. Nodes can prove knowledge of their initial passwords in each ND
          message by slowly revealing each one-time-use 'ancestor' hash in the iteration chain, going back to the Root Hash. See
          the specification <!-- ref --> for more information about its inner workings.
        </t>
        <t>
          ZKPP-based sessions therefore provide strong protection against Identity Assumption attacks occurring in the middle
          of a communication between two neighbors. They are still susceptible to impersonations at the very start of the ND
          Session, but this would require a very opportunistic and reactive attacker, since Sessions can last up to days at a time
          without any update. Implementing ND Session options with VBAs, then, simply shims the ND Address Resolution process with
          Session options. Such implementations SHOULD always validate the underlying session BEFORE processing any VBA verifications.
        </t>
        <t>
          To summarize, ND Sessions reassure two communicating neighbors of each others' persistent identities; on-path attackers
          will not be able to provide ZKPP. Similarly, VBAs provide the link-layer-address-to-IP binding which enforces Address
          Resolutions always return the correct link-layer addresses for target IPs.
          ND Sessions MAY be integrated with VBAs, but are not a requirement and in practice will almost certainly add both
          extra complication and extra latency to ND Address Resolution exchanges. These are again considered a trade-off
          for allowing ND verifications to be end-to-end, instead of something requiring complex implementations or network
          infrastructure to be deployed.
        </t>
      </section>

      <section anchor="security-static">
        <name>Static Addresses</name>
        <t>
          Networks requiring a mix of ephemeral addresses along with static, stable, long-term addresses might
          encounter difficulties deploying and maintaining VBAs. Preserving the state of a local LV long-term
          will not be feasible to maintain stable addresses, as long-term LVs lend themselves to the malicious
          discovery of address collisions.
        </t>
        <t>
          Assigning long-term addresses to hosts on a VBA-enabled network can be accomplished using a few approaches:
        </t>
        <ul>
          <li>
            <t>
              Use the AGVL IEM (<xref target="summary-interfaces-mode"/>) on either the whole subnet, or on interfaces
              known to interact with the target static address(es) directly. The AGVL IEM will permit per-implementation
              behaviors to strongly prefer Secured NDP resolutions over Unsecured ones. Note that this option will remove
              any guarantees of address ownership or on-path attack prevention from the static address(es).
            </t>
            <t>
              It is not necessary to set AGVL on the interfaces with static addresses (unless such interfaces also interact
              with other local static addresses), because IEM affects neighbor verifications and does not impose restrictions
              on statically-assigned local interface addresses.
            </t>
          </li>
          <li>
            <t>
              If local nodes simply do not interact with the static addresses, then the only affected parties are the node(s)
              with the static assignments and the subnet router, which will ostensibly route traffic to and from the static
              address(es). Most Router Advertsements will specify a link-local address as the subnet gateway: if this is the
              case within the subnet, then only router-to-host traffic will fail verification. This is because the router needs
              to be aware of the link-layer identifier corresponding to the static address, but the host forwarding to the
              router can always safely verify using the router's link-local VBA.
            </t>
            <t>
              Therefore, a static entry in the Neighbor Cache of the router should correlate link-layer identifier(s) to the
              static IPv6 address(es) on each host. Doing this for each long-term static address will mitigate any potential
              on-path attacks for both neighbors exchanging packets, while still ensuring all other ND Address Resolutions
              verify according to VBA rules and the level of strictness configured on each network interface.
            </t>
          </li>
          <li>
            Simply use static Neighbor Cache entries across the whole subnet, wherever interactions with the static addresses
            may be required. The use of static NC entries may alleviate the requirement for VBAs at all, however, depending on
            how and where these static addresses are set in the first place. This approach assumes the link-layer identifier of
            each interface carrying one or more static addresses is also stable and unchanging.
          </li>
        </ul>
      </section>

      <section anchor="security-anycast">
        <name>Anycast Addresses</name>
        <t>
          Anycast addresses are allocated from the unicast address space and are thus indistinguishable to
          nodes establishing connections to them. NDP exchanges with these hosts may therefore respond with
          varying Target Link-Layer Address options and cause VBA verification to be unreliable.
          For this reason, it is NOT RECOMMENDED to utilize anycast addresses for on-link prefixes within
          VBA-enabled networks, because the ownership of the address cannot be bound to a particular
          link-layer identifier.
        </t>
        <t>
          The IPv6 Addressing Architecture RFC (<xref target="RFC4291"/>) outlines a Required Anycast Address
          in Section 2.6.1. VBA-enabled links SHOULD maintain compatibility with this requirement by disabling
          verification for on-link subnet anycast addresses. For example, a host using SLAAC to generate an
          address in the subnet 2001:db8:700::/64 SHOULD disable VBA expectations and verifications for the
          address 2001:db8:700::. Because VBA protections must be disabled for this target host, implementations
          SHOULD avoid using the subnet Required Anycast Address altogether.
        </t>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        This document defines two new Neighbor Discovery Protocol option types and one new link-local multicast
        address. One of the NDP option types contains another set of Type-Length-Value (TLV) packet options.
        The multicast address also uses other assigned TLV packets to convey important (but optional) protocol
        information.
      </t>
      <t>
        Two new Neighbor Discovery Protocol options are defined in this document and must have new Option Type
        values assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet Control
        Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Link Voucher option (63), described in <xref target="addenda-voucher"/>.</li>
        <li>The Voucher Summary option (64), described in <xref target="addenda-summary"/>.</li>
      </ul>
      <t>
        The Link Voucher option includes a new option type used to convey KDF algorithm selections.
        Assigned in the "Algorithm Type Options" subregistry are string identifiers corresponding to integers 
        which indicate their Algorithm Type values. Future values MUST be assigned according to the Standards
        Action policy of <xref target="RFC8126"/>. Default registrations are defined in this document:
      </t>
      <table anchor="IANA-algo-type-registrations">
        <name>Initial Values of the "Algorithm Type Options" Subregistry</name>
        <thead>
          <tr>
            <th>Type</th>
            <th>Name/Identifier</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td>VBAKDF_PBKDF2_SHA256</td>
          </tr>
          <tr>
            <td>10</td>
            <td>VBAKDF_ARGON2D</td>
          </tr>
          <tr>
            <td>20</td>
            <td>VBAKDF_SCRYPT</td>
          </tr>
        </tbody>
      </table>
      <t>
        See <xref target="lovma"/> for information about the Local On-link Voucher Multicast Address subscribed
        to by VBA-enabled network interfaces. This section will also contain specific packet formats.
      </t>
      <t>
        Assigned in the "Link-Local Scope Multicast Addresses" subregistry of the "IPv6 Multicast Address Space
        Registry":
      </t>
      <blockquote>
        Address(es): FF02::ABBA<br />
        Description: Local On-link Voucher Multicast Address<br />
        Reference: draft-puhl-6man-ndp-vba-00
      </blockquote>
      <t>
        The well-known UDP port 2196 is used for multicast traffic on the LOVMA channel. Assigned in the "Service
        Name and Transport Protocol Port Number Registry":
      </t>
      <blockquote>
        Service Name: vba_lovma<br />
        Port Number: 2196<br />
        Transport Protocol: UDP<br />
        Description: IPv6 Voucher-Based Addressing LOVMA updates<br />
        Reference: draft-puhl-6man-ndp-vba-00
      </blockquote>
      <t>
        A set of three TLV packet types used specifically in the new LOVMA channel are defined in this document.
        Assigned in the "LOVMA Message Types and Options" subregistry of the "Voucher-Based Addressing (VBA)
        Parameters" registry.
      </t>
      <t>
        The values in the "LOVMA Message Types and Options" subregistry are string identifiers corresponding
        to integers which indicate their packet Type values. Future values MUST be assigned according to the Standards
        Action policy of <xref target="RFC8126"/>. Default registrations are defined in this document:
      </t>
      <table anchor="IANA-lovma-registrations">
        <name>Initial Values of the "LOVMA Message Types and Options" Subregistry</name>
        <thead>
          <tr>
            <th>Type</th>
            <th>Name/Identifier</th>
            <th>Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td>LOVMA_VSR</td>
            <td><xref target="lovma-packets-vsr"/></td>
          </tr>
          <tr>
            <td>2</td>
            <td>LOVMA_VCI</td>
            <td><xref target="lovma-packets-vci"/></td>
          </tr>
          <tr>
            <td>3</td>
            <td>LOVMA_VHA</td>
            <td><xref target="lovma-packets-vha"/></td>
          </tr>
        </tbody>
      </table>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3972.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6105.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6104.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7217.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3756.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8064.xml"/>
        <!-- Default KDF Definitions -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8018.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9106.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7914.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4429.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7527.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9131.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.768.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5758.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6555.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3279.xml"/>
        <reference anchor="ITU.X690.2002" target="https://www.itu.int/rec/T-REC-X.690">
          <front>
            <title>Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER),
              Canonical Encoding Rules (CER), and Distinguished Encoding Rules (DER)</title>
            <author>
              <organization>International Telecommunications Union</organization>
            </author>
          </front>
        </reference>
      </references>
      <!-- <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
          </front>
        </reference>       
      </references> -->
    </references>

    <section anchor="appendix-speed">
      <name>Testing Address Generation Speeds</name>
      <t>
      </t>
    </section>

    <section anchor="appendix-randomness">
      <name>Validating Address Randomness</name>
      <t>
        This section evaluates the statistical randomness of generated VBAs on the basis of a few
        noted conditions. All results were acquired through use of the Dieharder suite of PRNG tests
        <!-- ref -->.
      </t>
      <t>
        Each test procedurally selects starting values and iterates the "PBKDF2 with SHA-256" KDF with a static
        multiplier of 256. The 'variable' condition will then be mutated pseudo-randomly each time all 2<sup>16</sup> possible
        iterations counts have been calculated with the KDF.
      </t>
      <t>
        Each test simulates 2<sup>16</sup> variations, for a total of 2<sup>32</sup> outputs (2<sup>16</sup> variations &times; 2<sup>16</sup> iterations per
        variation). VBA address generation procedures calculating these inputs write to a test file that records the
        address SUFFIXES as 64-bit decimal integers. That test file is then ultimately fed to Dieharder to run PRNG
        tests and thus generate these results.
      </t>

      <section>
        <name>Variable MAC, Fixed Seed, Fixed Subnet (VFF)</name>
        <t>
          Per every set of 2<sup>16</sup> iterations counts, the input link-layer address (MAC in this case) is set to a new
          pseudo-random value. This test shows the random distribution of VBAs on a single subnet with an unchanging
          Link Voucher seed value, among neighbors with unique MAC addresses.
        </t>
        <t>
          This test shows the randomness of address derivations between on-link neighbors.
        </t>
        <t>
          Fixed LV Seed Value: 0x5DD55190_0FA2A986_D3DAB5D2_94B97B63<br />
          Fixed Subnet Prefix: 2001:DB8:C001:5EED
        </t>
        <!-- TODO: Data -->
      </section>

      <section>
        <name>Fixed MAC, Variable Seed, Fixed Subnet (FVF)</name>
        <t>
          Per every set of 2<sup>16</sup> iterations counts, the input Link Voucher Seed is set to a new pseudo-random value.
          This test shows the random distribution of VBAs from a single node on a single subnet with a mutating seed.
        </t>
        <t>
          This test shows the randomness of address derivations between seeds for the same node on the same subnet.
        </t>
        <t>
          Fixed MAC address: FF-1B-83-8B-BC-C0<br />
          Fixed Subnet Prefix: FE80::
        </t>
        <!-- TODO: Data -->
      </section>

      <section>
        <name>Fixed MAC, Fixed Seed, Variable Subnet (FFV)</name>
        <t>
          Per every set of 2<sup>16</sup> iterations counts, the input subnet PREFIX is mutated to a new pseudo-random value.
          This test shows the random distribution of VBAs from a single node on multiple varying subnet prefixes, with
          a fixed seed value.
        </t>
        <t>
          This test shows the randomness of address derivations for the same node on different subnets, using the same
          Link Voucher seed.
        </t>
        <t>
          Fixed MAC address: 6A-1E-56-45-E6-BA<br />
          Fixed LV Seed Value: 0x61E1B40E_3DB48225_5A03DCB5_33068708
        </t>
        <!-- TODO: Data -->
      </section>
    </section>

    <section anchor="appendix-code">
      <name>Code Snippets</name>
      <t>
        This section contains various code snippets related to VBAs. All code is written in C and does not depend
        on any external libraries outside of the standard library.
      </t>

      <section anchor="appendix-code-generation">
        <name>Address Generation Sample</name>
        <t>
        </t>
      </section>

      <section anchor="appendix-code-verification">
        <name>Address Verification Sample</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The author would like to thank Dr. Jinhua Guo of the University of Michigan for his valuable,
        constructive criticisms and support of this document.
      </t>
    </section>
  </back>
</rfc>
