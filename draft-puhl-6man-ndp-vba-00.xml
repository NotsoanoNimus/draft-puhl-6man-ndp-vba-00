<?xml version="1.0" encoding="utf-8"?>
<!-- 
     draft-rfcxml-general-template-standard-00
  
     This template includes examples of the most commonly used features of RFCXML with comments 
     explaining how to customise them. This template can be quickly turned into an I-D by editing 
     the examples provided. Look for [REPLACE], [REPLACE/DELETE], [CHECK] and edit accordingly.
     Note - 'DELETE' means delete the element or attribute, not just the contents.
     
     Documentation is at https://authors.ietf.org/en/templates-and-schemas
-->
<?xml-model href="rfc7991bis.rnc"?>  <!-- Required for schema validation and schema-aware editing -->

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndp-vba-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndp-vba">IPv6 Voucher-Based Address Generation &amp; Verification</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndp-vba-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>vba</keyword>
    <keyword>spoofing</keyword>
    <keyword>privacy</keyword>
    <abstract>
      <t>
        This document specifies an extensible IPv6 unicast address generation and verification methodology for local
        networks. Individual link-layer identifiers are bound to sets of deterministic output addresses, which
        maintain user privacy regardless of link-layer identifier stability. Vouchers distributed by Router
        Advertisements on-link are used to form a consensus between neighbors of the parameters used in the address
        derivation process. Cryptographic key derivation functions are used to generate pseudo-random addresses and
        to stretch address computation times. Host parameters can be used to derive any number of both stable
        and ephemeral, privacy-focused addresses for each on-link prefix and at the link-local scope. NDP
        exchanges can then verify the interface-identifier-to-IP bindings to prevent on-path attacks in local
        networks.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <!--
        RFC 8018:
            Another approach to password-based cryptography is to construct key
            derivation techniques that are relatively expensive, thereby
            increasing the cost of exhaustive search.  One way to do this is to
            include an iteration count in the key derivation technique,
            indicating how many times to iterate some underlying function by
            which keys are derived.  A modest number of iterations (say, 1000) is
            not likely to be a burden for legitimate parties when computing a
            key, but will be a significant burden for opponents.
      -->
      <t>
        Voucher-Based Addressing (VBA) offers an alternative solution to
        the address ownership problem, enables extensible and private unicast address generation, and prevents
        on-path attacks in IPv6 local networks. Using a mutual key derivation function to map input components
        one-to-one to output ciphertexts, link-layer identifiers can be reliably coupled to sets
        of deterministically generated IPv6 addresses and subsequently verified by neighboring nodes. All verifications
        are decentralized and do not require public-key cryptography; only shared consensus on a distributed,
        pseudo-random value used to seed the address generation procedure. The same deterministic algorithm produces
        IPv6 address suffixes appearing statistically random to devices outside the local broadcast domain, who
        are by design unaware of all input parameters associated with the address.
      </t>
      <t>
        This document represents an application of cryptographic key-stretching methodologies to IPv6 address
        generation. The result is a secure, high-impact, low-complexity change bundled with various transition
        capabilities, effectively corroborating IPv6 address ownership to defeat malicious network address spoofing.
      </t>
      <t>
        This document introduces Voucher-Based Addressing (VBA) in IPv6 networks as an optional functionality for Neighbor Discovery Protocol (NDP) <xref target="RFC4861"/>.
      </t>
      <t>
        VBAs operate on the principle that active spoofing requires the impersonation <!-- TODO -->
      </t>

      <section anchor="intro-binding">
        <name>Link-Layer Binding Considerations</name>
        <t>
        </t>
      </section>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <!-- TODO -->
      <t>
        Many of the terms in this document are defined in Section 2.1 of the most current NDP standard <xref target="RFC4861"/>.
      </t>
      <t>
        An alphabetical glossary of terms related to this document, but not necessarily defined herein, is specified in this
        section. Items appearing here may or may not be acronymized even in their first appearances in future sections (but
        never in section headers), so knowledge of them is assumed henceforth.
      </t>
      <dl newline="true">
        <dt>Voucher-Based Address (VBA)</dt>
        <dd>An IPv6 address generated by a mixture of Link Voucher details, network interface details, and subnet details.</dd>

        <dt>Link Voucher (LV)</dt> 
        <dd>A data payload intended to be distributed by a responsible node on-link. Details are statefully maintained
          on host network interfaces and used in both generating and verifying VBAs.</dd>

        <dt>Local On-link Voucher Multicast Address (LOVMA)</dt>
        <dd>A multicast group used by VBA-enabled hosts to get gratuitous information from the current Voucher Bearer or from
          other VBA-enabled neighbors.</dd>

        <dt>Voucher Bearer (VB)</dt>
        <dd>
          The on-link node solely responsible for dissemination of the LV and authorized by any potential link guarding to
          transmit Router Advertisements or Redirects with an LV attached.
        </dd>

        <dt>Voucher Status Report (VSR)</dt>
        <dd>A type of data payload sent by VBA-enabled nodes to the LOVMA. Shares information about the node's VBA-related
          preferences. Mainly used in optimizations and is an optional protocol feature.</dd>

        <dt>Interface Enforcement Mode (IEM)</dt>
        <dd>The operating mode of the VBA-enabled network interface controlling interface reactions to unverified neighbors.</dd>

        <dt>Neighbor</dt>
        <dd>Another connected node on the same link.</dd>

        <dt>Key Derivation Function</dt>
        <dd>Definition of the second term [REPLACE/DELETE]</dd>

        <dt>Link</dt>
        <dd></dd>

        <dt>Node</dt>
        <dd>A device that actively implements and uses IPv6 on the local network.</dd>

        <dt>Hextet</dt>
        <dd>A 16-bit aggregation; data that is 16 bits in size. Can also be called a 'chomp'.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Voucher-Based Addressing</name>
      <t>
        This section outlines the design goals of Voucher-Based Addressing. It includes concrete processes and
        procedures used by VBA-enabled network nodes to verify address ownership and to simultaneously create
        private, pseudo-random network addresses.
      </t>

      <section anchor="summary-overview">
        <name>Design Overview</name>
        <t>
          A Voucher-Based Address is defined as any IPv6 unicast address derived from on-link voucher information.
          The address derivation process is driven by a static, well-known procedure parameterized by a mixture of
          voucher details and public node information. This same derivation process is used by other on-link nodes
          to independently verify the link-layer binding of the address during the Neighbor Discovery Address
          Resolution process.
        </t>
        <t>
          Because deterministic address generation directly depends on the value of the link-layer identifier of the
          node, purported network and target link-layer addresses cannot be falsified in NDP exchanges. Address
          verification is a process parameterized by (1) data which identifies the node's network interface, and (2)
          data which lies OUTSIDE of the generating node's administration. Such information comprises a part of the
          Link Voucher details agreed upon by all neighbors.
        </t>
        <t>
          Consider the following dishonest transactions a node on a VBA-enabled network might consider:
        </t>
        <ul>
          <!-- TODO -->
          <li>Generating a false link-layer address. </li>
        </ul>
      </section>

      <section anchor="summary-generate">
        <name>Address Generation</name>
        <t>
          This section discusses the generation procedure and composition of a VBA.
        </t>
        <figure>
          <name>The Voucher-Based Address Generation Procedure</name>
          <artwork type="ascii-art" name="vbaGeneration.txt">
            <![CDATA[
Address composition:
          PREFIX    //      SUFFIX (64 bits)
    +------ ~ ------+-------------+---------------------+
    | 64-bit prefix | Z (16 bits) |     H (48 bits)     |
    +------ ~ ------+-------------+---------------------+

... where:
    PREFIX = The 64-bit subnet prefix. If the subnet length is
              shorter than 64 bits, the rest of the 64-bit field
              MUST be initialized to 0.
    SUFFIX = The first 8 bytes from the result of a Key Derivation
              Function (KDF) 'K' iterated 'L' times. The leftmost
              hextet is replaced by 'Z'.

Formulas:
    H  =  K(L, Key, Salt)
          |---> K    = A KDF specified by the Link Voucher.
          |---> L    = A random, host-selected 'iterations count'.
          |---> Key  = The 128-bit Link Voucher seed value.
          `---> Salt = [LLID] || 'v' || 'b' || 'a' || [PREFIX]

    Z  =  ~(L ^ H[2..3])

    SUFFIX = hextets{ Z, H[2..3], H[4..5], H[6..7] }
                            `--> (using 0-based indexing)
            ]]>
          </artwork>
        </figure>
        <t>
          The Interface Identifier (IID) for all VBAs, called a SUFFIX, embeds two important details for verification:
        </t>
        <ul>
          <li>
            <t>
              A 16-bit 'Z' value, calculated as a bitwise complement of the XOR of the 'L' value and the second hextet
              of the hash 'H'. This calculation uses this XOR computation to ensure the same iterations count 'L' between
              different KDF results will be unique and provide some resistance to tracking hosts between each generated
              hash. This is especially true if the host locally advertises a well-known or 'sticky' iterations count
              (<xref target="lovma-packets-vsr"/>).
            </t>
            <ul>
              <li>
                The 'L' value, also called 'iterations count' in this document, is an important value. This parameter
                controls how many times the KDF function is iterated to produce the resulting hash. Increasing this
                value increases both the work required to generate the VBA and the work required to find potential
                hash collisions.
              </li>
            </ul>
          </li>
          <li>
            48 bits from the resulting hash, or 'H' value, derived from the KDF after 'L' iterations. Implementations
            are REQUIRED to use the FIRST 8 bytes of the hash in formulating the SUFFIX value, replacing the first
            hextet with the 'Z' value as shown in the figure.
          </li>
        </ul>
        <t>
          The address generation algorithm is detailed procedurally as follows:
        </t>
        <ol>
          <li>A host connects to a VBA network and obtains Link Voucher [<xref target="addenda-voucher"/>] details.</li>
          <li>The 'L' value is chosen based on (1) host preference, (2) intended difficulty, or (3) randomly.</li>
          <li>The Link Voucher details contain instructions for which KDF to use and which 128-bit seed value to use.</li>
          <li>
            <t>
              The KDF Salt is a variable-length CONCATENATION of a few different values, in the order specified
              below. 'Raw' values indicate binary values, NOT hexademical string notations of the values.
            </t>
            <ul spacing="compact">
              <li>
                The raw link-layer identifier of the network interface for which addresses are being generated.
                Note that since the Salt value is a variable-length string, this is NOT REQUIRED to be a MAC
                address, but it MUST represent the link-layer address to which the IPv6 address will be bound.
              </li>
              <li>The string "vba".</li>
              <li>The raw PREFIX (subnet prefix) value. This MUST match the prefix for which the VBA will be generated.</li>
            </ul>
          </li>
          <li>
            <t>
              The final address SUFFIX is computed:
            </t>
            <ul spacing="compact">
              <li>
                The first 16 bits are the bitwise complement of an XOR between the iterations count 'L' and the
                second hextet of the generated KDF hash.
              </li>
              <li>
                The least significant 48 bits are 6 sequential bytes from the KDF hash, skipping the first two
                bytes in the sequence.
              </li>
            </ul>
          </li>
        </ol>
        <t>
          See [<!-- appendix ref -->] for sample code in the C programming language which might better
          demonstrate VBA address generation.
        </t>
      </section>

      <section anchor="summary-verify">
        <name>Address Verification</name>
        <t>
          This section provides a procedural overview of VBA address verification. Two important relative terms will
          need to be established for the sake of clarity:
        </t>
        <dl newline="true">
          <dt>Client Node</dt>
          <dd>The node resolving the link-layer address of a neighbor; sends the initial Neighbor Soliciation packet.</dd>
          <dt>Target Node</dt>
          <dd>The node supplying its target link-layer address in a responding Neighbor Advertisement.</dd>
        </dl>
        <t>
          VBA address verification MUST only performed during the Address Resolution phase of an NDP exchange, where
          enabled on the local interface. Verifying an address entails reconstructing the address generation procedure
          run by the Target Node and ensuring the produced address is equivalent to the one solicited by the Client Node.
        </t>
        <t>
          The Target Node address being resolved can be any unicast address, but MUST be for an on-link prefix.
        </t>
        <t>
          The following figure shows how VBA verification integrates into the NDP Address Resolution process. Node 'A' is
          the Client Node and node 'B' is the Target Node.
        </t>
        <figure>
          <name>The Voucher-Based Address Verification Procedure</name>
          <artwork type="ascii-art" name="vbaVerification.txt">
            <![CDATA[
 ,-- [advertise] <---.
 V       (2)         |
|A|{LV}             |B|{LV}{MAC}
 |   |               |      |
 +---+-> [solicit] --' <====|=== (solicited-node)
 |   |      (1)             |
 |   |                      |
 |   +---------.            |
 |   |         |            |
 |   |  +~~~~~~V~~~~~~~~~~~~+~~~~~~~~~~~+
 `---+->| H := LV.K(        | [rebuild  |
 (3) |  |   L := Z'(B),     |  addr B]  |
     `--+-> LV.seed,   v----'           |
        |   makeSalt(MAC, prefix(B))    |
        | );                            |
        +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            |
            |      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            `----> | [prefix(B) || suffix(Z(L, H), H)] === B |
                   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                        (4)  {????}
                              |  |
           DROP <-- false <---'  '---> true --> ACCEPT/CACHE
            ]]>
          </artwork>
        </figure>
        <t>
          The Link Voucher 'LV' MUST always be used from the state preserved on the verifying interface. Nodes
          SHALL NOT request the Link Vouchers of others for any reason. If the verification procedure fails due
          to an LV mismatch between nodes A and B, then there is most likely either (1) a synchronization problem
          or (2) an issue with multiple same-link LVs being distributed.
        </t>
        <t>
          In the above figure, the "Z'" (Z-prime) function returns the iterations count embedded in Host B's address.
          This function is the opposite of 'Z'; it uses an input address to determine 'L' rather than using
          an input 'L' to determine an output hextet. Despite the different inputs, the naming alludes to the
          opposite purposes for each function.
        </t>
        <dl newline="true">
          <dt>Z(L, H) = ~(L ^ H[2..3])</dt>
          <dd>Returns a hextet to insert into a generated address. A bitwise complement of an iterations count
            XOR'd with the second hextet of an output KDF hash 'H'.</dd>
          <dt>Z'(B) = ~(B[8..9] ^ B[10..11])</dt>
          <dd>Returns an iterations count derived from a full IPv6 address. In this case, 'B[8..9]' is equal to
            the length and position of the hextet calculated by the function 'Z' above.</dd>
        </dl>
        <t>
          See the figure below for a visualization of calculating Z' from a Voucher-Based Address.
        </t>
        <figure>
          <name>Extracting the Embedded Iterations Count (Z')</name>
          <artwork type="ascii-art" name="embeddedIterations.txt">
            <![CDATA[
                                  SUFFIX
                       _____________/\____________
                      /                           \
Byte: 0      ..     7 8    9    10   11   12 .. 15
      +------ ~ ------+----+----+----+----+-- ~ --+
Addr: |  PREFIX (64)  |  Z (16) |     H (48)      |
      +------ ~ ------+----+----+----+----+-- ~ --+
                      \________/\________/
                           |         |
                   Z or B[8..9]  B[10..11]

    Z'  =  L  =  NOT( B[8..9] XOR B[10..11] )
                  or NOT( SUFFIX[0..1] XOR SUFFIX[2..3] )
            ]]>
          </artwork>
        </figure>
        <t>
          Z' is necessarily computed for each VBA verification because the 'L' value is a required component to
          reconstruct the solicited address of the Target Node.
        </t>
        <t>
          See [<!-- appendix ref -->] for sample code in the C programming language which might better
          demonstrate VBA address verification.
        </t>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface-level Configurations</name>
        <t>
          This section outlines different interface-level configurations and options which MUST be available in
          any implementation of this specification.
        </t>

        <section anchor="summary-interfaces-state">
          <name>Preserving Voucher-Related State</name>
          <t>
            VBA-enabled interfaces for all nodes, regardless of their selected Interface Enforcement Modes, are
            REQUIRED to store the full state of the most current, validated Link Voucher. If a Link Voucher is not
            available on-link, then no stored LV state is required and the node MUST enter the Address Awareness
            Disabled state (see the next section). If a LV subsequently becomes available, the node MAY choose to
            enter a different state or IEM based on the implementation.
          </t>
        </section>

        <section anchor="summary-interfaces-mode">
          <name>Interface Enforcement Modes</name>
          <t>
            Per-interface modes (IEMs) are able to granularly dictate the local NDP behaviors related to VBAs.
            This flexibility in per-interface behavior grants VBAs more transition and adoption capabilities.
            A tiny state machine diagram would depict all of these states as being transitionable to any of
            the others.
          </t>
          <t>
            Implementations MUST allow nodes to independently opt into any one of the following IEMs for EACH
            of their local interfaces:
          </t>
          <dl newline="true">
            <dt>AAD - Address Awareness Disabled</dt>
            <dd>The VBA-aware interface MUST NOT generate or verify any addresses, regardless of the incoming
              packets. It MUST NOT participate in any LOVMA traffic exchanges. In this mode, VBAs are ignored.
              This mode SHALL always be used by VBA-enabled interfaces on links without an established LV.</dd>

            <dt>AGO - Address Generation Only</dt>
            <dd>The address generation procedure is followed for unicast addresses. The NDP Address Resolution
              process MUST NOT be supplemented by VBA optimization or verification procedures.</dd>

            <dt>AGV - Address Generation &amp; Verification</dt>
            <dd>The address generation and verification procedures are followed as per this document. Address
              Resolution is REQUIRED to fail if the advertised target link-layer address cannot be successfully
              bound to the target IP address. This SHOULD be the canonical, default Enforcement Mode for VBAs.</dd>

            <dt>AGVL - Address Generation &amp; Verification with Levels</dt>
            <dd>Both address generation and verification procedures are employed, but verification failures MUST
              NOT be strictly enforced during NDP Address Resolution. Neighbors whose VBA(s) successfully verify
              MUST be marked or indicated locally as "Secured". A neighbor which fails to verify
              MUST be indicated as "Unsecured" and given less trust or authority than "Secured" responses.</dd>
          </dl>
          <t>
            For AGVL mode, the Secured and Unsecured distinction is inherited from SEND <xref target="RFC3971"/>.
            If an AGVL interface receives multiple Neighbor Advertisement responses, it MUST strongly prefer Secured
            NAs over Unsecured NAs to determine which link-layer address is legitimate during the Address Resolution
            process. If multiple Secured responses are received, each with different link-layer addresses, then there
            is a VBA collision and the behavior of the interface is undefined. In this rare case, the pool of Secured
            responses might be equally valid, so it is left to the implementation to decide the correct course of action.
          </t>
        </section>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable VBA functionality.</t>

      <section anchor="addenda-voucher">
        <name>Link Voucher Option</name>
        <t>
          The Link Voucher (LV) option specifies the address generation (and consequent verification)
          parameters which on-link hosts MUST agree upon when generating or verifying local VBAs.
        </t>
        <figure>
          <name>Structure of the NDP Link Voucher option</name>
          <artwork type="ascii-art" name="linkVoucherOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |   Pad Length  |    Reserved   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit Expiration                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                                                               |
  |                      128-bit Voucher Seed                     |
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                       TLV Algorithm Type                      <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                      DER-encoded Public Key                   <
  >                            & Signature                        <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                             Padding                           <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>63</dd>
          <dt>Length</dt><dd>The total length of the LV from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <!-- TODO: Add all parameter definitions per LV specification. -->
        </dl>

        <section anchor="addenda-voucher-senders">
          <name>Processing Rules for Senders</name>
          <t>
            Senders of Link Vouchers MUST maintain stateful information about their LVs at all times, so reliable and consistent
            LV details can be sent at any time. The rotation of stable LV information, such as the Seed value or Expiration details,
            SHOULD be signaled in advance using the LOVMA group <xref target="lovma-packets-pvr"/>. Transferral of LV responsibility
            to another LV identifier SHOULD use similar means <xref target="lovma-packets-vha"/>.
          </t>
          <t>The Sender's LV MUST always be unique on-link and NEVER be forwarded or duplicated copies of other LVs.</t>
          <t>
            Sending nodes wishing to distribute a Link Voucher MUST first check the local link for an already-active LV. This
            entails following a process of router discovery, then only assuming LV responsibility if no LV is already present.
          </t>
          <ol spacing="compact">
            <li>Send a Router Soliciation to the All Routers multicast group at FF02::2.</li>
            <li>Wait for an LV for at least 2 seconds before sending another Soliciation.</li>
            <li>
              <t>Repeat this process 2 more times.</t>
              <ul spacing="compact">
                <li>If an LV is received within a Router Advertisement response, accept and use the parameters of the received LV.
                  This condition means the sender MUST NOT send their own LV, nor should it propagate any instances of LV options.</li>
                <li>
                  <t>If no LV is received after the 3 total attempts, and...</t>
                  <ul spacing="compact">
                    <li>the Sender IS NOT a router: the Sender's LV may be distributed on the local link as an option attached
                      to an appropriate NDP Redirect packet.</li>
                    <li>the Sender IS a router: the Sender may attach its LV to an appropriate NDP Router Advertisement packet.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ol>
          <t>
            On-link nodes responsible for an LV (also known as Voucher Bearers (VBs) -- see <xref target="bearers"/>)
            MUST respond to Router Soliciation packets. This is true regardless of whether the VB is using a Redirect or Router
            Advertisement to distribute its LV.
          </t>
          <t>
            Protecting the link from rogue LVs is crucial to securely maintain the full consensus of the local network.
            See <xref target="bearers-vigilance"/> on RA-Guard and <xref target="security-usurp"/> about LV Hijacking
            for more details.
          </t>
        </section>

        <section anchor="addenda-voucher-receivers">
          <name>Processing Rules for Receivers</name>
          <!-- TODO -->
          <t>
            Receiving nodes MUST statefully maintain and update all LV information per interface, if and only if the received LV
            is successfully verified according to its cryptographic signature.
          </t>
          <t>A Link Voucher option appearing with any packet except NDP Router Advertisements or NDP Redirects MUST be ignored.</t>
          <t>
            Nodes acting as authorized Voucher Bearers MUST disregard any received LV options on the links for which they are
            already the responsible VB. When VBs interact with VBAs, whether generating or verifying, they MUST use their own
            distributed LV for the interacting interface.
          </t>
        </section>

        <section anchor="addenda-voucher-kdfs">
          <name>Algorithm Type Options</name>
          <t>
            Section 5 of <xref target="RFC8018"/> specifies the definition of a Key Derivation Function (KDF):
          </t>
          <blockquote>
               A key derivation function produces a derived key from a base key and
               other parameters.  In a password-based key derivation function, the
               base key is a password, and the other parameters are a salt value and
               an iteration count...
          </blockquote>
          <t>
            This section will discuss the default algorithms and KDF types that SHOULD be packaged with basic implementations
            of this specification. Future versions or extensions of this document MAY add new Key Derivation Function algorithms.
          </t>
          <t>
            Any Algorithm Type option not specified in this document or in future versions MUST be ignored by receivers.
          </t>
          <t>
            Any TLV Algorithm Type choice is formatted as a Type-Length-Value object, where Type is a numeric identifier
            uniquely representing a chosen KDF, Length is the width of the total TLV Algorithm Type in units of 4 octets,
            and Value is a compact data format zero-padded to the nearest 32-bit boundary. Receivers MUST always ignore padding
            and senders MUST always initialize padded areas to zero.
          </t>
          <figure>
            <name>Structure of an Algorithm Type Option</name>
            <artwork type="ascii-art" name="algorithmOption.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Type             |             Length            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                             Value                             <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <t>
            The list of default KDF Algorithm Type choices is given below.
          </t>
          <!-- Might it be better to use ASN1 notation here or DER to convey some object details? -->
          <dl newline="true">
            <dt>PBKDF2_SHA256</dt>
            <dd>
              <t>
                The Password-Based Key Derivation Function (PBKDF2) is defined in Section 5.2 of <xref target="RFC8018"/>.
                It is a CPU-bound cryptographic function which might incur significant computation speed disparities
                between embedded systems and high-performance hardware. It is included primary for portability,
                universality, and ease of implementation.
              </t>
              <t>
                This specification explicitly uses PBKDF2 with SHA-256 as its PRF: implementations using this Type MUST
                use SHA-256 as the PBKDF2 Pseudo-Random Function.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>1</dd>
                <dt>Length</dt><dd>2</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>ITERATIONS_FACTOR</dt>
                    <dd>
                      A 16-bit integer representing the multiplier of an input KDF iterations count, specified in big-endian
                      format. This value MUST be greater than 0; receivers of 0 values MUST use 1 instead. This factor can be
                      used by a Link Voucher to automatically scale the 'difficulty' of the PBKDF2 KDF on the network.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
            <dt>Argon2d</dt>
            <dd>
              <t>
                The Argon2 algorithm is specified in Section 3 of <xref target="RFC9106"/>. It is a Memory-bound cryptographic
                function which will ideally provide less disparate address computation speeds than CPU-bound algorithms like
                PBKDF2. Implementations SHOULD always prefer to use this Type over others, provided all participating network
                devices have Argon2 support.
              </t>
              <t>
                This specification explicitly opts to use Argon2d instead of Argon2i or Argon2id because the generation of
                VBAs does not require any resistance to side-channel attacks. The in-memory data used by the KDF SHOULD NOT be
                treated as secret for any reason. All Implementations with this Type MUST specifically use Argon2d.
              </t>
              <t>
                The iterations count 'L' value is used as the 't' input for Argon2d computations. The Argon2 't' parameter
                indicates the number of passes and is used to increase the algorithm's running time regardless of MemorySize.
              </t>
              <t>
                The Argon2 parameters for Secret Value 'K' and Associated Data 'X' MUST NOT be used or distributed by the LV.
                The Tag Length 'T' for Argon2d MUST be set to 32 and MUST NOT be changed.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>10</dd>
                <dt>Length</dt><dd>3</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>Parallelism</dt>
                    <dd>
                      A 24-bit integer determining how many degrees of parallelism (lanes) are allowed to run during KDF
                      computation. This value SHALL NOT be set to 0. Receivers MUST consider Parallelism values of 0 to
                      automatically indicate a Parallelism of 1.
                    </dd>
                    <dd>Padding</dd>
                    <dt>
                      8 bits (one octet) of padding initialized to zero. Senders MUST set this to 0. Receivers MUST ignore
                      this padding.
                    </dt>
                    <dt>MemorySize</dt>
                    <dd>
                      A 32-bit integer representing the number of kibibytes used in the KDF computation. This value SHOULD be
                      carefully controlled and take into consideration the computing resources across the link on which the LV
                      will be distributed. This value MUST be a minimum of 8*Parallelism and MUST NOT be set to 0. Receivers MUST
                      adjust the minimum MemorySize accordingly if the value does not meet the minimum threshold for the ACTUAL
                      degree of parallelism being used.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
            <dt>Scrypt</dt>
            <dd>
              <t>
                The Scrypt KDF algorithm is specified in Section 6 of <xref target="RFC7914"/>. It is a Memory-bound cryptographic
                function which, similar to Argon2, ideally providing less disparate address computation durations than CPU-bound
                key derivation techniques.
              </t>
              <t>
                The iterations count 'L' value is used in part for both the 'N' and 'r' inputs for Scrypt computations. The Scrypt
                'N' parameter indicates the CPU/Memory cost of running the computation. This value MUST ultimately be a power of 2.
                The 'r' Scrypt parameter indicates the desired block size. Actual values are computed by the following conversion:
              </t>
              <t>
                r (Parallelism) := MAX{ 16, (L &amp; 0xFF00) &gt;&gt; 4 }<br />
                N (Cost) := MAX{ 2, 1 &lt;&lt; (L &amp; 0x00FF) }
              </t>
              <t>
                The Scrypt parameter 'dkLen' (derived key length) MUST always be set to 32 and MUST NOT differ between
                implementations. The Parallelization parameter 'p' MUST always be set to 1 and MUST NOT differ between
                implementations.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>20</dd>
                <dt>Length</dt><dd>1</dd>
                <dt>Value</dt>
                <dd>There are no extra parameters to control for the Scrypt Algorithm Type option.</dd>
              </dl>
            </dd>
          </dl>
        </section>

        <section anchor="addenda-voucher-signatures">
          <name>Voucher Signatures</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-voucher-expirations">
          <name>Voucher Expirations</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="addenda-summary">
        <name>Voucher Summary Option</name>
        <t>
          The Voucher Summary (VS) option is included with Neighbor Solicitation and Advertisement packets to hint to
          recipients which active Link Voucher ID is being statefully used on the target or source interface.
        </t>
        <figure>
          <name>Structure of the NDP Voucher Summary option</name>
          <artwork type="ascii-art" name="voucherSummaryOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>64</dd>
          <dt>Length</dt><dd>Set to 1. The total length of the VS from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>IEM</dt>
          <dd>
            <t>
              A 3-bit identifier representing the current Interface Enforcement Mode of the sending interface (see
              <xref target="summary-interfaces-mode"/>).
            </t>
            <dl spacing="compact" newline="false">
              <dt>0</dt><dd>AAD</dd>
              <dt>1</dt><dd>AGO</dd>
              <dt>2</dt><dd>AGV</dd>
              <dt>3</dt><dd>AGVL</dd>
              <dt>4</dt><dd>Reserved</dd>
              <dt>5</dt><dd>Reserved</dd>
              <dt>6</dt><dd>Reserved</dd>
              <dt>7</dt><dd>Reserved</dd>
            </dl>
          </dd>
          <dt>Reserved</dt><dd>A 13-bit field reserved for future use. This MUST be initialized to zero by the sender and MUST
            be ignored by the receiver.</dd>
          <dt>VoucherID</dt><dd>The 32-bit ID of a valid Link Voucher retained on the sending interface.</dd>
        </dl>

        <section anchor="addenda-summary-senders">
          <name>Processing Rules for Senders</name>
          <t>
            Senders SHOULD always include this option with all NDP Neighbor Solicitations or Advertisements. When a valid,
            unexpired LV is NOT currently available on the sending interface, senders MUST set the IEM to AAD mode and initialize
            the VoucherID to 0.
          </t>
          <t>
            The IEM value MUST be accurately set to the current IEM of the sending interface. The 32-bit VoucherID field MUST
            be equal to the cached Link Voucher ID for the sending interface.
          </t>
        </section>

        <section anchor="addenda-summary-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
            The VS option is NOT REQUIRED and SHALL NOT become required at any future time. Any NDP packets not including it MUST
            be treated as they normally would by the receiver's IEM and other processes. The same is true for VS options which are
            'ignored' due to incorrect formatting or some other validation decision.
          </t>
          <t>
            If the receiver's IEM is AAD, the VS option MUST be ignored.
          </t>
          <t>
            Processing of valid VS options is affected by which NDP packet types they are attached to:
          </t>
          <dl newline="true">
            <dt>Neighbor Solicitations</dt>
            <dd>
              The receiving interface MUST disregard the NS if there is a non-zero VoucherID present and it does not match the
              ID of the active Link Voucher of the receiving interface. To 'disregard' means to not respond to the NS at all.
            </dd>
            <dt>Neighbor Advertisements</dt>
            <dd>
              <t>
                Processing affects VBA verification procedures on the receiving interface based on the receiver's IEM.
              </t>
              <t>
                Receivers MUST first inspect the IEM field to acquire the mode of the sending interface. If the IEM indicates an
                AAD mode at the sender, the receiver MUST behave according to their own IEM:
              </t>
              <dl newline="true" spacing="compact">
                <dt>AAD</dt><dd>Ignore the VS option entirely.</dd>
                <dt>AGO</dt><dd>Ignore the VS option since VBA verification is not being performed anyway.</dd>
                <dt>AGV</dt><dd>Drop the packet. Do not cache the neighbor's details. Completely deny them.</dd>
                <dt>AGVL</dt><dd>Regard the neighbor as Unsecured and skip the VBA verification process.</dd>
              </dl>
              <t>
                If the VoucherID field is initialized to zero, the VS option MUST be ignored. If the VoucherID value does not match
                the ID of the active Link Voucher on the receiving interface, the VS option MUST be ignored. Otherwise, processing
                proceeds to VBA verification per the receiver's IEM.
              </t>
            </dd>
            <dt>Any other NDP packet types</dt>
            <dd>The receiver MUST ignore the VS option.</dd>
          </dl>
        </section>
      </section>
    </section>

    <section anchor="behavioral">
      <name>Behavioral Neighbor Discovery Changes</name>
      <t>
        This section describes the requirements and implications of VBAs with regard to ordinary NDP. Simple
        amendments to NDP are necessary to secure the Address Resolution process.
      </t>

      <section anchor="behavioral-send">
        <name>Changes Adopted from SEND</name>
        <t>
          A few changes in NDP are adopted from the SEND specification <xref target="RFC3971"/> and applied to
          integrate with VBA functionality. This is done for both compatibility and protocol robustness.
        </t>

        <section anchor="behavioral-send-nonce">
          <name>Nonce Option</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-send-levels">
          <!-- See Section 8 of RFC 3971. -->
          <name>Secured &amp; Unsecured Distinctions</name>
          <t>
            Section x of the SEND RFC <xref target="RFC3971"/> defines a
          </t>
        </section>
      </section>

      <section anchor="behavioral-cache">
        <name>Protecting the Neighbor Cache</name>
        <t>
          The primary verification goal of VBAs results in a symmetric computation that can be costly for
          low-power nodes or other embedded systems. By requiring address verification ONLY when interacting
          with the local Neighbor Cache, nodes do not need to perform the entire verification procedure as
          frequently.
        </t>
        <t>
          This section discusses some behavioral NDP changes regarding the host's Neighbor Cache. The changes
          are aimed at a balanced mixture of optimization and security.
        </t>

        <section anchor="behavioral-cache-receiving">
          <name>Receiving Neighbor Solicitations</name>
          <!-- DO NOT EAGERLY CACHE WITHOUT VERIFYING. -->
          <t>
          </t>
        </section>

        <section anchor="behavioral-nud">
          <name>Neighbor Unreachability Detection</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-cache-unsolicited">
          <name>Receiving Unsolicited Traffic</name>
          <t>
            Any node receiving unsolicited traffic from a neighbor, for which no response is required from
            the receiver -- such as UDP-based applications -- does not need to interact with the VBA system
            at all. The receiving node MAY choose to validate the sender according to this specification.
            This would necessitate the neighbor verification process be conducted in reverse.
          </t>
          <t>
            If the sending neighbor is already in the receiver's neighbor cache, then the receiver SHOULD
            NOT verify the address of the sender. The cache MAY be refreshed if the link-layer IP address
            bindings have not changed for the sender's cache entry.
          </t>
          <t>
            As stated in this document's introduction (<xref target="intro"/>),
            VBA employment primarily supplies privacy-focused address generation and uses neighbor address
            verification to provide proof of address ownership. The goal is to prevent on-path attackers
            from illegally, ACTIVELY intercepting local network traffic. Therefore, receiving packets for
            which no response is necessary does not merit an explicit requirement that the sending neighbor
            be verified.
          </t>
        </section>
      </section>

      <section anchor="behavioral-dad">
        <name>Duplicate Address Detection</name>
        <t>
          When generating a VBA, the node MUST follow the ordinary means of Duplicate Address Detection (DAD)
          specified by the SLAAC RFC (section 5.4 of <xref target="RFC4862"/>). The DAD procedure SHOULD follow
          any other applicable DAD optimizations (<xref target="RFC4429"/>, <xref target="RFC7527"/>, etc.).
        </t>
        <t>
          Upon detecting a duplicate address, VBA-enabled nodes MUST by necessity to select another iterations
          count 'L' value to generate a non-conflicting address. This can become computationally expensive
          to recompute each new value based on the amount of address collisions, or in the case of denial of
          service attacks.
        </t>
        <t>
          To counter this weakness, implementations MUST employ one of two options based on the selected 'L' value:
        </t>
        <dl newline="true">
          <dt>L &gt;= 4</dt>
          <dd>Cache the 4 leading KDF computations (L-4 through L-1) during the DAD procedure.</dd>
          <dt>L &lt;  4</dt>
          <dd>Cache the result of the 'L' value only.</dd>
        </dl>
        <t>
          Implementations SHOULD always prefer the option where the 'L' value is &gt;= 4, because
          L-4 through L-1 are intermediate KDF results already required in order to produce the result at the final
          iterations count. Conversely, any 'L' value under 4 will simply cache 'L' then increment the KDF iterations
          by one for each DAD collision, up to 4 times.
        </t>
        <t>A figure representing this process visually is shown below:</t>
        <figure>
          <name>Using DAD with VBAs</name>
          <artwork type="ascii-art" name="duplicateAddressDetection.txt">
            <![CDATA[
COMPUTE & CACHE:
  N = Set of K(L', Key, Salt),
    where L' :=
      if L >= 4 :  { L-4, L-3, L-2, L-1, L },
      else      :  { L }

           (1)      +~~~~~~~~~~~~~~+
 |A|{B}------------>| Normal SLAAC | (B :  Duplicate!)
  |     v-----------|  DAD Process | (B':  Success!)
  |  [FAIL]  (2)    +~~~~~~~~~~~~~~+
  |                      ^
  |                      |
  `---> [cached (L-1)    | (3)
         generates B'] --'
            ]]>
          </artwork>
        </figure>
        <t>
          In the figure, (1) shows host 'A' engaged in DAD using the address 'B' generated with the iterations count 'L'.
          After the collision is detected in (2), step (3) shows the new address "B'" being immediately tried using the
          already-cached value 'L-1' as the input iterations count. The DAD process is then successful and there are no
          on-link duplicate addresses.
        </t>
        <t>
          To further cement this important optimization procedure, a written example process follows.
        </t>
        <ol>
          <li>A new network host has received Link Voucher details; the voucher specifies using PBKDF2.</li>
          <li>The host arbitrarily selects 0xFF04 as its input link-local iterations count.</li>
          <li>The host will iterate the PBKDF2 function through 0xFEFF.</li>
          <li>When retrieving the PBKDF2 cipher output for 0xFF00 (L - 4) iterations, it will cache this value.</li>
          <li>It will do the same for the next 3 iterations counts (0xFF01, 0xFF02, &amp; 0xFF03).</li>
          <li>It will compute the final PBKDF2 round at 0xFF04 iterations, and will use the result to generate
            a valid VBA <xref target="summary-generate"/>.</li>
          <li>When following the DAD procedure, a collision is detected.</li>
          <li>The host then falls immediately back to the L - 1 iterations count of 0xFF03 to generate the VBA.</li>
          <li>This new host address is completely different and does not register a DAD collision.</li>
          <li>The optimization has successfully removed the need to recompute the PBKDF2 algorithm up to some new
            iterations count, saving a significant amount of time in the VBA-enabled SLAAC process. Reducing the
            chosen 'L' value by 1 results in a completely different pseudo-random address.</li>
        </ol>
        <t>
          If all 5 attempted iterations counts result in DAD collisions, then the node MUST give up and use some other
          implementation-specific course of action to contact an administrator or log a system management error.
        </t>
        <t>
          Note that truly benign DAD collisions are a dangerous prospect for Voucher-Based Addressing. Address
          collisions imply that a separate link-layer identifier with the SAME iterations count has somehow
          generated a hash suffix collision, exposing the possibility for node impersonation in a rare occurrence.
          Some implementations MAY wish to find trusted ways to detect such an occurrence, possibly by means
          of intermediate device monitoring (such as switching hardware), and take action based on it.
        </t>
        <t>
          Nodes encountering a duplicate address will by necessity require a different iterations count to
          generate their current address. If the node uses a 'sticky' iterations count, then it is RECOMMENDED
          that it send a gratuitous VSR update to the LOVMA with the new count (<xref target="lovma-packets-vsr"/>).
        </t>
        <t>
          A discussion regarding denial of service attack vectors related to DAD in VBA networks is found in
          <xref target="security-dos-dad"/>.
        </t>
      </section>
    </section>

    <section anchor="lovma">
      <name>Local On-link Voucher Multicast Address</name>
      <t>
        The LOVMA group is defined for the express purpose of sharing gratuitous, independent VBA details between nodes.
        All nodes with VBA awareness, regardless of Interface Enforcement Mode (<xref target="summary-interfaces-mode"/>)
        are strongly RECOMMENDED to join this group. Nodes are NOT REQUIRED to make practical use of any LOVMA traffic.
      </t>
      <t>
        This multicast group is located at the IPv6 address FF02::ABBA. A helpful mnemonic to remember this address is to
        think of "ABBA" as the closest possible hexademical rendition of "a VBA".
      </t>

      <section anchor="lovma-constraints">
        <name>Constraints</name>
        <t>
          When utilizing the LOVMA for any purpose, experimental or deployed, implementations MUST regard these constraints:
        </t>
        <ul>
          <li>LOVMA traffic is considered unidirectional. Nodes SHOULD NOT send unicast responses in reply to multicast traffic.
            This recommended constraint acts to prevent asymmetric traffic volumes and potential denial of service vulnerabilites
            leveraging the LOVMA.</li>
          <li>All LOVMA datagrams MUST be User Datagram Protocol (UDP) <xref target="RFC768"/> packets.</li>
          <li>VBA-enabled nodes MUST NOT assume that other VBA-enabled nodes are subscribed to the LOVMA multicast group or
            receiving any of its related datagrams.</li>
          <li>Subscribing nodes MUST NOT offer any trust of LOVMA packets, unless a datagram validation procedure is explicitly
            declared for the extension protocol using the LOVMA.</li>
        </ul>
      </section>

      <section anchor="lovma-packets">
        <name>Defined Datagrams</name>
        <t>
          This section outlines and formalizes some initial datagrams which may be gratuitously sent to the LOVMA at any time.
        </t>

        <section anchor="lovma-packets-vsr">
          <name>Voucher Status Reports (VSRs)</name>
          <t>
          </t>
          <figure>
            <name>Structure of a VSR Datagram</name>
            <artwork type="ascii-art" name="lovmaVsr.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>

        <section anchor="lovma-packets-vci">
          <name>Voucher Capability Indications (VCIs)</name>
          <t>
            Nodes may notify the LOVMA about their potential candidacy as a link Voucher Bearer (<xref target="bearers"/>) by
            sending a VCI datagram. The VCI is an informational packet REQUIRED to be considered for election by the current VB.
          </t>
          <t>
            Receivers are typically intended to be the current VB, but any node MAY make use of VCI details. Nodes MUST NOT consider
            VCI packets as valid Link Vouchers. The current VB MAY maintain a state of unexpired VCI packets, especially when
            it intends to elect a new node responsible for the LV.
          </t>
          <figure>
            <name>Structure of a VCI Datagram</name>
            <artwork type="ascii-art" name="lovmaVci.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>

        <section anchor="lovma-packets-vha">
          <name>Voucher Handoff Advertisements (VHAs)</name>
          <t>
            The node responsible for the Link Voucher MAY at any time elect a new link Voucher Bearer (<xref target="bearers"/>)
            using the VHA datagram. This 'handoff' communication notifies VBA-enabled hosts of a change in VB and thus public-key
            information used to sign the new LV. If the public-key signature on the VHA is valid and nodes are 
          </t>
          <t>
            Candidate nodes considered for VB election MUST be gathered from either (1) manually configured details or (2) senders
            of recent, unexpired VCI notifications.
          </t>
          <t>
            When the elected node observes the VHA packet granting it VB responsibility, it MUST begin sending gratuitous Router
            Advertisements to the local network for which it is now a VB. Sending a RA to the local network always follows the receipt
            of a valid, unexpired VHA from the previous VB. After 2 minutes, the new VB MUST consider the LV parameters (including the
            public key) of the previous VB as invalid, and no longer trigger RAs based on receipt of VHAs.
          </t>
          <figure>
            <name>Structure of a VHA Datagram</name>
            <artwork type="ascii-art" name="lovmaVha.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>

        <section anchor="lovma-packets-pvr">
          <name>Preemptive Voucher Rotations (PVRs)</name>
          <t>
          </t>
          <figure>
            <name>Structure of a PVR Datagram</name>
            <artwork type="ascii-art" name="lovmaPvr.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="bearers">
      <name>Voucher Bearers</name>
      <t>
        A Voucher Bearer (VB) is the on-link node responsible for the current, majority-accepted Link Voucher. This
        section introduces any VB constraints or procedures for implementations or deployments to maintain awareness of.
      </t>
      <t>
        Any node MAY be elected to serve as the link's VB, whether by manual configuration or by a process of election
        and appointment from the current VB (see <xref target="lovma-packets-vci"/>). If the current VB is NOT a router
        or responsible for routing subnet traffic, then it MUST distribute the LV via an NDP Redirect packet with an LV
        option, instead of using an NDP RA packet with the LV option. The Redirect is expected to behave similarly to
        the defined NDP process (<!-- NDP section ref -->).
      </t>

      <section anchor="bearers-vigilance">
        <name>Employing RA-Guard</name>
        <t>
          RA-Guard, short for Router Advertisement Guarding, is specified in <xref target="RFC6105"/> as a response to
          the Rogue RA Problem Statement in <xref target="RFC6104"/>. Networks need to protect against basic Rogue RAs
          in order to keep routing trusted and secured without high-complexity changes to the infrastructure. <!-- TODO -->
        </t>
        <t>
          In the case where the elected VB is NOT a link router nor responsible for routing traffic, and NDP Redirect
          packets are being used with the LV option, RA-Guard is RECOMMENDED to also include these in its learning
          processes.
        </t>
        <t>
          The exact deployment of RA-Guard is beyond the scope of this document, but it is STRONGLY RECOMMENDED in
          order to ensure VBAs faithfully serve their purpose during the NDP Address Resolution process.
        </t>
      </section>

      <section anchor="bearers-timeouts">
        <name>Timeouts or Expirations</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="optimizations">
      <name>Specification Optimizations</name>
      <t>
        This section discusses the various optimizations built into Voucher-Based Addressing.
      </t>

      <section anchor="optimizations-dad">
        <name>Duplicate Address Detection Caching</name>
        <t>
          The SLAAC DAD process is optimized to reduce the burden of regenerating another VBA from scratch.
          See <xref target="behavioral-dad"/> for how this optimization functions as part of the core VBA
          specification.
        </t>
      </section>

      <section anchor="optimizations-lovma">
        <name>Preemptive Notifications on the LOVMA</name>
        <t>
        </t>
      </section>

      <section anchor="optimizations-kdfs-et-al">
        <name>Key Derivation Function Parameters</name>
        <t>
        </t>
      </section>

      <section anchor="optimizations-summaries">
        <name>Voucher Summary Options</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Mechanisms</name>
      <t>
      </t>
    </section>
    
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on various subjects related to the security of Voucher-Based Addresses.
        It also serves to clarify certain VBA processes or tangential protocol-related topics that may not have
        had adequate exploration in the rest of this document.
      </t>

      <section anchor="security-solutions">
        <name>How VBAs Balance Privacy &amp; Security</name>
        <t>
        </t>

        <section anchor="security-solutions-proof">
          <name>Proof of Address Ownership</name>
          <t>
          </t>
        </section>

        <section anchor="security-solutions-privacy">
          <name>Privacy-Focused Addresses</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="security-binding">
        <!-- From SEND:
            SEND does not compensate for an unsecured link layer.  For instance,
            there is no assurance that payload packets actually come from the
            same peer against which the NDP was run.
            Likewise, VBAs rely on the principle that link-lyer addresses MUST be unique on the same broadcast medium.
            VBAs offer great protection for unsecured L2 setups, but link-layer security would help to remediate further concerns.
        -->
        <name>Privacy of Link-Layer Bindings</name>
        <t>
        </t>
        <t>
          The Appendix of this document contains a detailed statistical evaluation of address randomness;
          see <xref target="appendix-randomness"/>.
        </t>
      </section>

      <section anchor="security-usurp">
        <name>Hijacking Link Vouchers</name>
        <t>
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
        </t>

        <section anchor="security-dos-dad">
          <name>Duplicate Address Detection</name>
          <!-- This spec leans on other DAD protection mechanisms. -->
          <t>
            The computational cost of generating VBAs can be abused by a malicious threat actor using DAD mechanisms.
          </t>
        </section>

        <section anchor="security-dos-grand">
          <name>Gratuitous Neighbor Discovery</name>
          <!-- RFC 9131 considerations. -->
          <t>
          </t>
        </section>
      </section>

      <section anchor="security-static">
        <name>Static Addressing</name>
        <t>
        </t>
      </section>

      <section anchor="security-collisions">
        <name>Hash Collisions</name>
        <t>
        </t>
      </section>

      <section anchor="security-fairness">
        <name>Computational Fairness</name>
        <t>
        </t>
      </section>

      <section anchor="security-pki">
        <name>Certifying Link Vouchers</name>
        <t>
        </t>
      </section>

      <section anchor="security-anycast">
        <name>Anycast Addresses</name>
        <t>
          Anycast addresses are allocated from the unicast address space and are thus indistinguishable to
          nodes establishing connections to them. NDP exchanges with these hosts may therefore respond with
          varying Target Link-Layer Address options and cause VBA verification to be unreliable.
          For this reason, it is NOT RECOMMENDED to utilize anycast addresses for on-link prefixes within
          VBA-enabled networks, because the ownership of the address cannot be bound to a particular
          link-layer identifier.
        </t>
        <t>
          The IPv6 Addressing Architecture RFC (<xref target="RFC4291"/>) outlines a Required Anycast Address
          in Section 2.6.1. VBA-enabled links SHOULD maintain compatibility with this requirement by disabling
          verification for on-link subnet anycast addresses. For example, a host using SLAAC to generate an
          address in the subnet 2001:db8:700::/64 SHOULD disable VBA expectations and verifications for the
          address 2001:db8:700::. Because VBA protections must be disabled for this target host, implementations
          SHOULD avoid using the subnet Required Anycast Address altogether.
        </t>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        This document defines two new Neighbor Discovery Protocol option types and one new link-local multicast
        address.
      </t>
      <t>
        See <xref target="lovma"/> for information about the Local On-link Voucher Multicast Address subscribed
        to by VBA-enabled network interfaces.
      </t>
      <t>
        Assigned in the "Link-Local Scope Multicast Addresses" subregistry of the "IPv6 Multicast Address Space
        Registry":
      </t>
      <t>
        Address(es): FF02::ABBA<br />
        Description: Local On-link Voucher Multicast Address<br />
        Reference: draft-puhl-6man-ndp-vba-00
      </t>
      <t>
        Two new Neighbor Discovery Protocol options are defined in this document and must have new Option Type
        values assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet Control
        Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Link Voucher option, described in <xref target="addenda-voucher"/>.</li>
        <li>The Voucher Summary option, described in <xref target="addenda-summary"/>.</li>
      </ul>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6105.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6104.xml"/>
        <!-- Default KDF Definitions -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8018.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9106.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7914.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4429.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7527.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9131.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.768.xml"/>
      </references>
      <!-- <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
          </front>
        </reference>       
      </references> -->
    </references>
    
    <section anchor="appendix-a">
      <name>Appendix A</name>
      <t></t>
    </section>

    <section anchor="appendix-randomness">
      <name>Validating Address Randomness</name>
      <t>
        The following sections evaluate the statistical randomness of generated VBAs on the basis of a few
        noted conditions. All results were acquired through use of the Dieharder suite of PRNG tests
        <!-- ref -->.
      </t>
      <t>
        Each test procedurally selects starting values and iterates the "PBKDF2 with SHA-256" KDF with a static
        multiplier of 256. The 'variable' condition will then be mutated pseudo-randomly each time all 2^16 possible
        iterations counts have been calculated with the KDF.
      </t>
      <t>
        Each test simulates 2^16 variations, for a total of 2^32 outputs (2^16 variations * 2^16 iterations per
        variation). VBA address generation procedures calculating these inputs write to a test file that records the
        address SUFFIXES as 64-bit decimal integers. That test file is then ultimately fed to Dieharder to run PRNG
        tests and thus generate these results.
      </t>

      <section>
        <name>Variable MAC, Fixed Seed, Fixed Subnet (VFF)</name>
        <t>
          Per every set of 2^16 iterations counts, the input link-layer address (MAC in this case) is set to a new
          pseudo-random value. This test shows the random distribution of VBAs on a single subnet with an unchanging
          Link Voucher seed value, among neighbors with unique MAC addresses.
        </t>
        <t>
          This test shows the randomness of address derivations between on-link neighbors.
        </t>
        <t>
          Fixed LV Seed Value: 0x5DD55190_0FA2A986_D3DAB5D2_94B97B63<br />
          Fixed Subnet Prefix: 2001:DB8:C001:5EED
        </t>
        <!-- TODO: Data -->
      </section>

      <section>
        <name>Fixed MAC, Variable Seed, Fixed Subnet (FVF)</name>
        <t>
          Per every set of 2^16 iterations counts, the input Link Voucher Seed is set to a new pseudo-random value.
          This test shows the random distribution of VBAs from a single node on a single subnet with a mutating seed.
        </t>
        <t>
          This test shows the randomness of address derivations between seeds for the same node on the same subnet.
        </t>
        <t>
          Fixed MAC address: FF-1B-83-8B-BC-C0<br />
          Fixed Subnet Prefix: FE80::
        </t>
        <!-- TODO: Data -->
      </section>

      <section>
        <name>Fixed MAC, Fixed Seed, Variable Subnet (FFV)</name>
        <t>
          Per every set of 2^16 iterations counts, the input subnet PREFIX is mutated to a new pseudo-random value.
          This test shows the random distribution of VBAs from a single node on multiple varying subnet prefixes, with
          a fixed seed value.
        </t>
        <t>
          This test shows the randomness of address derivations for the same node on different subnets, using the same
          Link Voucher seed.
        </t>
        <t>
          Fixed MAC address: 6A-1E-56-45-E6-BA<br />
          Fixed LV Seed Value: 0x61E1B40E_3DB48225_5A03DCB5_33068708
        </t>
        <!-- TODO: Data -->
      </section>
    </section>
 </back>
</rfc>
