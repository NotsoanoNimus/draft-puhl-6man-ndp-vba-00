<?xml version="1.0" encoding="utf-8"?>
<!-- 
     draft-rfcxml-general-template-standard-00
  
     This template includes examples of the most commonly used features of RFCXML with comments 
     explaining how to customise them. This template can be quickly turned into an I-D by editing 
     the examples provided. Look for [REPLACE], [REPLACE/DELETE], [CHECK] and edit accordingly.
     Note - 'DELETE' means delete the element or attribute, not just the contents.
     
     Documentation is at https://authors.ietf.org/en/templates-and-schemas
-->
<?xml-model href="rfc7991bis.rnc"?>  <!-- Required for schema validation and schema-aware editing -->

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
  <!ENTITY times  "&#215;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndp-vba-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndp-vba">IPv6 Voucher-Based Addressing for Neighbor Discovery Address Resolution</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndp-vba-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>vba</keyword>
    <keyword>spoofing</keyword>
    <keyword>privacy</keyword>
    <abstract>
      <t>
        This document specifies an extensible IPv6 address generation and verification methodology for local
        networks. Individual link-layer identifiers are bound to sets of deterministic output addresses, which
        maintain user privacy regardless of link-layer identifier stability. Link Vouchers distributed by Router
        Advertisements form a shared consensus between neighbors of the parameters used in the SLAAC address
        generation process. Cryptographic key derivation functions are used to generate pseudo-random addresses and
        to intentionally stretch address computation times. Host parameters can be used to derive any number of both stable
        and ephemeral, privacy-focused addresses for each on-link prefix and at the link-local scope. Neighbor Discovery
        Address Resolution implementations can then verify the link-layer-address-to-IP bindings to prevent on-path attacks
        in local networks.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        An on-path attack, historically more well-known as a Man-in-the-Middle (MITM) attack, occurs when a malicious
        network node inserts itself into a communication between two other nodes -- often transparently -- in order to read and/or
        modify the ongoing communication. This type of weakness is a critical point of concern for network administrators, since the
        high feasibility of on-path attacks in local networks, where nodes are least likely to encrypt communications,
        compromises confidentiality, integrity, and availability.
      </t>
      <t>
        The Neighbor Discovery Protocol (NDP) <xref target="RFC4861"/> is self-aware of its capability for misuse in on-path (or redirect) attacks.
        Section 11 of the RFC provides a brief threat analysis followed by pointers to both SEND <xref target="RFC3971"/> and Security
        Associations with native IPSec (Section 4 of <xref target="RFC4301"/>) as solutions for its weaknesses. Though SEND has
        long been considered the canonical solution for its namesake (securing ND), it and its complementary Cryptographically
        Generated Addresses <xref target="RFC3972"/> have struggled to achieve widespread usage due to their deployment complexities.
      </t>
      <t>
        Meanwhile, war has raged about the best way to generate a balanced set of IP addresses per-node, for different use-cases, that
        can preserve user privacy. <xref target="RFC8981"/> discusses the generation of both stable and temporary SLAAC addresses. It
        slightly augments the generation process of opaque IIDs <xref target="RFC7217"/> and provides insights about more recent address
        generation methodologies. <xref target="RFC7721"/> and
        <xref target="RFC8064"/> express deep concerns about using link-layer identifiers in the address generation process, citing network
        activity correlation, location tracking, address scanning, and targeted exploitation as significant problems.
      </t>
      <t>
        NDP Address Resolution (Section 7.2 of <xref target="RFC4861"/>) establishes a process for discovering the
        link-layer identifier (LLID) of a neighbor's IP address. But this process faithfully relies on some nebulous neighbor owning the target
        IP to respond with its own LLID (and not, e.g., a malicious host to respond with a redirected LLID).
        If the target IP address is already being softly correlated with a LLID, it is then sensible to tightly bind the two together; 
        IP addresses should be provably derived from a LLID.
        In light of address privacy warfare, this binding needs to be done in a way where temporary and stable identifiers can
        coexist and not suffer the aforementioned privacy concerns.
      </t>
      <t>
        Voucher-Based Addressing offers local IPv6 networks (1) a common procedure for binding LLIDs to IP addresses,
        (2) rotatable and private IP address generation, and (3) prevention of subversive on-path attacks.
        Address bindings use mutual key derivation functions to map public input components to deterministic output IP addresses.
        These bindings can be subsequently verified by neighboring nodes who seek to assert a target's address "ownership".
        All verifications are decentralized and do not require public-key infrastructure; only shared consensus on a distributed,
        pseudo-random value used to seed the address generation procedure. Despite its determinism, the address generation
        process creates rotatable IP addresses which appear statistically random to off-link devices, who are by design
        unaware of all input parameters associated with the address.
      </t>
      <t>
        This document thus represents a cross-application of cryptographic
        key-stretching techniques to LLID bindings in generating random IPv6 addresses. The result
        is a high-impact, low-complexity, optional feature for the NDP Address Resolution process,
        with minimal changes to NDP options, formats, or behaviors. It is proposed as an alternative to
        SEND <xref target="RFC3971"/>, CGAs <xref target="RFC3972"/>, and opaque IIDs
        <xref target="RFC7217"/> in traditional LANs using "reactive" NDP, and it does not intend to obsolete any other document.
      </t>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>

      <section anchor="intro-background">
        <name>Background</name>
        <t>
          This document assumes the reader's very basic familiarity with the following specifications. These are merely OPTIONAL
          in order to understand the concepts proposed in this document, but will provide plenty of helpful context.
        </t>
        <ul spacing="compact">
          <li>IP Version 6 Addressing Architecture <xref target="RFC4291"/>.</li>
          <li>Neighbor Discovery for IP Version 6 <xref target="RFC4861"/>.</li>
          <li>IPv6 Stateless Address Autoconfiguration <xref target="RFC4862"/>.</li>
          <li>IPv6 Neighbor Discovery (ND) Trust Models and Threats <xref target="RFC3756"/>.</li>
          <li>SEcure Neighbor Discovery (SEND) <xref target="RFC3971"/>.</li>
          <li>Cryptographically Generated Addresses (CGA) <xref target="RFC3972"/>.</li>
          <li>Semantically Opaque Interface Identifiers <xref target="RFC7217"/>.</li>
          <li>Temporary Address Extensions for Stateless Address Autoconfiguration in IPv6 <xref target="RFC8981"/>.</li>
          <li>Recommendation on Stable IPv6 Interface Identifiers <xref target="RFC8064"/>.</li>
          <li>PKCS #5: Password-Based Cryptography Specification Version 2.1 <xref target="RFC8018"/> (primarily Sections 3 and 4).</li>
        </ul>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <t>
        A glossary of terms related to this document, but not necessarily defined herein, is specified in this section. Items
        appearing here may or may not be acronymized even in their first appearances in future sections (but never in section
        headers), so knowledge of them is assumed henceforth.
      </t>
      <t>
        To keep this section reasonable, please see Section 2.1 of <xref target="RFC4861"/> for defitions of the following
        terms used equivalently in this document: neighbor, node, interface, link, address, router, host, on-link, off-link,
        IP, ICMP, packet, and target. It is very important to understand these terms before reading this document.
      </t>
      <dl newline="true">
        <dt>ND (sometimes NDP)</dt>
        <dd>Neighbor Discovery (Protocol) <xref target="RFC4861"/>.</dd>

        <dt>SEND</dt>
        <dd>SEcure Neighbor Discovery <xref target="RFC3971"/>.</dd>

        <dt>CGA</dt>
        <dd>Cryptographically Generated Address <xref target="RFC3972"/>.</dd>

        <dt>NDAR (sometimes AR)</dt>
        <dd>The Neighbor Discovery Address Resolution process; see Section 7.2 of <xref target="RFC4861"/>.</dd>

        <dt>NC</dt>
        <dd>Neighbor Cache, as specified in Section 5.1 of <xref target="RFC4861"/>.</dd>

        <dt>RS, RA, NS, and NA</dt>
        <dd>A collection of abbreviations from NDP <xref target="RFC4861"/>.
          Respectively: Router Solicitation, Router Advertisement, Neighbor Soliciation, Neighbor Advertisement.</dd>

        <dt>NUD</dt>
        <dd>Neighbor Unreachability Detection (Section 7.3 of <xref target="RFC4861"/>).</dd>

        <dt>LLADDR or LLID</dt>
        <dd>A shorthand representation for the term "Link Layer Address" or "Link Layer Identifier".
          Both terms are synonymous and describe any Individual link-layer identifier for a network interface.</dd>

        <dt>IID</dt>
        <dd>Interface Identifier. The unique identifier of an interface on a network. See Section 2.5.1 of <xref target="RFC4291"/>.</dd>

        <dt>SLLAO</dt>
        <dd>Source Link-Layer Address Option. An ND option indicating the LLADDR of the packet sender <xref target="RFC4861"/>.</dd>

        <dt>TLLAO</dt>
        <dd>Target Link-Layer Address Option. An ND option indicating the LLADDR of the NDAR target <xref target="RFC4861"/>.</dd>

        <dt>DAD</dt>
        <dd>Duplicate Address Detection (Section 5.4 of <xref target="RFC4862"/>).</dd>
        
        <dt>SLAAC</dt>
        <dd>Stateless Address Autoconfiguration <xref target="RFC4862"/>.</dd>

        <dt>PKI</dt>
        <dd>Public Key Infrastructure. A system that uses asymmetric encryption to verify user identities and secure network
          communications. Often in reference to some larger specification such as X.509 PKI.</dd>

        <dt>VBA</dt>
        <dd>
          <t>Could mean one of two things depending on context:</t>
          <ul>
            <li>Voucher-Based Addressing (such as "the VBA-enabled subnet" or "VBA mandates this").
              A reference to this document and its contents.</li>
            <li>Voucher-Based Address (such as "a VBA" or "using VBAs").
              An IPv6 address generated by a mixture of Link Voucher details, network interface details, and subnet details.</li>
          </ul>
        </dd>

        <dt>LV</dt> 
        <dd>ND Link Voucher option. A data payload intended to be distributed by a responsible node on-link. Details are statefully
          maintained on host network interfaces and used in both generating and verifying VBAs.</dd>

        <dt>VS</dt>
        <dd>ND Voucher Summary option. Used to hint to receivers which LV identifier is being used by the sending host.</dd>

        <dt>LOVMA</dt>
        <dd>Local On-link Voucher Multicast Address. A multicast group used by VBA-enabled hosts to get gratuitous information from
          the current Voucher Bearer or from other VBA-enabled neighbors.</dd>

        <dt>VB</dt>
        <dd>Voucher Bearer. The on-link node solely responsible for dissemination of the LV and authorized by any potential link
          guarding to transmit Router Advertisements or Redirects with an LV attached.</dd>

        <dt>VSR</dt>
        <dd>Voucher Status Report. A type of data payload sent by VBA-enabled nodes to the LOVMA. Shares information about the node's
          VBA preferences. Mainly used in optimizations and is an optional protocol feature.</dd>

        <dt>VCI</dt>
        <dd>Voucher Capability Indication. A type of data payload sent by candidate VBs wishing to indicate their candidacy as a
          future VB for the link.</dd>

        <dt>VHA</dt>
        <dd>Voucher Handoff Advertisement. A type of data payload sent by the current VB to the LOVMA, signing off on an election
          process for a new VB (and thus LV) on-link.</dd>

        <dt>IEM</dt>
        <dd>Interface Enforcement Mode. The operating mode of the VBA-enabled network interface controlling interface address
          generation and verification behaviors with regard to this specification.</dd>

        <dt>LL2IP</dt>
        <dd>Used to shorten the phrase "link-layer-address-to-IP" when discussing address bindings.</dd>

        <dt>Binding</dt>
        <dd>Used primarily to describe a coupling between two types of addresses. In the case of this document, it often references
          LL2IP bindings, where Link-Layer Identifiers are 'bound' to one or more IP addresses.</dd>

        <dt>KDF</dt>
        <dd>Key Derivation Function, as defined in Section 3 of <xref target="RFC8018"/>.</dd>

        <dt>Salt</dt>
        <dd>An extra random value used in computing a KDF which makes it impossible for attackers to precompute output values.
          See Section 4.1 of <xref target="RFC8018"/> for more information.</dd>

        <dt>IC</dt>
        <dd>Iterations Count. For the sake of clarity, this term is often not abbreviated in this document. Defined as an integer
          value representing the amount of times a KDF is iterated to produce a final output value. See Section 4.2 of
          <xref target="RFC8018"/> for more information.</dd>

        <dt>Hextet</dt>
        <dd>A 16-bit aggregation; data that is 16 bits in size. Can also be called a 'chomp'.</dd>

        <dt>RA-Guard</dt>
        <dd>Router Advertisement Guard, as specified in <xref target="RFC6105"/>.</dd>
      </dl>
      <t>
        SPECIAL NOTE: Any use of the terms 'IP', 'DHCP', or 'ICMP' in the following sections of this document are synonymous with
        'IPv6', 'DHCPv6', and 'ICMPv6', respectively. When referencing the IPv4 versions of these protocols, it will be explicitly noted.
      </t>
    </section>

    <section anchor="summary">
      <name>Voucher-Based Addressing</name>
      <t>
        This section outlines the design goals of Voucher-Based Addressing. It reviews the primary mechanisms driving
        the specification and their design considerations. It discusses related requirements for network interfaces
        on-link. Lastly, it includes concrete processes and procedures used by VBA-enabled network nodes to verify
        address ownership and to simultaneously create private, pseudo-random network addresses.
      </t>

      <section anchor="summary-overview">
        <name>Protocol Design</name>
        <t>
          A Voucher-Based Address is defined as any unicast IP address derived from on-link voucher information.
          The address derivation process is underpinned by a static, well-known procedure parameterized by a mixture
          of Link Voucher details and public node information. This same derivation process is used by other on-link
          nodes to independently verify the link-layer binding of the address during the ND Address Resolution process.
        </t>
        <t>
          This section will outline fundamental design goals aspiring to synergistically balance privacy and local
          network security. It will also discuss the mechanisms by which Voucher-Based Addressing realizes these
          goals.
        </t>

        <section anchor="summary-overview-goals">
          <name>Goals</name>
          <t>
            From a high level, VBAs attempt to balance network-layer security with privacy without too much additional
            complexity that would render the protocol unemployable.
          </t>
          <t>
            Many existing proposals have repeated varying iterations and mixtures of two generic mechanisms (and for
            good reasons):
          </t>
          <ul>
            <li>Public-Key Cryptography. Used mostly to validate a device is truly the registered or otherwise authenticated
              owner of the neighbor address (and LLADDR) through various strategies.</li>
            <li>Centralized Registration. Usually used to establish an on-link authority which can directly validate or vouch
              for the bindings returned in an NDAR exchange.</li>
          </ul>
          <t>
            Voucher-Based Addressing applies alternative -- and considerably weak -- methods to achieve the same goals. 
          </t>
          <ul>
            <li></li>
          </ul>
        </section>

        <section anchor="summary-overview-binding">
          <name>Link-Layer Bindings</name>
          <t>
            VBAs are generated by using the link-layer identifier of the underlying, assigned interface as an input.
            They operate on the assumption that link-layer identifiers MUST be unique on the same broadcast domain at
            any moment in time in order for higher-level protocols to successfully operate. Thus, VBAs are directly
            derived from this on-link 'identity'.
          </t>
          <t>
            The derivation process necessarily binds a generated IP address to a link-layer identifier. During the NDP
            Address Resolution process, the goal is to associate a Target Address with a corresponding link-layer address
            to which frames can be forwarded at the link layer (see Section 7.2 of <xref target="RFC4861"/>).
          </t>
          <t>
            Because deterministic VBA generation directly depends on the value of the link-layer identifier of the
            node, purported network and target link-layer addresses cannot be falsified in NDP address resolutions. Address
            verification is a process parameterized by (1) data which identifies the node's network interface, and (2)
            data which lies OUTSIDE of the generating node's administration. Such 'outside' information is listed in the
            Link Voucher details agreed upon by all neighbors.
          </t>
          <t>
            Due to this principle of link-layer address binding in generating VBAs, it is impossible to report an association
            of an IP address to a link-layer address that cannot be bound to it. This means NDP Address Resolution exchanges
            are safe from issues of impersonation. A host wishing to contact a particular IP address can no longer be subversively
            redirected to a different receiver at a lower level of the network stack.
          </t>
        </section>

        <section anchor="summary-overview-cryptography">
          <name>Key Derivation Functions &amp; Address Privacy</name>
          <t>
            Link-layer bindings using a simple embedding or hashing scheme should suffice if the goals of VBAs stopped at
            address ownership. For example, modified EUI-64 interface identifiers are formed by a long-established address
            derivation methodology which uses the link-layer identifier of an underlying interface; see Section 2.5.1 of
            <xref target="RFC4291"/>. However, a design goal of this document is to contemporaneously establish a
            privacy-focused address generation procedure that will obscure the link-layer identifier and create rotatable
            addresses.
          </t>
          <t>
            For this requirement, VBAs employ cryptographic hashing during the address generation process to create a
            pseudo-random output address. This address, while still relatively fixed and lacking dynamic derivation,
            does not immediately allow outside trackers to know the link-layer identifier of the node. Using cryptographic
            hashing and key derivation techniques also ensures that any link-layer identifier of arbitrary length could be
            reliably bound to an address suffix that is fixed at 64 bits in length.
          </t>
          <t>
            Hashing a link-layer identifier and producing an output will only create a one-to-one binding, but many IP
            address generation schemes already offer ways to derive MANY privacy-focused addresses from the link-layer
            identifier (e.g., Section 5 and Appendix A.3 of <xref target="RFC7217"/>). These addresses are usually NOT reversible,
            by design, unless reversing nodes are aware of all input parameters for the underpinning PRF. This is intended
            to preserve the privacy of the address.
          </t>
          <t>
            But VBAs strike a careful balance of (1) keeping off-link nodes unaware of local Link Voucher information used in
            private address derivation, and (2) ensuring on-link nodes ARE aware of all parameters used to generate an address.
            Off-link nodes will be unaware of the VBA's bound link-layer identifier -- because they cannot receive NDP messages
            nor can they determine it from the address itself -- and VBAs will always appear as random as a consequence of
            using the outputs of deterministic hash functions.
          </t>
          <t>
            More to the point, simple hashing is elevated to using key derivation techniques, which allow a set of one-to-many
            link-layer identifier to IP address bindings. This is because KDFs often accept an input iterations count that
            specifies how many times the PRF or hashing function should be iterated <xref target="RFC8018"/>. Iterations counts
            can then be embedded in resultant IP addresses, such that the following three components are an inherent value
            exchanged in any NDP Address Resolution communication:
          </t>
          <ul spacing="compact">
            <li>The Target Link Layer Address.</li>
            <li>A portion of the KDF output (using the other on-link input parameters).</li>
            <li>The Iterations Count used to compute the address.</li>
          </ul>
          <t>
            Addresses using this generation process therefore enforce that all three items are each the same input values -- along
            with on-link Link Voucher details -- to produce the same output address. Each increment or decrement of the embedded
            Iterations Count value produces an entirely new, seemingly random address. Nodes falsifying any of the input values
            will be rejected by enforcing neighbors seeking to resolve and verify link-layer addresses for certain target IP addresses.
          </t>
          <t>
            The VBA verification requirement in this document simply repeats the address generation procedure, using
            inputs known to the verifying node about the target node. As stated in the previous section, some of these
            parameters are indeed under the control of the target node; others are distributed on the network in a Link
            Voucher by a trusted authority.
          </t>
        </section>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface-level Processes &amp; Configurations</name>
        <t>
          This section outlines different interface-level configurations and options which MUST be available in
          any implementation of this specification. It also discusses topics specific to caching Link Voucher
          information on local interfaces and outlines some specific details of the process. It is intended to
          explicitly dictate receiving-interface perspectives on different mechanisms presented in this document.
        </t>
        <t>
          Link Vouchers are defined in <xref target="addenda-voucher"/>.
        </t>

        <section anchor="summary-interfaces-mode">
          <name>Interface Enforcement Modes</name>
          <t>
            Per-interface modes (IEMs) are able to granularly dictate the local NDP behaviors related to VBAs.
            This flexibility in per-interface behavior grants VBAs more transition and adoption capabilities.
            A tiny state machine diagram would depict all of these states as being transitionable to any of
            the others.
          </t>
          <t>
            Implementations MUST allow nodes to independently opt into any one of the following IEMs for EACH
            of their local interfaces. The IEM state MAY also be specified on each interface statically, in which
            case all other automatic IEM state transitions MUST NOT apply.
          </t>
          <dl newline="true">
            <dt><tt>AAD - Address Awareness Disabled</tt></dt>
            <dd>The VBA-aware interface MUST NOT generate or verify any addresses, regardless of the incoming
              packets. It MUST NOT participate in any LOVMA traffic exchanges. In this mode, VBAs are ignored.
              This mode SHALL always be used by VBA-enabled interfaces on links without an established LV.</dd>

            <dt><tt>AGO - Address Generation Only</tt></dt>
            <dd>The address generation procedure is followed for unicast addresses. The NDP Address Resolution
              process MUST NOT be supplemented by VBA optimization or verification procedures.</dd>

            <dt><tt>AGV - Address Generation &amp; Verification</tt></dt>
            <dd>The address generation and verification procedures are followed as per this document. Address
              Resolution is REQUIRED to fail if the advertised target link-layer address cannot be successfully
              bound to the target IP address. This SHOULD be the default Enforcement Mode for interfaces.</dd>

            <dt><tt>AGVL - Address Generation &amp; Verification with Levels</tt></dt>
            <dd>Both address generation and verification procedures are employed, but verification failures MUST
              NOT be strictly enforced during ND Address Resolution. Neighbors whose VBA(s) successfully verify
              MUST be marked or indicated locally as "Secured". A neighbor which fails to verify
              MUST be indicated as "Unsecured" and given less trust or authority than "Secured" responses.</dd>
          </dl>
          <t>
            For AGVL mode, the Secured and Unsecured distinction is adopted from Section 8 of SEND <xref target="RFC3971"/>.
            If an AGVL interface receives multiple Neighbor Advertisement responses, it MUST strongly prefer Secured
            NAs over Unsecured NAs to determine which link-layer address is legitimate during the Address Resolution
            process. If multiple Secured responses are received, each with different link-layer addresses, then there
            is a VBA collision and the behavior of the interface is undefined. In this rare case, the pool of Secured
            responses are equally valid VBAs, so it is left to the implementation to decide the correct course of action.
          </t>
          <t>
            Implementations MAY opt to treat nodes with either the Secured or Unsecured distinctions with their own
            custom behavior(s) based on the operating environment in which VBAs are deployed.
          </t>
        </section>

        <section anchor="summary-interfaces-state">
          <name>Preserving Voucher-Related State</name>
          <t>
            VBA-enabled interfaces for all nodes, regardless of their selected Interface Enforcement Modes, are
            REQUIRED to store the full state of the most current, validated Link Voucher. If a Link Voucher is not
            available on-link, then no stored LV state is required and the node MUST enter the Address Awareness
            Disabled state (see <xref target="summary-interfaces-mode"/>). If a LV subsequently becomes available,
            the node MAY choose to enter a different state or IEM based on the implementation.
          </t>
          <t>
            Link Voucher details MAY also be set statically on an interface. In such cases, the static information
            MUST contain at least a VoucherID, Voucher Seed, and Algorithm Type specification. Any interface with
            static details configured MUST ignore any received LVs on-link. Static LVs MUST always be considered in
            an 'active' state and MUST NOT expire.
          </t>
        </section>

        <section anchor="summary-interfaces-acquisitions">
          <name>Link Voucher Acquisitions</name>
          <t>
            Interfaces connecting to the network for the first time are REQUIRED to accept and cache the FIRST
            LV received on-link. If the interface intends to maintain responsibility for the LV as a VB, it MUST
            follow the process outlined in <xref target="addenda-voucher-senders"/>.
          </t>
          <t>
            If an active LV expires -- i.e., no updated LV has been received on-link within the amount of seconds
            specified in the 'Expiration' field of the most recent LV -- then the interface MUST again accept the
            first received LV. The Expiration time can also elapse while a non-VB host interface is disconnected
            from the link, and so that interface MUST follow the same process regardless of how LV expiration occurred.
          </t>
          <t>
            Because Link Voucher distribution to interfaces uses a 'first-come-first-serve' trust methodology,
            it is essential for adversarial networks, especially public networks, to implement some form of
            protection against rogue LVs at a lower or intermediate level. See <xref target="bearers-vigilance"/>
            for more information.
          </t>
          <t>
            In the cases where these protective mechanisms are not available, administrators MAY choose to set LV
            information on each node statically. Administrators in this sitation SHOULD also choose to employ
            some form of intrusion detection to better mitigate rogue LVs from appearing and affecting the
            local network.
          </t>
        </section>

        <section anchor="summary-interfaces-transitions">
          <name>Host Recipients &amp; Link Voucher Transitions</name>
          <t>
            The node responsible for the Link Voucher MAY at any time issue a handoff of that responsibility to
            another node (see <xref target="lovma-packets-vha"/>). During the period of transition between the
            previous Link Voucher and the upcoming one, VBA-enabled nodes which are subscribed to the LOVMA channel
            SHOULD receive VHA multicast packets specifying the new responsible node and LV. These LOVMA-connected
            nodes are strongly RECOMMENDED to allow both LVs to be cached so that VBAs generated using either LV
            are immediately valid. They are also strongly RECOMMENDED to begin address generation in anticipation
            of the upcoming LV becoming active.
          </t>
          <figure>
            <name>Link Voucher Transitions</name>
            <artwork type="ascii-art" name="voucherTransitions.txt">
              <![CDATA[
  ==========================================> Time
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  ...   LV_A Validity        |
  ~~~|~~~~~|~~~~~X~~~~~~~~~~~Z
     |     |     +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     |     |     |      LV_B Validity       ...
     |     |     +~~~~~|~~~~~|~~~~~|~~~~~|~~~~~~~
  |==|=====|=====|=====|=====|=====|=====|===> Time
  |  O     O     O     O     O     O     O    ...
  |              |           |
  [ LV_A Active  [ Window    [ LV_B Active
 (1)            (2)         (3)

** 'X' marks the final advertisement for LV_A.
    Each 'O' at 'X' until and including 'Z' will
    include a VHA from the VB of LV_A.
** 'Z' marks the time at [X + LV_A.Expiration].
** 'O' indicates the advertisement of a LV on-link.

  Moments:
    1   = Link Voucher A is active for all nodes.
    2   = VHA. LOVMA-subscribed nodes become aware
           of a transition window. Both LV_A and
           LV_B are considered active LVs.
    3   = LV_A expires. Link Voucher B is active for
           neighbors and the transition completes.
              ]]>
            </artwork>
          </figure>
          <t>
            If another VHA appears indicating a third LV as appointed for election, receivers MUST ignore the VHA
            until one of the two LVs from the original VHA has expired. This prevents VHA abuse which flags several
            active LVs on the same link as being valid, causing an 'address storm' that drains available computing
            resources from network nodes.
          </t>
          <t>
            Once the transition window ends, the amount of valid LVs will return from 2 to 1. The transition window
            ends when the original responsible node fails to refresh its LV within its LV-specified Expiration time
            (thus purposefully letting its LV expire).
          </t>
          <t>
            For nodes that do NOT receive or regard LOVMA VHA datagrams, the 'transition' process becomes more
            akin to a 'hard handoff'. Due to LV requirements, these nodes will not trust the new LV until the previous
            LV has expired, at which time any LV becomes acceptable. For this reason, any VBAs preemptively generated
            with the upcoming LV will not be successfully verified by neighbors unaware of the handoff, until the
            transition window has ended and the new LV becomes primary. All implementations SHOULD therefore parse VHAs
            to secure the handoff process, preventing rogue LVs from partially hijacking the VB role on the link.
          </t>
          <t>
            When a handoff completes, the Link Voucher has changed. Any time the stored VoucherID of the active
            LV transitions to another, the Neighbor Cache MUST be cleared and all VBAs, whether generated or verified,
            MUST be derived from the parameters of the newly active LV ONLY. This is true even in the case of a hard
            handoff.
          </t>
          <t>
            The handoff and transition window provides an opportunity for optimization. If neighbors are aware of the
            upcoming voucher, they MAY opt to preemptively generate their new VBAs in anticipation of the completed LV
            transition. Implementations MAY also choose to utilize this transition window for pre-caching the computed
            addresses of cached neighbors who have a Preferred Iterations Count specified in LOVMA VSR packets.
          </t>
          <t>
            Finally, if the current node responsible for the LV either disconnects from the network or lets its LV
            expire without an election process, then the link becomes open and allows other nodes to fill in the LV
            void with their own. If no other VB assumes responsibility on the link while the primary VB is away or not
            transmitting updated LVs, all VBA-enabled nodes MUST retain the most recent valid LV for the purposes of
            address generation and verification.
          </t>
        </section>
      </section>

      <section anchor="summary-generate">
        <name>Address Generation</name>
        <t>
          This section discusses the generation procedure and composition of VBAs.
        </t>
        <figure>
          <name>The Voucher-Based Address Generation Procedure</name>
          <artwork type="ascii-art" name="vbaGeneration.txt">
            <![CDATA[
Address composition:
          PREFIX    //      SUFFIX (64 bits)
    +------ ~ ------+-------------+---------------------+
    | 64-bit prefix | Z (16 bits) |     H (48 bits)     |
    +------ ~ ------+-------------+---------------------+

  where:
    PREFIX is the 64-bit subnet prefix. If the subnet length is
              shorter than 64 bits, the rest of the 64-bit field
              MUST be initialized to a pseudo-random value.
    SUFFIX is the first 8 bytes from the result of a Key Derivation
              Function (KDF) 'K' iterated 'L' times. The leftmost
              hextet is replaced by 'Z'.

Formulas:
    H  =  K(L, Key, Salt)
          |---> K    = A KDF specified by the Link Voucher.
          |---> L    = A random, host-selected 'iterations count'.
          |---> Key  = The 128-bit Link Voucher seed value.
          `---> Salt = [LLID] || 'v' || 'b' || 'a' || [PREFIX]

    Z  =  ~(L ^ Key[0..1])

    SUFFIX = hextets{ Z, H[2..3], H[4..5], H[6..7] }
                            `--> (using 0-based indexing)
            ]]>
          </artwork>
        </figure>
        <t>
          The IID for all VBAs, called a SUFFIX, embeds two important details for verification:
        </t>
        <ul>
          <li>
            <t>
              A 16-bit 'Z' value, calculated as a bitwise complement of the XOR of the 'L' value and the first hextet
              of the LV seed. This calculation uses this XOR computation to ensure the same iterations count 'L' between
              different LV seeds will be unique and provide some resistance to tracking hosts between each varying LV
              seed. This is especially true if the host locally advertises a well-known or Preferred Iterations Count
              (<xref target="lovma-packets-vsr"/>).
            </t>
            <ul>
              <li>
                The 'L' value, also called 'iterations count' in this document, is an important value. This parameter
                controls how many times the KDF function is iterated to produce the resulting hash. Increasing this
                value increases both the work required to generate the VBA and the work required to find potential
                hash collisions.
              </li>
            </ul>
          </li>
          <li>
            48 bits from the resulting hash, or 'H' value, derived from the KDF after 'L' iterations. Implementations
            are REQUIRED to use the FIRST 8 bytes of the hash in formulating the SUFFIX value, replacing the first
            hextet with the 'Z' value as shown in the figure.
          </li>
        </ul>
        <t>
          The address generation algorithm is detailed procedurally as follows:
        </t>
        <ol>
          <li>A host connects to a VBA network and obtains Link Voucher details (<xref target="addenda-voucher"/>).</li>
          <li>The 'L' value is chosen based on (1) host preference, (2) intended difficulty, or (3) random selection.</li>
          <li>The Link Voucher details contain instructions for which KDF to use and which 128-bit seed value to use.</li>
          <li>
            <t>
              The KDF Salt is a variable-length CONCATENATION of a few different values, in the order specified
              below. 'Raw' values indicate binary values, NOT hexademical string notations of the values.
            </t>
            <ul spacing="compact">
              <li>
                The raw link-layer identifier of the network interface for which addresses are being generated.
                Note that since the Salt value is a variable-length string, this is NOT REQUIRED to be an IEEE 802 MAC
                address, but it MUST represent the link-layer address to which the IP address will be bound.
              </li>
              <li>The string "vba".</li>
              <li>The raw PREFIX (subnet prefix) value. This MUST match the prefix for which the VBA will be generated.</li>
            </ul>
          </li>
          <li>
            <t>
              The final address SUFFIX is computed:
            </t>
            <ul spacing="compact">
              <li>
                The first 16 bits are the bitwise complement of an XOR between the iterations count 'L' and the
                first hextet of the LV seed.
              </li>
              <li>
                The least significant 48 bits are 6 sequential bytes from the KDF hash, skipping the first two
                bytes (hextet) in the sequence.
              </li>
            </ul>
          </li>
        </ol>
        <t>
          See <xref target="appendix-code-generation"/> for sample code in the C programming language which
          might better demonstrate VBA address generation.
        </t>
      </section>

      <section anchor="summary-verify">
        <name>Address Verification</name>
        <t>
          This section provides a procedural overview of VBA address verification. Two important relative terms will
          need to be established for the sake of clarity:
        </t>
        <dl newline="true">
          <dt>Client Node</dt>
          <dd>The node resolving the link-layer address of a neighbor; sends the initial Neighbor Soliciation packet.</dd>
          <dt>Target Node</dt>
          <dd>The node supplying its target link-layer address in a responding Neighbor Advertisement.</dd>
        </dl>
        <t>
          VBA address verification MUST only performed during the Address Resolution phase of an NDP exchange, where
          enabled on the local interface. Verifying an address entails reconstructing the address generation procedure
          run by the Target Node and ensuring the produced address is equivalent to the one solicited by the Client Node.
        </t>
        <t>
          The Target Node address being resolved MAY be any unicast address, but MUST be within the address space of an
          on-link prefix.
        </t>
        <t>
          The following figure shows how VBA verification integrates into the NDP Address Resolution process. Node 'A' is
          the Client Node and node 'B' is the Target Node.
        </t>
        <figure>
          <name>The Voucher-Based Address Verification Procedure</name>
          <artwork type="ascii-art" name="vbaVerification.txt">
            <![CDATA[
 ,-- [advertise] <---. <======== (unicast NA)
 V       (2)         |
|A|{LV}             |B|{LV}{MAC}
 |   |               |      |
 +---+-> [solicit] --' <====|=== (solicited-node
 |   |      (1)             |      multicast NS)
 |   |                      |
 |   +---------+-------.    |
 |   |         |       |    |
 |   |  +~~~~~~V~~~~~~~|~~~~+~~~~~~~~~~~+
 `---+->| H := LV.K(   V    | [rebuild  |
 (3) |  |   L := Z'(B, LV), |  addr B]  |
     `--+-> LV.seed,   v----'           |
        |   makeSalt(MAC, prefix(B))    |
        | );                            |
        +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            |
            |      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            `----> | [prefix(B) || suffix(Z(L, LV), H)] == B |
                   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                        (4)  {????}
                              |  |
           DROP <-- false <---'  '---> true --> ACCEPT/CACHE
            ]]>
          </artwork>
        </figure>
        <t>
          The Link Voucher 'LV' MUST always be used from the state preserved on the verifying interface. Nodes
          SHALL NOT request the Link Vouchers of others for any reason. If the verification procedure fails due
          to an LV mismatch between nodes A and B, then there is most likely either (1) a synchronization problem
          or (2) an issue with multiple same-link LVs being distributed.
        </t>
        <t>
          In the above figure, the "Z'" (Z-prime) function returns the iterations count embedded in Host B's address.
          This function is the opposite of 'Z'; it uses an input address to determine 'L' rather than using
          an input 'L' to determine an output hextet. Despite the different inputs, the naming alludes to the
          opposite purposes for each function.
        </t>
        <dl newline="true">
          <dt><tt>Z(L, LV) = ~(L ^ LV.seed[0..1])</tt></dt>
          <dd>Returns a hextet to insert into a generated address. A bitwise complement of the result of an iterations
            count XOR'd with the first hextet of a Link Voucher seed value.</dd>
          <dt><tt>Z'(B, LV) = ~(B[8..9] ^ LV.seed[0..1])</tt></dt>
          <dd>Returns an iterations count derived from a full IP address. In this case, 'B[8..9]' is equal to
            the length and position of the embedded hextet calculated by the function 'Z' above.</dd>
        </dl>
        <t>
          <tt>Z'</tt> is necessarily computed for each VBA verification because the 'L' value is a required component
          to reconstruct the solicited address of the Target Node.
        </t>
        <t>
          See <xref target="appendix-code-verification"/> for sample code in the C programming language which
          might better demonstrate VBA address verification.
        </t>
      </section>

      <section anchor="behavioral">
        <name>Behavioral Neighbor Discovery Changes</name>
        <t>
          This section describes the requirements and implications of VBAs with regard to ordinary NDP. Simple
          amendments to NDP are necessary to secure NDAR. Any behavioral NDAR change not explicitly declared in
          this section falls back to the typical NDAR behavior <xref target="RFC4861"/>.
        </t>
        <t>
          NOTE: If a receiving interface uses either the AAD or the AGO IEM, then this section's behavioral changes
          MUST NOT apply to that interface or its NDP-related behaviors.
        </t>
        <t>
          This document updates the following NDP behaviors:
        </t>
        <ul>
          <li>
            <t>
              Since LLADDRs are bound to IPs and VBA collisions are highly unlikely, new LLADDRs on neighbors have an
              impossibly low chance of producing the same VBA. This unlikelihood means that any NAs using a cached
              Target Address not in the INCOMPLETE state MUST be ignored if an included TLLAO attempts to update the
              record to a different LLADDR (or change the NC entry to a different status).
            </t>
          </li>
          <li>
            <t>
              The value of a LLADDR from a NS should likewise never update for the same generated IP Source Address. So
              NS packets with an SLLAO attached MUST NOT update the state or values of any active NC entry.
            </t>
          </li>
          <li>
            <t>
              Any "urgent updates" about underlying details for the previous IP are unnecessary. The Override flag in NAs
              MUST NOT update the underlying LLADDR of an active NC entry. It also MUST NOT update the status of any NC entry.
            </t>
            <t>
              However, some devices may wish to support a more lax AGVL IEM that allows compatibility with static addresses
              on-link. When the IEM is set to AGVL, the Override bit MUST NOT be ignored in order to let static addresses
              immediately notify neighbors of a change in their LLADDRs. This is of course UNSECURE and is NOT RECOMMENDED.
            </t>
          </li>
        </ul>

        <section anchor="behavioral-when">
          <name>The Address Verification Shim</name>
          <t>
            VBA verification is a 'shim' software process filtering incoming requests to cache bindings between IP addresses
            and LLIDs. If the verification shim rejects a binding from entering the NC, then the verifying node will be
            denied from properly forwarding data frames to the requesting node. This immediately halts any node's ability to
            forge NDAR packets or to redirect traffic.
          </t>
          <t>
            Employing the verification shim results in a KDF computation that might be costly for low-power nodes
            or other embedded systems, so it is optimized and called as seldom as possible. As such, this document specifies
            that VBA verification MUST be performed when updating or creating a NC entry through NDAR exchanges. For the sake
            of optimization, NUD exchanges MUST NOT use the verification shim. Incoming NDAR packets failing verification
            MUST be ignored, and NC entries MUST NOT be created or updated. Nodes MUST NOT respond to any packets failing
            verification.
          </t>
          <t>
            There are a few situations when NDAR packets MUST pass through the Address Verification Shim (AVS) for approval:
          </t>
          <ul spacing="compact">
            <li>A NS packet is received with a SLLAO attached and a NC entry for the IP Source Address is not already present.</li>
            <li>A NA packet is received for a Target Address whose NC entry is in the INCOMPLETE state.</li>
            <li>If the receiving interface is using the AGVL IEM: a NA packet is received and the Override flag is set.</li>
            <li>A NA packet is received on a node supporting Gratuitious ND and the Target Address does not have a NC entry.</li>
          </ul>
        </section>

        <section anchor="behavioral-nud">
          <name>Neighbor Unreachability Detection</name>
          <t>
            The NUD process outlines the concept of Reachability Confirmation to regularly update NC values when one of two
            types of hints indicates connections with already-cached neighbors are making "forward progress" (Section 7.3.1 of
            <xref target="RFC4861"/>). Forward progress signals an established connection is still ongoing and that a neighbor
            is still considered REACHABLE in the NC.
          </t>
          <t>
            Nodes engage in NUD to keep their NC entries in ideal REACHABLE states. VBAs capitalize on this behavior by
            foregoing address verification requirements when NS/NA transactions only serve to express forward progress.
            This means any forward progress showing NO CHANGE in the LLADDR and IP address of a NC entry MUST allow the
            record to be refreshed as REACHABLE without requiring VBA verification. Any forward progress indicating that
            a change HAS occurred in the LLADDR for an IP address MUST be ignored and MUST NOT update the cache.
          </t>
        </section>

        <section anchor="behavioral-expirations">
          <name>Link Voucher Updates</name>
          <t>
            Any expiration of a current LV used to verify VBAs MUST cause the dynamic NC to be immediately cleared.
            This could occur for any number of reasons, but the expiration indicates the LV is no longer in active use
            and therefore any addresses which were previously cached MUST be dropped. Implementations MAY wish to
            categorize or label NC entries by the LV ID used to verify them as an optimization, so that other NC entries
            will not be forcibly cleared (such as those from a new LV after a handoff occurs).
          </t>
          <t>
            When a new LV is accepted and cached, whether by handoff or due to the absence of a current LV, any current
            NC entries (especially busy or recent ones) MAY have their LLIDs pre-computed into the resulting VBAs which use
            the new LV's parameters, even if no NDARs have been required for those neighbors yet. This allows communications
            with select neighbors to immediately resume without any delays incurred by address verification. It is left to
            the discretion of each implementation to apply this optimization where desired.
          </t>
          <t>
            Static mappings entered into the NC MUST be preserved regardless of LV expirations.
          </t>
        </section>

        <section anchor="behavioral-grand">
          <name>Gratuitous Neighbor Discovery</name>
          <t>
            Gratuitious ND <xref target="RFC9131"/> allows routers to create STALE NC entries from received NAs, as an
            expediting the exchange of host LLADDR bindings. VBAs SHOULD support this option, as routers preemptively
            verifying a host's address bindings will allow the host to communicate off-link much faster than if the
            router required a reverse AR process for the host.
          </t>
          <t>
            Implementations SHOULD be flexible with Gratuitious ND as it applies to IEMs requiring address verification. If
            a flurry of NA packets is received in an ostensible attack, the router might quickly find itself with too much
            work and could start dropping packets. Implementations MAY therefore toggle enablement of this feature reactively.
          </t>
        </section>

        <section anchor="behavioral-dad">
          <name>Duplicate Address Detection</name>
          <t>
            When generating a VBA, the node MUST follow the ordinary means of Duplicate Address Detection (DAD)
            specified by the SLAAC RFC (section 5.4 of <xref target="RFC4862"/>). The DAD procedure SHOULD follow
            any other applicable DAD optimizations (<xref target="RFC4429"/>, <xref target="RFC7527"/>, etc.).
          </t>
          <t>
            Upon detecting a duplicate address, VBA-enabled nodes MUST by necessity to select another iterations
            count 'L' value to generate a non-conflicting address. This can become computationally expensive
            to recompute each new value based on the amount of address collisions, or in the case of denial of
            service attacks.
          </t>
          <t>
            To counter this weakness, implementations MUST employ one of two options based on the selected 'L' value:
          </t>
          <dl newline="true">
            <dt><tt>L &gt;= 4</tt></dt>
            <dd>Cache the 4 leading KDF computations (L-4 through L-1) during the DAD procedure.</dd>
            <dt><tt>L &lt;  4</tt></dt>
            <dd>Cache the result of the 'L' value only.</dd>
          </dl>
          <t>
            Implementations SHOULD always prefer the option where the 'L' value is &gt;= 4, because
            L-4 through L-1 are intermediate KDF results already required in order to produce the result at the final
            iterations count. Conversely, any 'L' value under 4 will simply cache 'L' then increment the KDF iterations
            by one for each DAD collision, up to 4 times.
          </t>
          <t>A figure representing this process visually is shown below:</t>
          <figure>
            <name>Using DAD with VBAs</name>
            <artwork type="ascii-art" name="duplicateAddressDetection.txt">
              <![CDATA[
COMPUTE & CACHE:
  N = Set of K(L', Key, Salt),
    where L' :=
      if L >= 4 :  { L-4, L-3, L-2, L-1, L },
      else      :  { L }

           (1)      +~~~~~~~~~~~~~~+
 |A|{B}------------>| Normal SLAAC | (B :  Duplicate!)
  |     v-----------|  DAD Process | (B':  Success!)
  |  [FAIL]  (2)    +~~~~~~~~~~~~~~+
  |                      ^
  |                      |
  `---> [cached (L-1)    |
         or new (L+1)    | (3)
         generates B'] --'
              ]]>
            </artwork>
          </figure>
          <t>
            In the figure, (1) shows host 'A' engaged in DAD using the address 'B' generated with the iterations count 'L'.
            After the collision is detected in (2), step (3) shows the new address "B'" being immediately tried using the
            already-cached value 'L-1' as the input iterations count. The DAD process is then successful and there are no
            on-link duplicate addresses.
          </t>
          <t>
            To further cement this important optimization procedure, a written example process follows.
          </t>
          <ol>
            <li>A new network host has received Link Voucher details; the voucher specifies using PBKDF2.</li>
            <li>The host arbitrarily selects 0xFF04 as its input link-local iterations count.</li>
            <li>The host will iterate the PBKDF2 function through 0xFEFF.</li>
            <li>When retrieving the PBKDF2 cipher output for 0xFF00 (L - 4) iterations, it will cache this value.</li>
            <li>It will do the same for the next 3 iterations counts (0xFF01, 0xFF02, &amp; 0xFF03).</li>
            <li>It will compute the final PBKDF2 round at 0xFF04 iterations, and will use the result to generate
              a valid VBA <xref target="summary-generate"/>.</li>
            <li>When following the DAD procedure, a collision is detected.</li>
            <li>The host then falls immediately back to the L - 1 iterations count of 0xFF03 to generate the VBA.</li>
            <li>This new host address is completely different and does not register a DAD collision.</li>
            <li>The optimization has successfully removed the need to recompute the PBKDF2 algorithm up to some new
              iterations count, saving a significant amount of time in the VBA-enabled SLAAC process. Reducing the
              chosen 'L' value by 1 results in a completely different pseudo-random address.</li>
          </ol>
          <t>
            If all 5 attempted iterations counts result in DAD collisions, then the node MUST give up and use some other
            implementation-specific course of action to contact an administrator or log a system management error.
          </t>
          <t>
            Note that truly benign DAD collisions are a dangerous prospect for Voucher-Based Addressing. Address
            collisions imply that a separate link-layer identifier with the SAME iterations count has somehow
            generated a hash suffix collision, exposing the possibility for node impersonation in a rare occurrence.
            Some implementations MAY wish to find trusted ways to detect such an occurrence, possibly by means
            of intermediate device monitoring (such as switching hardware), and take action based on it.
          </t>
          <t>
            Nodes encountering a duplicate address will by necessity require a different iterations count to
            generate their current address. If the node uses a 'sticky' iterations count, then it is RECOMMENDED
            that it send a gratuitous VSR update to the LOVMA with the new count (<xref target="lovma-packets-vsr"/>).
          </t>
          <t>
            Protections to mitigate denial of service attacks based on DAD are beyond the scope of this document.
            Since VBAs do not modify the actual DAD process, further research into DAD denial of service protections
            will apply likewise when using VBAs.
          </t>
        </section>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable VBA functionality.</t>

      <section anchor="addenda-voucher">
        <name>Link Voucher Option</name>
        <t>
          The Link Voucher (LV) option specifies the address generation (and consequent verification)
          parameters which on-link hosts MUST agree upon when generating or verifying local VBAs.
        </t>
        <figure>
          <name>Structure of the NDP Link Voucher option</name>
          <artwork type="ascii-art" name="linkVoucherOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |           Expiration          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                                                               |
  |                      128-bit Voucher Seed                     |
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                       TLV Algorithm Type                      <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  >                          DER-encoded                          <
  >                     PublicKey & Signature                     <
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>63</dd>
          <dt>Length</dt><dd>The total length of the LV from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>Expiration</dt>
          <dd>
            A 16-bit big-endian value storing the amount of time in seconds that the Link Voucher should be considered legitimate
            when an update has not been received. This value MUST be between 3,600 (1 hour) and 43,200 (12 hours).
          </dd>
          <dt>Reserved</dt>
          <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
          <dt>Timestamp</dt>
          <dd>
            A 64-bit value representing the system time of the sender at the moment an LV is constructed.
          </dd>
          <dt>VoucherID</dt>
          <dd>
            A pseudo-random 64-bit value that uniquely identifies a Link Voucher instance. This MUST NOT change between distributions
            of the same unique LV.
          </dd>
          <dt>Seed</dt>
          <dd>
            A 128-bit pseudo-random value used as an input for neighbor VBA generation. This value MUST be the same for each
            distribution of an LV identified by a VoucherID. It MUST NOT be the same value across different VoucherID values.
          </dd>
          <dt>Algorithm Type</dt>
          <dd>
            Specifies exactly which type of key derivation function to use in address generation and its corresponding difficulty.
            See <xref target="addenda-voucher-kdfs"/> for more details.
          </dd>
          <dt>PublicKey (named field; NOT present in option data)</dt>
          <dd>
            This value MUST NOT be directly present in LV options. Extended ECDSA signatures have a public key recovery feature which
            allows the PublicKey value to be implied within the encoded signature value <!-- ref -->.
            Receivers are REQUIRED to extract the PublicKey value each time they validate an LV signature, to ensure it has not changed.
            This implied public key value used to sign LVs MUST NOT change in distributions of the same LV identified by the VoucherID value.
          </dd>
          <dt>ECDSA Signature</dt>
          <dd>
            <t>
              A variable-length field containing a DER-encoded ECDSA signature, derived using the Private Key corresponding to
              the sender's LV public key. The signature is computed over a series of sequential octets, constructed in the following order:
            </t>
            <ol spacing="compact">
              <li>The 16-bit 'Expiration' value.</li>
              <li>The 64-bit 'Timestamp' value.</li>
              <li>The 32-bit 'VoucherID' value.</li>
              <li>The 128-bit 'Seed' value.</li>
              <li>The variable-length contents of the 'Algorithm Type' value, including its Type and Length values.</li>
            </ol>
            <t>
              The algorithm used in signature computation is ecdsa-with-SHA256, as defined in Section 3.2 of <xref target="RFC5758"/>.
              This field MUST be a DER-encoded <xref target="ITU.X690.2002"/> ASN.1 structure of the type ECDSA-Sig-Value
              (Section 2.2.3 of <xref target="RFC3279"/>).
            </t>
          </dd>
          <dt>Padding</dt>
          <dd>
            Any extra padding set on the datagram to round its total length to an even 8-octet boundary. Senders MUST initialize this
            value to 0. Receivers MUST ignore this field.
          </dd>
        </dl>

        <section anchor="addenda-voucher-senders">
          <name>Processing Rules for Senders</name>
          <t>
            On-link nodes responsible for an LV (<xref target="bearers"/>) MUST respond to Router Soliciation packets. This is
            true regardless of whether the VB is using a Redirect or Router Advertisement to distribute its LV.
          </t>
          <t>
            Sending nodes wishing to distribute a Link Voucher MUST first check the local link for an already-active LV. This
            entails following a process of router discovery, then only assuming LV responsibility if no LV is already present.
          </t>
          <ol spacing="compact">
            <li>Send a Router Soliciation to the All Routers multicast group at FF02::2.</li>
            <li>Wait for an LV option for at least 2 seconds before sending another Soliciation.</li>
            <li>
              <t>Repeat this process 2 more times.</t>
              <ul spacing="compact">
                <li>If an LV is received within a Router Advertisement or Redirect response, accept and use the parameters of the received LV.
                  This condition means the sender MUST NOT send their own LV, nor should it propagate any instances of LV options.</li>
                <li>
                  <t>If no LV is received after the 3 total attempts, and...</t>
                  <ul spacing="compact">
                    <li>the Sender IS NOT a router: the Sender's LV may be distributed on the local link as an option attached
                      to an appropriate NDP Redirect packet.</li>
                    <li>the Sender IS a router: the Sender may attach its LV to an appropriate ND Router Advertisement packet.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ol>
          <t>
            Senders of Link Vouchers MUST maintain stateful information about their LVs, so reliable and consistent LVs
            can be sent as demanded. The rotation of stable LV information -- the ID, Seed value, or Algorithm details --
            MUST be signaled in advance using the LOVMA group <xref target="lovma-packets-vha"/> which will initiate a transition
            window to the new address generation parameters.
          </t>
          <t>
            Expiration values MUST be set to an appropriate value. Senders MAY adjust this value without requiring a handoff.
            Timestamp values MUST always be sent to the precise system time as a big-endian 64-bit value.
          </t>
          <t>
            The Sender's LV MUST always be unique on-link and NEVER be forwarded or duplicated copies of other LVs. Additionally,
            the Voucher Seed MUST NOT be preserved between different LV VoucherIDs or handoffs. It MUST always be a random value
            when first assigned to an LV VoucherID.
          </t>
          <t>
            Protecting the link from rogue LVs is crucial to securely maintain the full consensus of the local network.
            See <xref target="bearers-vigilance"/> on RA-Guard and <xref target="security-usurp"/> about LV Hijacking
            for more details. <xref target="security-pki"/> also discusses considerations for incorporating trust anchors and PKI.
          </t>
        </section>

        <section anchor="addenda-voucher-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
            A Link Voucher option appearing with any packet except NDP Router Advertisements or NDP Redirects MUST be ignored.
          </t>
          <t>
            Nodes manually set to Address Awareness Disabled mode on their receiving interface MUST ignore LVs. Similarly, nodes
            with static LV details assigned on their interface(s) MUST ignore LVs.
          </t>
          <t>
            Nodes acting as authorized Voucher Bearers MUST disregard any received LV options on the links for which they are
            already the active, responsible VB.
          </t>
          <t>
            Receiving nodes MUST statefully maintain and update all LV information per interface, if and only if the received LV
            is successfully verified according to its cryptographic signature. The most recent, valid, and unexpired version of
            the LV is what MUST always be cached and preferred on the receiving interface. A received LV that does not contain a
            valid signature MUST be ignored.
          </t>
          <t>
            Nodes receiving a new LV for the first time are "locked" to the LV and its public key. They MUST NOT accept LVs which
            contain any other PublicKey details or signatures which do not use the same PublicKey. This period of "locking" remains
            until the cached LV is expired or VB responsibility is delegated to another LV.
          </t>
          <t>
            Received LVs which contain different address generation parameters (VoucherID, Seed, Algorithm Type option details)
            MUST be ignored and MUST NOT update any cached LV entries. Likewise, any difference in the PublicKey field MUST cause
            the LV to be ignored.
          </t>
          <t>
            LVs with invalid timestamps MUST be ignored. Timestamps MUST be considered invalid if the value falls outside the
            range [CURRENT_TIMESTAMP - LV_Expiration] to [CURRENT_TIMESTAMP + LV_Expiration], where 'CURRENT_TIMESTAMP' is the
            64-bit system time (in seconds) measured by the receiving node. This ensures timestamp validity remains flexible even
            with minor clock drifting across the local network.
          </t>
          <t>
            Segment VBs may occasionally wish to hand off responsibility for the Link Voucher to another VB through gratuitous
            Voucher Handoff Advertisements (see <xref target="lovma-packets-vha"/>). These VHAs serve to enable a "sliding window"
            where two LVs MAY be active on the same link at one time. During this window, both Link Vouchers MUST be considered
            valid and cached accordingly. This same window MAY also be used for updating the Algorithm Type and other current LV
            options.
          </t>
        </section>

        <section anchor="addenda-voucher-kdfs">
          <name>Algorithm Type Options</name>
          <t>
            Section 5 of <xref target="RFC8018"/> specifies the definition of a Key Derivation Function (KDF):
          </t>
          <blockquote>
               A key derivation function produces a derived key from a base key and
               other parameters.  In a password-based key derivation function, the
               base key is a password, and the other parameters are a salt value and
               an iteration count...
          </blockquote>
          <t>
            This section will discuss the default algorithms and KDF types that SHOULD be packaged with basic implementations
            of this specification. Future versions or extensions of this document MAY add new Key Derivation Function algorithms.
          </t>
          <t>
            Any Algorithm Type option not specified in this document or in future versions MUST be ignored by receivers.
          </t>
          <t>
            Any TLV Algorithm Type choice is formatted as a Type-Length-Value object, where Type is a numeric identifier
            uniquely representing a chosen KDF, Length is the width of the total TLV Algorithm Type in units of 4 octets,
            and Value is a compact data format zero-padded to the nearest 32-bit boundary. Receivers MUST always ignore padding
            and senders MUST always initialize padded areas to zero.
          </t>
          <figure>
            <name>Structure of an Algorithm Type Option</name>
            <artwork type="ascii-art" name="algorithmOption.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |              Type             |             Length            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                             Value                             <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <t>
            The list of default KDF Algorithm Type choices is given below.
          </t>
          <!-- Might it be better to use ASN1 notation here or DER to convey some object details? -->
          <dl newline="true">
            <dt>PBKDF2_SHA256</dt>
            <dd>
              <t>
                The Password-Based Key Derivation Function (PBKDF2) is defined in Section 5.2 of <xref target="RFC8018"/>.
                It is a CPU-bound cryptographic function which might incur significant computation speed disparities
                between embedded systems and high-performance hardware. It is included primary for portability,
                universality, and ease of implementation.
              </t>
              <t>
                This specification explicitly uses PBKDF2 with SHA-256 as its PRF: implementations using this Type MUST
                use SHA-256 as the PBKDF2 Pseudo-Random Function.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>1</dd>
                <dt>Length</dt><dd>2</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>ITERATIONS_FACTOR</dt>
                    <dd>
                      A 16-bit integer representing the multiplier of an input KDF iterations count, specified in big-endian
                      format. This value MUST be greater than 0; receivers of 0 values MUST use 1 instead. This factor can be
                      used by a Link Voucher to automatically scale the 'difficulty' of the PBKDF2 KDF on the network.
                    </dd>
                    <dt>Padding</dt>
                    <dd>
                      16 bits (2 octets) of padding initialized to zero. Senders MUST set this to 0. Receivers MUST
                      ignore this padding.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
            <dt>Argon2d</dt>
            <dd>
              <t>
                The Argon2 algorithm is specified in Section 3 of <xref target="RFC9106"/>. It is a Memory-bound cryptographic
                function which will ideally provide less disparate address computation speeds than CPU-bound algorithms like
                PBKDF2.
              </t>
              <t>
                This specification explicitly opts to use Argon2d instead of Argon2i or Argon2id because the generation of
                VBAs does not require any resistance to side-channel attacks. The in-memory data used by the KDF SHOULD NOT be
                treated as secret for any reason. All Implementations with this Type MUST specifically use Argon2d.
              </t>
              <t>
                The iterations count 'L' value is used as the 't' input for Argon2d computations. The Argon2 't' parameter
                indicates the number of passes and is used to increase the algorithm's running time regardless of MemorySize.
                To give the LV parameters in the Value field more weight, 't' MUST always be calculated from the input 'L' value
                as follows:
              </t>
              <t><tt>t := (L &gt;&gt; 8) + 1</tt></t>
              <t>
                The Argon2 parameters for Secret Value 'K' and Associated Data 'X' MUST NOT be used or distributed by the LV.
                The Tag Length 'T' for Argon2d MUST be set to 32 and MUST NOT be changed.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>10</dd>
                <dt>Length</dt><dd>2</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>Parallelism</dt>
                    <dd>
                      An 8-bit integer determining how many degrees of parallelism (lanes) are allowed to run during KDF
                      computation. This value SHALL NOT be set to 0. Receivers MUST consider Parallelism values of 0 to
                      automatically indicate a Parallelism of 1.
                    </dd>
                    <dt>MemorySize</dt>
                    <dd>
                      A 24-bit integer representing the number of kibibytes used in the KDF computation. This value SHOULD be
                      carefully controlled and take into consideration the computing resources across the network on which the LV
                      will be distributed. This value MUST be a minimum of <tt>8 &times; Parallelism</tt> and MUST NOT be set to 0.
                      Receivers MUST adjust the minimum MemorySize accordingly if the value does not meet the minimum threshold for
                      the ACTUAL degree of Parallelism being used.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
            <dt>Scrypt</dt>
            <dd>
              <t>
                The Scrypt KDF algorithm is specified in Section 6 of <xref target="RFC7914"/>. It is a Memory-bound cryptographic
                function which, similar to Argon2, ideally providing less disparate address computation durations than CPU-bound
                key derivation techniques. Implementations SHOULD always prefer to use this Type over others, provided all
                participating network devices have Scrypt support.
              </t>
              <t>
                The iterations count 'L' value is used in part for both the 'N' and 'r' inputs for Scrypt computations. The Scrypt
                'N' parameter indicates the CPU/Memory cost of running the computation. This value MUST ultimately be a power of 2.
                The 'r' Scrypt parameter indicates the desired block size. Actual values are computed by the following conversion:
              </t>
              <t>
                <tt>r (Parallelism) := MAX{ 16, (L &amp; 0xFF00) &gt;&gt; 4 } &lt;&lt; SCALING_FACTOR</tt><br />
                <tt>N (Cost) := MAX{ 2, 1 &lt;&lt; (L &amp; 0x00FF) } &lt;&lt; SCALING_FACTOR</tt>
              </t>
              <t>
                The Scrypt parameter 'dkLen' (derived key length) MUST always be set to 32 and MUST NOT differ between
                implementations. The Parallelization parameter 'p' MUST always be set to 1 and MUST NOT differ between
                implementations.
              </t>
              <dl newline="true" spacing="compact">
                <dt>Type</dt><dd>20</dd>
                <dt>Length</dt><dd>2</dd>
                <dt>Value</dt>
                <dd>
                  <dl newline="true" spacing="compact">
                    <dt>SCALING_FACTOR</dt>
                    <dd>
                      An 8-bit integer setting the "difficulty" of the Scrypt algorithm. This value MUST only be 0 through 5 inclusive.
                      Receivers adjust the maximum SCALING_FACTOR to 5 if the value of this field is greater than 5.
                    </dd>
                    <dt>Padding</dt>
                    <dd>
                      24 bits (3 octets) of padding initialized to zero. Senders MUST set this to 0. Receivers MUST
                      ignore this padding.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>
          </dl>
          <t>
            A cursory exploration of KDF speeds in the address generation process can be found in <xref target="appendix-speed"/>.
          </t>
        </section>
      </section>

      <section anchor="addenda-summary">
        <name>Voucher Summary Option</name>
        <t>
          The Voucher Summary (VS) option SHOULD be included with Neighbor Solicitation and Advertisement packets to
          hint to recipients which active Link Voucher ID is being statefully used on the target or source interface.
        </t>
        <figure>
          <name>Structure of the NDP Voucher Summary option</name>
          <artwork type="ascii-art" name="voucherSummaryOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>64</dd>
          <dt>Length</dt><dd>Set to 1. The total length of the VS from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>IEM</dt>
          <dd>
            <t>
              A 3-bit identifier representing the current Interface Enforcement Mode of the sending interface (see
              <xref target="summary-interfaces-mode"/>).
            </t>
            <table anchor="iem-mappings">
              <name>IEM Identifier Mappings</name>
              <thead>
                <tr><th>Value</th><th>IEM</th></tr>
              </thead>
              <tbody>
                <tr><td>0</td><td>AAD</td></tr>
                <tr><td>1</td><td>AGO</td></tr>
                <tr><td>2</td><td>AGV</td></tr>
                <tr><td>3</td><td>AGVL</td></tr>
                <tr><td>4</td><td>Reserved</td></tr>
                <tr><td>5</td><td>Reserved</td></tr>
                <tr><td>6</td><td>Reserved</td></tr>
                <tr><td>7</td><td>Reserved</td></tr>
              </tbody>
            </table>
          </dd>
          <dt>Reserved</dt><dd>A 13-bit field reserved for future use. This MUST be initialized to zero by the sender and MUST
            be ignored by the receiver.</dd>
          <dt>VoucherID</dt><dd>The 32-bit ID of a valid Link Voucher retained on the sending interface.</dd>
        </dl>

        <section anchor="addenda-summary-senders">
          <name>Processing Rules for Senders</name>
          <t>
            Senders SHOULD always include this option with all NDP Neighbor Solicitations or Advertisements. When a valid
            LV is NOT currently available on the sending interface, senders MUST set the IEM to AAD mode and initialize
            the VoucherID to 0.
          </t>
          <t>
            The IEM value MUST be accurately set to the current IEM of the sending interface. The 32-bit VoucherID field MUST
            be equal to the cached Link Voucher ID for the sending interface.
          </t>
        </section>

        <section anchor="addenda-summary-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
            The VS option is NOT REQUIRED and SHALL NOT become required at any future time. Any NDP packets not including it MUST
            be treated as they normally would by the receiver's IEM and other processes. The same is true for VS options which are
            'ignored' due to incorrect formatting or some other validation decision.
          </t>
          <t>
            If the receiver's IEM is AAD, the VS option MUST be ignored.
          </t>
          <t>
            Processing of valid VS options is affected by which NDP packet types they are attached to:
          </t>
          <dl newline="true">
            <dt>Neighbor Solicitations</dt>
            <dd>
              <t>
                The receiving interface MUST disregard the NS if there is a non-zero VoucherID present and it does not match the
                ID of the active Link Voucher of the receiving interface. To 'disregard' means to not respond to the NS at all.
              </t>
              <t>
                If the receiver is aware of a current Voucher Handoff on the link, then either the current voucher ID or the
                upcoming voucher ID MUST be considered valid.
              </t>
            </dd>
            <dt>Neighbor Advertisements</dt>
            <dd>
              <t>
                Processing affects VBA verification procedures on the receiving interface based on the receiver's IEM.
              </t>
              <t>
                Receivers MUST first inspect the IEM field to acquire the mode of the sending interface. If the IEM indicates an
                AAD mode at the sender, the receiver MUST behave according to their own IEM:
              </t>
              <dl newline="false" spacing="normal">
                <dt>AAD</dt><dd>Ignore the VS option entirely.</dd>
                <dt>AGO</dt><dd>Ignore the VS option since VBA verification is not being performed anyway.</dd>
                <dt>AGV</dt><dd>Drop the packet. Do not cache the neighbor's details. Completely deny them.</dd>
                <dt>AGVL</dt><dd>Regard the neighbor as Unsecured and skip the VBA verification process.</dd>
              </dl>
              <t>
                If the VoucherID field is initialized to zero, the VS option MUST be ignored. If the VoucherID value does not match
                the ID of the active Link Voucher on the receiving interface, the VS option MUST be ignored. Otherwise, processing
                proceeds to VBA verification per the receiver's IEM.
              </t>
              <t>
                If the receiver is aware of a current Voucher Handoff on the link, then either the current voucher ID or the
                upcoming voucher ID MUST be considered valid.
              </t>
            </dd>
            <dt>Any other NDP packet types</dt>
            <dd>The receiver MUST ignore the VS option.</dd>
          </dl>
        </section>
      </section>
    </section>

    <section anchor="lovma">
      <name>Local On-link Voucher Multicast Address</name>
      <t>
        The LOVMA group is defined for the express purpose of sharing gratuitous, independent VBA details between nodes.
        All nodes with VBA awareness, regardless of Interface Enforcement Mode (<xref target="summary-interfaces-mode"/>)
        are strongly RECOMMENDED to join this group. Nodes are NOT REQUIRED to make practical use of any LOVMA traffic.
        Current link Voucher Bearers are always REQUIRED to join the LOVMA group.
      </t>
      <t>
        This multicast group is located at the IP address FF02::ABBA. A helpful mnemonic to remember this address is to
        think of "ABBA" as the closest possible hexademical rendition of "a VBA".
      </t>
      <t>
        The designated UDP port on which all LOVMA traffic is received is 2196.
      </t>
      <t>
        Senders of LOVMA traffic are REQUIRED to send packets from a link-local addresses bound to the interface being used
        to communicate on the LOVMA channel.
      </t>

      <section anchor="lovma-constraints">
        <name>Constraints</name>
        <t>
          When utilizing the LOVMA for any purpose, experimental or deployed, implementations MUST regard these constraints:
        </t>
        <ul>
          <li>LOVMA traffic is considered unidirectional. Nodes SHOULD NOT send unicast responses in reply to multicast traffic.
            This recommended constraint acts to prevent asymmetric traffic volumes and potential denial of service vulnerabilites
            leveraging the LOVMA.</li>
          <li>All LOVMA datagrams MUST be User Datagram Protocol (UDP) <xref target="RFC768"/> packets.</li>
          <li>VBA-enabled nodes MUST NOT assume that any other VBA-enabled nodes are subscribed to the LOVMA multicast group or
            receiving any of its related datagrams. However, nodes MUST assume the presence of the current link VB in the LOVMA.</li>
          <li>Subscribing nodes MUST NOT offer any trust of LOVMA packets, unless a datagram validation procedure is explicitly
            declared in the Defined Datagram using the LOVMA.</li>
        </ul>
      </section>

      <section anchor="lovma-packets">
        <name>Defined Datagrams</name>
        <t>
          This section outlines and formalizes some initial datagrams which should be expected to appear on LOVMA at any time.
        </t>
        <t>
          All packets MUST use a Type-Length-Value (TLV) format. Type is an 8-bit integer identifying the datagram type, Length
          is the length of the packet (including the Type and Length fields) in units of 4 octets, and Value is the following
          object to be parsed.
        </t>
        <t>
          The Type or Length fields MUST NOT be set to 0. Receivers MUST ignore datagrams with a Type of 0 or a Length of 0.
        </t>

        <section anchor="lovma-packets-vsr">
          <name>Voucher Status Reports (VSRs)</name>
          <t>
            A node might opt to occasionally send VSRs to the LOVMA channel to gratuitously let other nodes know of its presence
            as a VBA-enabled interface in addition to a few VBA state-related fields.
          </t>
          <t>
            Sending interfaces are REQUIRED to add their link-layer identifier onto VSR packets. This allows receivers to easily
            identify the sending interface by ID, rather than associating the sender to one of its potentially many IP addresses
            on-link.
          </t>
          <t>
            Senders MUST adhere to the rules defined in the below figure. Receivers are NOT REQUIRED to parse any of the fields.
          </t>
          <figure>
            <name>Structure of a VSR Datagram</name>
            <artwork type="ascii-art" name="lovmaVsr.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        32-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Pref. Iterations Count    |          LLID Length          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                              LLID                             <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>1</dd>
            <dt>Length</dt><dd>Variable. The length of the datagram in its totality rounded up to the nearest 4 octets.</dd>
            <dt>IEM</dt>
            <dd>
              A 3-bit value identifying the IEM of the sending interface. See <xref target="iem-mappings"/> for the possible IEM
              values. This value MUST be set to AAD mode if the sending interface does not have a currently cached, active Link Voucher.
            </dd>
            <dt>Reserved</dt>
            <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
            <dt>VoucherID</dt>
            <dd>
              The ID of the cached, active Link Voucher on the sending interface. Senders MUST initialize this to 0 if no LV is present
              or if they are operating in the AAD IEM.
            </dd>
            <dt>Preferred Iterations Count</dt>
            <dd>
              Also known as the 'sticky' iterations count. Senders MAY use this field to indicate a preferred 'L' value when generating
              on-link addresses for each prefix. Receivers MAY associate this field with the Link Layer ID (LLID) field which the generated
              address is bound to, to preemptively calculate VBAs for a neighbor. See <xref target="optimizations"/> for more details.
            </dd>
            <dt>LLID Length</dt><dd>The length in bytes of the LLID field. Stored as a big-endian value.</dd>
            <dt>LLID</dt><dd>A variable-length field representing the node's on-link Link Layer identifier.</dd>
            <dt>Padding</dt>
            <dd>
              Any extra padding set on the datagram to round its total length to an even 4-octet boundary. Senders MUST initialize this
              value to 0. Receivers MUST ignore this field.
            </dd>
          </dl>
        </section>

        <section anchor="lovma-packets-vci">
          <name>Voucher Capability Indications (VCIs)</name>
          <t>
            A node may notify the LOVMA channel about its potential candidacy as a link Voucher Bearer (<xref target="bearers"/>)
            by sending a VCI datagram. The VCI is an informational packet REQUIRED to be considered for election by the current VB.
          </t>
          <t>
            Receivers are typically intended to be the current VB, but any node MAY make use of VCI details. Nodes MUST NOT consider
            VCI packets as valid Link Vouchers. The current VB MAY maintain a state of unexpired VCI packets, especially when
            it intends to elect a new node responsible for the LV. Current VBs SHOULD NOT elect a new VB without first receiving a
            VCI datagram indicating the sender's readiness to be elected.
          </t>
          <t>
            Sending nodes MUST NOT assume that issuance of a VCI packet is guaranteed to lead to their eventual election as a link VB.
            The decision for election MUST be indicated by receipt of a signed VHA datagram.
          </t>
          <figure>
            <name>Structure of a VCI Datagram</name>
            <artwork type="ascii-art" name="lovmaVci.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                      Link Voucher Contents                    <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>2</dd>
            <dt>Length</dt><dd>Variable. The length of the datagram in its totality rounded up to the nearest 4 octets.</dd>
            <dt>Reserved</dt>
            <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
            <dt>Link Voucher Contents</dt>
            <dd>
              The entirety of the NDP Link Voucher option to be attached to Router Advertisements or Redirects. This also MUST include
              the NDP Option Type and Length values. Validation of this field follows the same rules outlined by <xref target="addenda-voucher"/>.
              Receivers MUST NOT expect the signature or public key of the LV option to be the same as that of the current LV, because
              this packet type is only announcing a node's candidacy for future election and it is NOT attempting to delcare a network LV.
              Receivers MUST ignore the entire VCI if validation of the embedded Link Voucher fails for any reason, including invalid
              cryptographic signatures, null IDs, etc.
            </dd>
          </dl>
        </section>

        <section anchor="lovma-packets-vha">
          <name>Voucher Handoff Advertisements (VHAs)</name>
          <t>
            The node responsible for the Link Voucher MAY at any time elect a new link Voucher Bearer (<xref target="bearers"/>)
            using the VHA datagram. This 'handoff' communication notifies VBA-enabled hosts of a change in VB and thus public-key
            information used to sign the new LV. If the public-key signature on the VHA is valid and nodes are 
          </t>
          <t>
            The transition window duration is based on the 'Expiration' value of the current VB's LV packet. Exceedingly long
            Expirations will entail exceedingly long transition windows, and there is no limit to the duration of a transition.
            VHA frequency is variable but is RECOMMENDED to follow the same frequency as the node's previous RA or Redirect issuances.
            Nodes initiating a handoff MUST send at least one VHA notification every 5 seconds for a minimum of 3 minutes OR the
            length of the 'Expiration' value, whichever is shorter. If the 'Expiration' value is high, nodes handing off VB
            responsibility MAY choose to stop transmitting VHAs after this minimum threshold.
          </t>
          <t>
            Candidate nodes considered for VB election MUST be gathered from either (1) manually configured details or (2) senders
            of recent, unexpired VCI notifications.
          </t>
          <t>
            When the elected node observes the VHA packet granting it VB responsibility, it MUST begin sending gratuitous Router
            Advertisements or Redirects to the local network for which it is now a VB. Sending a RA to the local network always
            follows the receipt of a valid, unexpired VHA from the previous VB. After 2 minutes, the new VB MUST consider the LV
            parameters (including the public key) of the previous VB as invalid, and no longer trigger RAs based on receipt of VHAs.
          </t>
          <t>
            VHAs MUST also be used to indicate a change in active Link Voucher details using the 'Refresh' bit. This indicates that
            the handoff represents a transition between LV parameters from the same VB rather than a change of issuing VB nodes.
            Using the VHA for this purpose affords neighbors enough time to fully transition addresses between varying LV parameters.
          </t>
          <t>
            See <xref target="summary-interfaces-transitions"/> for more details regarding the handoff process at the per-interface
            scope.
          </t>
          <figure>
            <name>Structure of a VHA Datagram</name>
            <artwork type="ascii-art" name="lovmaVha.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    |R|          Reserved           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    32-bit Signer VoucherID                    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                   32-bit Upcoming VoucherID                   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                                                               <
  >                     DER-encoded Signature                     <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  >                            Padding                            <
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
          <dl newline="true">
            <dt>Type</dt><dd>3</dd>
            <dt>Length</dt><dd>Variable. The length of the datagram in its totality rounded up to the nearest 4 octets.</dd>
            <dt>Refresh Bit</dt>
            <dd>
              A single bit. When set to '1', it indicates that the transition is only a Link Voucher refresh and does not represent a
              LV handoff to a new or different Voucher Bearer node. This field is mostly used for informational purposes and for any
              further implementation-specific optimizations.
            </dd>
            <dt>Reserved</dt>
            <dd>Space reserved for future use. This value MUST be initialized to 0 by senders and MUST be ignored by receivers.</dd>
            <dt>Timestamp</dt>
            <dd>
              <t>The current precise system time encoded as a 64-bit value.</t>
              <t>
                Timestamps MUST be considered invalid if the value falls outside the range [CURRENT_TIMESTAMP - 120] to
                [CURRENT_TIMESTAMP + 120], where 'CURRENT_TIMESTAMP' is the 64-bit system time (in seconds) measured by the receiving node.
                This ensures timestamp validity remains flexible even with minor clock drifting across the local network.
              </t>
            </dd>
            <dt>Signer VoucherID</dt>
            <dd>
              The VoucherID of the active LV which is signing the handoff to the Upcoming VoucherID. Nodes using this ID for their active
              LV SHOULD disregard any further advertised LVs with this ID upon receiving this packet. A receiver MUST ignore this packet
              if the Signer VoucherID does not represent the active LV held in the cache of its receiving interface.
            </dd>
            <dt>Upcoming VoucherID</dt>
            <dd>
              The VoucherID of the upcoming LV which will be assuming 'active' status on the network after the transition window completes.
            </dd>
            <dt>ECDSA Signature</dt>
            <dd>
              <t>
                A variable-length field containing a DER-encoded ECDSA signature, derived using the Private Key corresponding to
                the sender's Signer VoucherID. The signature is computed over a series of sequential octets, constructed in the following order:
              </t>
              <ol spacing="compact">
                <li>The 64-bit 'Timestamp' value.</li>
                <li>The 32-bit 'Signer VoucherID' value.</li>
                <li>The 32-bit 'Upcoming VoucherID' value.</li>
              </ol>
              <t>
                The algorithm used in signature computation is ecdsa-with-SHA256, as defined in Section 3.2 of <xref target="RFC5758"/>.
                This field MUST be a DER-encoded <xref target="ITU.X690.2002"/> ASN.1 structure of the type ECDSA-Sig-Value
                (Section 2.2.3 of <xref target="RFC3279"/>).
              </t>
            </dd>
            <dt>Padding</dt>
            <dd>
              Any padding necessary to round the packet size up to the nearest 32-bit boundary. This value MUST be initialized to 0 by
              senders and MUST be ignored by receivers.
            </dd>
          </dl>
        </section>
      </section>
    </section>

    <section anchor="bearers">
      <name>Voucher Bearers</name>
      <t>
        A Voucher Bearer (VB) is the on-link node responsible for the current, majority-accepted Link Voucher. This
        section introduces any VB constraints, recommendations, or other procedures for VBA implementations and deployments.
      </t>

      <section anchor="bearers-appointment">
        <name>Appointments</name>
        <t>
          Any node MAY be elected to serve as the link's VB, whether by manual configuration or by a process of election
          and appointment from the current VB (see <xref target="lovma-packets-vci"/>). Current network VBs wishing to
          transfer LV ownership to another responsible candidate VB MUST use the LOVMA channel and issue handoffs per the
          election process (see <xref target="lovma-packets-vha"/>). Nodes MUST NOT be forced into VB responsibilities
          without first offering their capability through their own LV option attachments or through valid LOVMA VCI packets.
        </t>
        <t>
          If the current VB is NOT a router or responsible for routing subnet traffic, then it MUST distribute the LV via
          an NDP Redirect packet with an LV option, instead of using an NDP RA packet with the LV option. The Redirect is
          expected to behave similarly to the defined NDP process (Section 8 of <xref target="RFC4861"/>).
        </t>
        <t>
          VBs MAY at any time let their own LVs expire if they do not wish to elect another VB, or if there are no other
          candidates available on the LOVMA channel. VBs SHOULD NOT let their own LVs expire without first appointing a
          responsible successor node. If there is no successor, the most recent LV MUST remain current in the network until
          another node assumes VB responsibility.
        </t>
      </section>

      <section anchor="bearers-vigilance">
        <name>Employing RA-Guard</name>
        <t>
          Fake or malicious Link Vouchers can cause issues for nodes who do not yet have the state of an LV stored in
          their local interface(s) on-link. Illegitimate VBs represent a threat more thoroughly explored in
          <xref target="security-usurp"/>. Undesired or "bogus" RAs/Redirects are a known problem in local IPv6 networks
          with no active protections, causing potential failure of on-link nodes. An excerpt from the RA-Guard RFC is noted:
        </t>
        <blockquote>
          <xref target="RFC6105"/> describes a solution framework for
          the rogue-RA problem <xref target="RFC6104"/> where network segments are designed
          around a single L2-switching device or a set of L2-switching devices
          capable of identifying invalid RAs and blocking them.  The solutions
          developed within this framework can span the spectrum from basic
          (where the port of the L2 device is statically instructed to forward
          or not to forward RAs received from the connected device) to advanced
          (where a criterion is used by the L2 device to dynamically validate
          or invalidate a received RA, this criterion can even be based on SEND
          mechanisms).
        </blockquote>
        <t>
          The RA-Guard system SHOULD be augmented and deployed with VBA-aware functions, capable of tracking the state
          of Link Vouchers and LOVMA channel elections. This will allow an intermediate network device, such as
          a switch, to only require RA-Guard Learning mode for a short initial period and then to subsequently "follow"
          the correct LV around, similar to what other network nodes do.
        </t>
        <t>
          The difference with RA-Guard in this scenario is to of course enable and disable RA/Redirect packet forwarding
          when and where appropriate based on what the system understands about the state of vouchers on the network. One
          notable exception to this, however, is that a RA-Guard implementation MAY drop its protections if and only if
          the most recent and legitimate LV has expired without a successor VB. This is because some responsible VB needs
          to be able to supersede a "dead" or expired LV.
        </t>
        <t>
          In the case where the elected VB is NOT a link router nor responsible for routing traffic, and NDP Redirect
          packets are being used with the LV option, a Redirect-aware flavor of RA-Guard is strongly RECOMMENDED to also
          include these in its learning processes.
        </t>
        <t>
          Use of RA-Guard is primarily suggested for networks with a revolving door of clients, such as public networks,
          or networks which need to fortify and guarantee their security posture.
          The exact deployment of RA-Guard is beyond the scope of this document, but it is strongly RECOMMENDED where
          possible in order to ensure VBAs faithfully serve their purpose during the ND Address Resolution process.
          Appointments or elections of new VBs should be considered with caution, because the lack of PKI introduces a
          problem with bogus claims of INITIAL identity.
        </t>
      </section>
    </section>

    <section anchor="optimizations">
      <name>Specification Optimizations</name>
      <t>
        This section briefly lists and references the various optimizations built into this specification.
      </t>

      <section anchor="optimizations-summary">
        <name>Summary</name>
        <dl newline="true">
          <dt><tt>Avoiding Repeat Verifications</tt></dt>
          <dd>
            Neighbor Discovery NUD features are used to avoid continuous verification of active neighbors between Link Voucher
            instances. Neighbors do not need to be re-verified when there has been no change to their already-verified bindings
            in a previous Address Resolution exchange. <xref target="behavioral-nud"/> provides more details about this crucial
            performance optimization.
          </dd>

          <dt><tt>Duplicate Address Detection</tt></dt>
          <dd>
            The SLAAC DAD process <xref target="RFC4862"/> is optimized to reduce the burden of regenerating another VBA
            from scratch. See <xref target="behavioral-dad"/> for how this optimization reduces the costs of DAD collisions.
          </dd>

          <dt><tt>The LOVMA Channel &amp; Preemption</tt></dt>
          <dd>
            The LOVMA group affords various optimizations to the network. It enables the use of gratuitous handoffs for
            VBA-enabled nodes to detect upcoming voucher changes (<xref target="lovma-packets-vha"/>). It allows hosts to
            note their preferred iterations counts for upcoming address generations, new prefixes, and LV VB transitions
            (<xref target="lovma-packets-vsr"/>). Lastly, it allows candidate nodes to become capable for VB election when
            the current VB no longer wishes to maintain responsibility for the Link Voucher (<xref target="lovma-packets-vci"/>).
          </dd>

          <dt><tt>Key Derviation Function Selections</tt></dt>
          <dd>
            The options presented in <xref target="addenda-voucher-kdfs"/> permits VBs the flexibility to choose a baseline
            "difficulty" setting for address generation and verification in their distributed LVs. From this baseline, which
            implementations MAY establish through either default settings or some other network benchmarking, network nodes
            are permitted to scale the difficulties of each address they generate based on their chosen iterations counts.
          </dd>

          <dt><tt>Voucher Summary Options</tt></dt>
          <dd>
            VS options (<xref target="addenda-summary"/>) allow hosts to exchange identifying information about the LVs used
            to construct or verify the target address related to the current NDP Address Resolution exchange. This saves
            computation time if the two hosts disagree on the ID of the active (and possibly upcoming) Link Voucher. Behavior
            with this option is of course based on the IEMs of the two communicating interfaces during this exchange.
          </dd>
        </dl>
      </section>

      <section anchor="optimizations-preemption">
        <name>A Note About Packet Loss &amp; Speed</name>
        <t>
          This document proposes various optimizations to ensure the performance of VBAs is commensurate with the simplicity
          of its integration into pre-established LANs. However, the cost of address verification can be notable depending on
          the selected Algorithm Type options of a Link Voucher, in addition to the relative computing power of the verifying
          node. Such a process might easily create a situation where addresses simply cannot be verified fast enough.
        </t>
        <t>
          As such, it is important to highlight that optimizations become inversely proportional to security. In other words,
          preemptive caching of neighbor information -- from, e.g., Gratuitious Neighbor Discovery <xref target="RFC9131"/> --
          results in fewer lost packets when enabled. But it also grants the ability for malicious attackers to spoof thousands
          of gratuitous advertisements per second, inundating routers with a backlog of address bindings to verify (assuming
          some IEM on the receiving interface mandates verification).
        </t>
        <t>
          It is left to both (1) other works and (2) per-implementation details to balance these issues. While this document
          attempts to find a happy medium, it can only make generic suggestions due to its umbrella of affected technologies.
        </t>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Considerations</name>
      <t>
        This document would be unrealistic to assume that VBAs could be deployed simultaneously across all hosts in even
        relatively tiny local subnets. There will undoubtedly be network devices present which have no support for VBAs.
        While that is especially true at the time of writing this document, it is certain that -- like IPv6 itself -- some
        hardware vendors and software developers will never implement the protocol or provide necessary operable support.
      </t>
      
      <section anchor="transitions-dualstack">
        <name>Dual-Stack Communications</name>
        <t>
          A pure IPv6 local network using the AGV IEM across its nodes will simply not be able to communicate
          bidirectionally with node(s) lacking VBA support. Bidirectional traffic between the VBA-unaware node and the
          network gateway will be dropped due to the requirements of address verifications. However, in the case of
          dual-stack LANs, IPv4 traffic can be used as an insecure (read: spoofable) failsafe protocol when connecting
          hosts are explicitly aware of a route in both protocol stacks, such as between a LAN client and a gateway router.
        </t>
        <t>
          The Happy Eyeballs algorithm from <xref target="RFC6555"/> specifies a connection methodology that simultaneously
          attempts IPv4 and IPv6 connections, preferring IPv6 communication. Destination hosts are often selected from a
          pool of Domain Name System (DNS) query results in a round-robin fashion. For local networks using AGV mode, the
          IPv6 network will appear unavailable and broken to the unsupporting node(s): thus, they should fall back to using
          IPv4 in the case where both stacks are supported.
        </t>
        <t>
          This will permit some degree of communication for unsupporting nodes, both on the local link and off-link,
          wherever IPv4 traffic is allowed.
        </t>
      </section>

      <section anchor="transitions-iem">
        <name>Tweaking Interface Enforcement Modes</name>
        <t>
          Local IEMs can be adjusted on hosts communicating directly with unsupporting nodes to better accommodate their
          lack of verified VBAs on-link. For example, two local VBA-enabled nodes corresponding with an ancient device might
          opt to use the AGVL IEM. This could allow them to strongly prefer Secured devices for the rest of the network (such
          as the default gateway) while being accepting of ND Address Resolution traffic that does not contain any Secured
          responses.
        </t>
        <t>
          In the case of a subnet router in a mixed network -- that is, a LAN consisting of VBA-enabled and unaware nodes
          alike -- using the AGVL IEM can once again prove very advantageous for the sake of accommodation. Assuming most
          nodes use VBAs and a few cannot, the only those few are at risk of ND Address Resolution spoofing attacks.
        </t>
      </section>
    </section>
    
    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on various subjects related to the security of Voucher-Based Addresses.
        It also serves to clarify certain VBA processes or tangential protocol-related topics that may not have
        had adequate exploration in the rest of this document.
      </t>

      <section anchor="summary-overview-collisions">
        <name>Address Collisions</name>
        <t>
          VBA derivation only preserves 48 bits from a resultant hash. While a collision is unlikely, nodes treat
          this as they do the Duplicate Address Detection process: even if it is unlikely, it is possible and MUST
          be handled appropriately.
        </t>
        <t>
          Potential hash collisions expose a weakness of Voucher-Based Addressing. VBAs inherently bind 
          link-layer addresses upward to interface IP addresses through a deterministic process and nothing else
          -- i.e., there is no other mechanism used for certifying the resultant addresses. Thus, any other spoofable
          link-layer identifier producing the same 48-bit 'H' portion of the address suffix will result in an
          equally valid address according to the verification process.
        </t>
        <t>
          The employment of cryptographic KDFs drastically reduces the capacity for would-be attackers to discover
          address collisions and use them for malicious purposes (i.e., on-path attacks). Section 3 of <xref target="RFC8018"/>
          outlines a Key Derivation Function in the exact manner it intends to apply to this specification:
        </t>
        <blockquote>
            Another approach to password-based cryptography is to construct key
            derivation techniques that are relatively expensive, thereby
            increasing the cost of exhaustive search.  One way to do this is to
            include an iteration count in the key derivation technique,
            indicating how many times to iterate some underlying function by
            which keys are derived.
        </blockquote>
        <t>
          Thus KDFs are applied to VBAs for the added purpose of slowing collision discoveries. This same tradeoff
          of requiring slightly more time for address computation in order to protect against brute-force enumeration
          is a strategy also utilized by myriad password storage systems to protect user secrets (<!-- ref -->).
        </t>
        <t>
          To prevent any time-memory tradeoff attacks, the Link Voucher is distributed between nodes to ensure that
          generated addresses are always generously salted by a 128-bit pseudo-random value, as well as the subnet
          prefix, so they can never be pared down to a simple dictionary attack. This same value from the Link Voucher
          also rotates occasionally to prevent long-term attacks.
        </t>
        <t>
          An attacker searching for inputs producing a colliding address is therefore subjected to the misery of enumerating
          many different link-layer addresses in order to generate an IP address that matches the target's 48-bit hash suffix.
          This spoofed IP address must also embed the same iterations count as its target because it needs to be an equivalent
          IP. If the target IP address contains a high iterations count, then this searching process will be even slower and
          more unlikely to be successful. All the while, these collision-producing inputs must be obtained before the rotation
          of the Link Voucher seed, which will reset the attacker's marathon entirely.
        </t>
        <t>
          Link Vouchers also allow the specification of required on-link KDF algorithms and difficulties. This permits a
          dynamic adjustment of the base computation time required to derive or verify a VBA. For example, adjusting computation
          time to be approximately 20 milliseconds per address for the least powerful network node, and an estimated 1
          millisecond for the fastest, produces a negligible delay in processing legitimate Neighbor Discovery messages
          for all hosts. Simultaneously, this theoretical time taken to compute each address hamstrings any node,
          regardless of computing power, from being able to compute collisions expeditiously. This guarantees
          responsiveness while also protecting node address ownership.
        </t>
        <t>
          Following the above example, 1-millisecond address generation times for the most powerful on-link hosts
          equates to trying a mere 1,000 variable link-layer identifiers per second (3,600,000 addresses per hour). If
          the link-layer identifier in this case were a MAC address, 3.6M tried MAC addresses is equivalent to about a
          millionth of a percent of all possible addresses (2<sup>48</sup> when not accounting for reserved MAC addresses).
        </t>
      </section>

      <section anchor="summary-overview-adversaries">
        <name>Concerning Adversaries</name>
        <t>
          In an ideal network, VBA deployments would be unnecessary for the purpose of securing address ownership. One sample
          trust model which may disregard VBA verifications is a small enterprise network wherein all link-layer-address-to-IP
          bindings are entered statically. Another might be a private home network, where on-path attackers are very unlikely
          to be lurking.
        </t>
        <t>
          Address ownership applications notwithstanding, VBAs still offer a locally-verifiable manner of producing private
          unicast addresses which share no potential correlation in user activity between rotations. Such a method might find
          its own specific utilizations in other IPv6 protocols, the deployment of which could be easily adapted into support
          for this specification's address ownership mechanisms when are where such proof of ownership becomes necessary.
        </t>
        <t>
          The design choices for this specification cooperate to grant both: (1) a brute-force-resistant solution to IP
          address ownership in local networks, and (2) a deterministic generation of rotatable, privacy-focused addresses
          bound to link-layer identifiers. Item 2 is achieved as a byproduct of the VBA generation procedure, but Item 1
          requires some modifications to the way Neighbor Discovery functions; in particular, it places greater emphasis
          on guarding the Neighbor Cache.
        </t>
        <t>
          The application of VBAs against adversaries must be explored from a broad perspective before protocol
          specificities are introduced. Notably, this exploration assumes a hypothetical VBA deployment that is using the
          AGV Interface Enforcement Mode to enact full, strict protections on IP address ownership
          (<xref target="summary-interfaces-mode"/>).
          With the context of the design goals of this document, of various NDP problem statements (Section 4 of
          <xref target="RFC3756"/>), and of IPv6 address privacy concerns (<xref target="RFC8064"/>):
          consider how Voucher-Based Addressing either proposes a resolution for a potential issue or encounters a
          drawback.
        </t>

        <section anchor="summary-overview-adversaries-false">
          <name>Falsifying Neighbor Discovery Messages</name>
          <t><tt>Sending Neighbor Advertisements or Solicitations with false link-layer addresses.</tt></t>
          <t>
            The sender of a NS can use a false Source Link-Layer Address option, while the sender of a NA can use a false
            Target Link-Layer Address option. Since NDP specifies optimizations or instructions to enter these into the Neighbor
            Cache on receipt (without verification), the protocol becomes vulnerable to abuse.
          </t>
          <t>
            VBAs on-link are a way to force this purported binding in NA/NS packets to be verified. This specification
            dictates that any cache-affecting ND instruction, or optimization to automatically accept link-layer address options,
            be shimmed with the VBA verification process first. NDP packets which fail VBA verification are subsequently
            dropped and do not update the Neighbor Cache.
          </t>
        </section>

        <section anchor="summary-overview-adversaries-nud">
          <name>Prolonging Attacks &amp; Lies</name>
          <t><tt>Asserting a false link-layer address in Neighbor Unreachability Detection packets.</tt></t>
          <t>
            Malicious nodes can extend impersonation attacks against the target node by responding to NUD probes in order
            to indicate continued reachability. Again, with VBAs this attack is not possible because of the imposed verification
            requirements. If a NUD probe detects any change in address bindings -- i.e., the malicious node responds with
            an IP or link-layer address that is different from the original cache entry -- the target node will drop the packet
            and will not update nor refresh its Neighbor Cache with the unverified information.
          </t>
        </section>

        <section anchor="summary-overview-adversaries-correlate">
          <name>Tracking Address or Device Activity</name>
          <t><tt>Correlating unicast address activities long-term on the public internet.</tt></t>
          <t>
            <xref target="RFC8064"/> discusses four primary problems of deriving IP addresses from link-layer identifiers:
            network activity correlation, location tracking, address scanning, and device-specific vulnerability exploitation.
            The applicability of this discussion, however, only applies to addresses from which ANY off-link node can derive
            the link-layer identifier directly. VBAs are created using an irreversible hashing function, and therefore
            link-layer identifiers are not recoverable by off-link nodes.
          </t>
          <t>
            Stable VBAs do not truly exist unless the Link Voucher on-link is also stable. In such a case, addresses being
            generated by the VBA derivation process are still considered statistically random. Nodes employing these addresses
            also have the choice to choose a different iterations count embedded within their addresses, changing them at-will
            despite the stable Link Voucher details.
          </t>
        </section>

        <section anchor="summary-overview-adversaries-kill">
          <name>Forcing Neighbors Offline</name>
          <t><tt>Nodes who are 'killed' or go offline are impersonated.</tt></t>
          <t>
            When a node goes offline, there is no consequence for a malicious node spoofing its link-layer identifier. This
            is a problem for this specification and for any other address ownership methodology relying on link-layer address
            bindings. It is indeed where more convoluted solutions relying on asymmetric cryptography, like Cryptographically
            Generated Addresses <xref target="RFC3972"/>, tend to thrive by certifying addresses NOT coupled to any link-layer
            attributes.
          </t>
          <t>
            VBA address ownership mechanisms are designed primarily to prevent active, TRANSPARENT spoofing; that is,
            to stop the interception of traffic between two online links without disrupting traffic between either party.
            As mentioned previously, VBAs do NOT certify link-layer address bindings, and they are based on the
            principle that two link-layer devices CANNOT share the same identifier at the same time. Certifying addresses
            or using other monitoring technologies to detect when nodes are 'killed'/spoofed at the link layer are topics
            beyond the scope of this specification.
          </t>
          <t>
            A point of emphasis about VBAs in this regard is their ability to control NDP traffic redirection attacks, without
            relying on a trust model that uses MAC address filtering or something similar. VBAs assume the network is always open
            to any link-layer address, and they aim to prevent the openness of the link-layer from being abused to spoof Neighbor
            Cache entries and to redirect Address Resolutions.
          </t>
          <t>
            To enforce long-term ownership in the face of this link-layer impersonation problem, Neighbor Discovery Sessions
            <!-- ref --> can be implemented as a complement to VBAs. See <xref target="security-sessions"/> for a deeper
            exploration of ND Sessions as applied to Voucher-Based Addressing.
          </t>
        </section>
      </section>

      <section anchor="security-usurp">
        <name>Hijacking or Desynchronizing Link Vouchers</name>
        <!-- Discuss de-sync in LV state as well: nodes in certain IEMs will NOT be able to communicate -->
        <t>
          Theft of the Voucher Bearer role can be achieved by a few different means based on the level of
          employed security in the local network. Without RA-Guard, false VBs are free to constantly advertise
          their own rogue LVs to other hosts. For hosts already on the network with an active LV, this is only
          a problem if VHAs in the LOVMA are not being used and the current LV expires. For hosts joining the
          network for the first time, there is an easy opportunity for an abuse of 'first-come-first-serve'
          trust.
        </t>
        <t>
          If the legitimate VB goes offline and is not able to transmit any updated LVs to the network, the
          current LV can expire. When a LV expires, the design of VBAs requires nodes to accept any incoming LV
          as providing direction and consensus for the nodes on-link. If a malicious host uses other denial of
          service methodologies to force the current VB offline for long enough, the malicious host can force an
          expiration of the current LV and gain control of it.
        </t>
        <t>
          Another less feasible -- but not impossible -- attack would involve theft of the cryptographic private
          key associated with the current LV. Any compromise of the voucher key will result in directly impersonable
          LVs or VHAs that would not be questioned by any network node.
        </t>
        <t>
          Relatively short 'Expiration' windows for LVs are disallowed in LVs because of (1) possible time
          synchronization issues between nodes, (2) 'address storm' prevention, and (3) compensating for possibly
          slow VBs who cannot send LVs to the network fast enough. Most relevant to this section are 2 and 3.
          The 'address storm' prevention relying on this mechanism aims to stop malicious VBs from over-rotating
          the current LV and completely exhausting network nodes who will be very busy trying to keep up with
          VBA generation and verification optimizations. Compensating for a slow VB requires malicious nodes to
          force that same legitimate VB off the network for longer in order to usurp them as the link VB.
        </t>
        <t>
          Hijacking, tampering with, or otherwise desynchronizing the LV can be used for either malicious denial
          of service attacks or to set the difficulty of VBA computation to a very low threshold.
        </t>
        <ul>
          <li>
            Denial of service attacks could result from setting LV parameters to an excessive difficulty. By
            asking local nodes to verify and generate according to absurd KDF demands, even for low iterations
            counts chosen on each host, outrageous amounts of computing power could be wasted on node interfaces.
            This could potentially bind up enough resources on a node to disconnect it from the network entirely.
          </li>
          <li>
            Consider a situation where Group<sub>A</sub> represents hosts aware of legitimate LV<sub>A</sub> and
            Group<sub>B</sub> represents hosts aware of malicious LV<sub>B</sub>. Having multiple LVs active on the
            same link will inevitably lead to different logical subnetworks, where Group<sub>A</sub> hosts are 
            generating and verifying VBAs according to a completely different LV than Group<sub>B</sub>. Depending
            on per-interface IEMs, hosts from one group will be completely barred from communicating with hosts in
            another.
          </li>
          <li>
            Malicious VBs could transmit an LV dictating use of a KDF algorithm with very minimal requirements. For
            example, PBKDF2_SHA256 with an ITERATIONS_FACTOR of 1. Targeting hosts with low iterations counts would
            of course be most efficient for discovering a valid link-layer identifier that produces an address
            collision. Weakening the entire subnet in this way affords the attacker a greater advantage by greatly
            reducing the computation costs of on-path attacks.
          </li>
        </ul>
        <t>
          All of the concerns in this section allude to the importance of guarding the local network from rogue
          LV options in the first place. Though on-path attacks are still LESS feasible with VBAs enabled, regardless
          of LV control, that still does not outweigh the risks assessed above. <xref target="bearers-vigilance"/>
          has more information about RA-Guard and protecting against the rogue LV problem.
        </t>
        <t>
          Other solutions for (1) denial of service attacks disconnecting the current VB from the network, and for
          (2) the deployment of accurate and VBA-aware intrusion detection systems, are beyond the scope of this
          document.
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
          This document is primarily tasked to counter on-path attacks in local networks. Mitigation of NDP denial of service
          attacks is therefore an auxiliary goal that could be achieved by applying other protocols. Placing the burden of
          resolving these problems onto this specification could reduce its flexibility and applicability by forcing it to
          apply these mitigation strategies, rather than leaving them as optional.
        </t>
        <t>
          This brief section discusses concerns about potential denial of service attack vectors when employing VBAs. When a
          topic is presented without a solution, it is STRONGLY IMPLIED that the implementation of this protocol SHOULD find
          another way to mitigate the problem, or at least maintain an awareness of the weakness during development.
        </t>

        <section anchor="security-dos-ns-floods">
          <name>Neighbor Solicitation Flooding</name>
          <t>
            Section 4.3.2 of <xref target="RFC3756"/> outlines an attack targeting last-hop routers that inundates a network
            with traffic destined to on-link hosts which do not exist. VBAs do not suffer from this attack vector or from any
            situation involving creation of repeated NS packets, as there is no extra cost incurred in creating them.
          </t>
          <t>
            When a VBA-enabled node is receiving a flood of NS packets rather than sending them, particularly if the NS
            packets contain spoofed SLLAOs, then the node may be forced to compute a large volume of verifications in a short
            interval. This could easily lead to resource exhaustion if the LV parameters specify a more difficult set of KDF
            parameters.
          </t>
          <t>
            A malicious node may also initiate a series of connections from bogus IP addresses that demand return traffic at higher
            layers of the network stack, such as TCP SYN floods. This would necessitate that the target of the attack engages in NDAR
            to determine the LLIDs of the supposed initiating IPs, if the LLIDs were not provided in NS SLLAOs. If the bogus initiating
            IPs use high IC values, then the influx of work in the verification process could quickly exhaust resources on the target.
          </t>
          <t>
            This document does not formulate a mitigation for this type of attack, as VBA is primarily concerned with verifying
            purported address bindings according to the standard ND behavior, and further protocol constraints might hinder any
            chance of adoption.
          </t>
        </section>

        <section anchor="security-dos-na-floods">
          <name>Neighbor Advertisement Flooding</name>
          <t>
            Neighbor Advertisement floods, either with (1) randomized target addresses and Target Link Layer Address options
            or (2) randomized Target Link-Layer Address options for a known target address, will not affect VBAs and the address
            verification process for enforcing interfaces. VBA NC behavior for NAs does not generally permit an Override to affect
            a NC entry, nor do NAs affect cache entries which are beyond the INCOMPLETE state.
          </t>
          <t>
            A more effective attack vector is listed in the previous section. Falsified incoming connections could "bait" a target
            into sending many NS packets, each of which an attacker could reply to with a bogus, high-iteration VBA to verify.
          </t>
        </section>

        <section anchor="security-dos-others">
          <name>Others</name>
          <t>
            Other classic ND vulnerabilites for denial of service also apply to this protocol because of its goal aiming to NOT
            significantly amend NDAR. Many of these concerns can be found in <xref target="RFC3756"/>.
          </t>
        </section>

        <section anchor="security-dos-overrotate">
          <name>Over-rotation of Link Vouchers</name>
          <t>
            Large local networks might have thousands of devices on the same logical link using NDP to resolve each others' LLIDs
            from IP addresses. When a network is of this size and the LV is handed off to another through the election process,
            optimizations for low-power nodes could get excessively costly when attempting to pre-generate anticipated VBAs according
            to the new LV parameters. To reduce this burden, implementations MAY choose to either limit their optimizations at a
            certain cache size or pre-generate VBAs only for the most recently contacted, high-traffic nodes on the link. 
          </t>
        </section>
      </section>

      <section anchor="security-fairness">
        <name>Computational Fairness</name>
        <t>
          The selection of an appropriate Key Derivation Function is essential to scale the difficulty of
          discovering hash collisions. The choice of KDF is also essential for the notion of fairness in
          computing the generated result. As described in <xref target="addenda-voucher-kdfs"/>, choosing a
          CPU-bound KDF algorithm is significantly more likely to result in very disparate computation times
          than choosing a Memory-bound KDF for VBA-related calculations. <!-- ext ref -->
        </t>
        <t>
          Even when using memory-bound KDFs like Argon2d, the proper delegation of baseline algorithm
          parameters in the Link Voucher SHOULD always tend toward being more forgiving for low-power or
          embedded systems. The balance of low compute latencies with high security might be difficult to
          determine, but implementations SHOULD attmept to discover and apply defaults that achieve this goal.
        </t>
      </section>

      <section anchor="security-static">
        <name>Static Addresses</name>
        <t>
          Networks requiring a mix of ephemeral addresses along with static, stable, long-term addresses might
          encounter difficulties deploying and maintaining VBAs. Preserving the state of a local LV long-term
          will not be feasible to maintain stable addresses, as long-term LVs lend themselves to the malicious
          discovery of address collisions.
        </t>
        <t>
          Assigning long-term addresses to hosts on a VBA-enabled network can be accomplished using a few approaches:
        </t>
        <ul>
          <li>
            <t>
              Use the AGVL IEM (<xref target="summary-interfaces-mode"/>) on either the whole subnet, or on interfaces
              known to interact with the target static address(es) directly. The AGVL IEM will permit per-implementation
              behaviors to strongly prefer Secured NDP resolutions over Unsecured ones. Note that this option will remove
              any guarantees of address ownership or on-path attack prevention from the static address(es).
            </t>
            <t>
              It is not necessary to set AGVL on the interfaces with static addresses (unless such interfaces also interact
              with other local static addresses), because IEM affects neighbor verifications and does not impose restrictions
              on statically-assigned local interface addresses.
            </t>
          </li>
          <li>
            <t>
              If local nodes simply do not interact with the static addresses, then the only affected parties are the node(s)
              with the static assignments and the subnet router, which will ostensibly route traffic to and from the static
              address(es). Most Router Advertsements will specify a link-local address as the subnet gateway: if this is the
              case within the subnet, then only router-to-host traffic will fail verification. This is because the router needs
              to be aware of the link-layer identifier corresponding to the static address, but the host forwarding to the
              router can always safely verify using the router's link-local VBA.
            </t>
            <t>
              Therefore, a static entry in the Neighbor Cache of the router should correlate link-layer identifier(s) to the
              static IP address(es) on each host. Doing this for each long-term static address will mitigate any potential
              on-path attacks for both neighbors exchanging packets, while still ensuring all other ND Address Resolutions
              verify according to VBA rules and the level of strictness configured on each network interface.
            </t>
          </li>
          <li>
            Simply use static Neighbor Cache entries across the whole subnet, wherever interactions with the static addresses
            may be required. The use of static NC entries may alleviate the requirement for VBAs at all, however, depending on
            how and where these static addresses are set in the first place. This approach assumes the link-layer identifier of
            each interface carrying one or more static addresses is also stable and unchanging.
          </li>
        </ul>
      </section>

      <section anchor="security-anycast">
        <name>Anycast Addresses</name>
        <t>
          Anycast addresses are allocated from the unicast address space and are thus indistinguishable to
          nodes establishing connections to them. NDP exchanges with these hosts may therefore respond with
          varying Target Link-Layer Address options and cause VBA verification to be unreliable.
          For this reason, it is NOT RECOMMENDED to utilize anycast addresses for on-link prefixes within
          VBA-enabled networks, because the ownership of the address cannot be bound to a particular
          link-layer identifier.
        </t>
        <t>
          The IPv6 Addressing Architecture RFC (<xref target="RFC4291"/>) outlines a Required Anycast Address
          in Section 2.6.1. VBA-enabled links SHOULD maintain compatibility with this requirement by disabling
          verification for on-link subnet anycast addresses. For example, a host using SLAAC to generate an
          address in the subnet 2001:db8:700::/64 SHOULD disable VBA expectations and verifications for the
          address 2001:db8:700::. Because VBA protections must be disabled for this target host, implementations
          SHOULD avoid using the subnet Required Anycast Address altogether.
        </t>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        This document defines two new Neighbor Discovery Protocol option types and one new link-local multicast
        address. One of the NDP option types contains another set of Type-Length-Value (TLV) packet options.
        The multicast address also uses other assigned TLV packets to convey important (but optional) protocol
        information.
      </t>
      <t>
        Two new Neighbor Discovery Protocol options are defined in this document and must have new Option Type
        values assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet Control
        Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Link Voucher option (63), described in <xref target="addenda-voucher"/>.</li>
        <li>The Voucher Summary option (64), described in <xref target="addenda-summary"/>.</li>
      </ul>
      <t>
        The Link Voucher option includes a new option type used to convey KDF algorithm selections.
        Assigned in the "Algorithm Type Options" subregistry are string identifiers corresponding to integers 
        which indicate their Algorithm Type values. Future values MUST be assigned according to the Standards
        Action policy of <xref target="RFC8126"/>. Default registrations are defined in this document:
      </t>
      <table anchor="IANA-algo-type-registrations">
        <name>Initial Values of the "Algorithm Type Options" Subregistry</name>
        <thead>
          <tr>
            <th>Type</th>
            <th>Name/Identifier</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td>VBAKDF_PBKDF2_SHA256</td>
          </tr>
          <tr>
            <td>10</td>
            <td>VBAKDF_ARGON2D</td>
          </tr>
          <tr>
            <td>20</td>
            <td>VBAKDF_SCRYPT</td>
          </tr>
        </tbody>
      </table>
      <t>
        See <xref target="lovma"/> for information about the Local On-link Voucher Multicast Address subscribed
        to by VBA-enabled network interfaces. This section will also contain specific packet formats.
      </t>
      <t>
        Assigned in the "Link-Local Scope Multicast Addresses" subregistry of the "IPv6 Multicast Address Space
        Registry":
      </t>
      <blockquote>
        Address(es): FF02::ABBA<br />
        Description: Local On-link Voucher Multicast Address<br />
        Reference: draft-puhl-6man-ndp-vba-00
      </blockquote>
      <t>
        The well-known UDP port 2196 is used for multicast traffic on the LOVMA channel. Assigned in the "Service
        Name and Transport Protocol Port Number Registry":
      </t>
      <blockquote>
        Service Name: vba_lovma<br />
        Port Number: 2196<br />
        Transport Protocol: UDP<br />
        Description: IPv6 Voucher-Based Addressing LOVMA updates<br />
        Reference: draft-puhl-6man-ndp-vba-00
      </blockquote>
      <t>
        A set of three TLV packet types used specifically in the new LOVMA channel are defined in this document.
        Assigned in the "LOVMA Message Types and Options" subregistry of the "Voucher-Based Addressing (VBA)
        Parameters" registry.
      </t>
      <t>
        The values in the "LOVMA Message Types and Options" subregistry are string identifiers corresponding
        to integers which indicate their packet Type values. Future values MUST be assigned according to the Standards
        Action policy of <xref target="RFC8126"/>. Default registrations are defined in this document:
      </t>
      <table anchor="IANA-lovma-registrations">
        <name>Initial Values of the "LOVMA Message Types and Options" Subregistry</name>
        <thead>
          <tr>
            <th>Type</th>
            <th>Name/Identifier</th>
            <th>Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td>LOVMA_VSR</td>
            <td><xref target="lovma-packets-vsr"/></td>
          </tr>
          <tr>
            <td>2</td>
            <td>LOVMA_VCI</td>
            <td><xref target="lovma-packets-vci"/></td>
          </tr>
          <tr>
            <td>3</td>
            <td>LOVMA_VHA</td>
            <td><xref target="lovma-packets-vha"/></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor="future">
      <name>Future Work</name>
      <t>
        This section provides an overview of adjacent topics that might be explored in future work related to
        this document.
      </t>

      <section anchor="security-dhcp">
        <name>Deployments using DHCP</name>
        <t>
          DHCP is not mentioned elsewhere in this document because VBAs are designed primarily for SLAAC-based environments.
          However, future work might wish to add features into DHCP servers that support VBAs, using something like DHCP
          Snooping to ensure only legitimate servers are giving out addresses. Because of its centrality and responsibility,
          a DHCP server would also function well as the link VB if the link router does not support this specification.
        </t>
        <t>
          One notable change of generating VBAs on the server-side is the ability for client nodes to self-determine an
          interations count value dynamically is no longer available. Allowing nodes to choose their own ICs affords them
          the ability to (1) randomize the value according to their own implementation and (2) preserve a Preferred IC (see
          <xref target="lovma-packets-vsr"/> about VSRs).
        </t>
        <t>
          In a future proposal, DHCP client options might be amended to allow a client to request a certain 'security level'
          or IC dynamically. Such an option could also present an opportunity to exchange other information about client
          preferences or other important VBA details.
        </t>
      </section>

      <section anchor="security-proxies">
        <!-- See RFCs 4389 & 5909 -->
        <name>Neighbor Discovery Proxies</name>
        <t>
        </t>
      </section>

      <section anchor="security-pki">
        <name>Certifying Link Vouchers</name>
        <t>
          Link Vouchers are susceptible to impersonation despite the use of asymmetric cryptography in signing their
          details. Once a host becomes aware of a valid public-key and signature, it becomes "locked" to this key and
          will not accept LVs from senders NOT using it in their signatures (unless the current LV expires or a VHA is
          issued). However, the initial exchange -- or first-contact -- between a VB and a neighbor is still vulnerable.
          This is because any malicious node on-link could craft a public key for its own LV and advertise it, if the
          node is not first blocked by infrastructure-based solutions like RA-Guard.
        </t>
        <t>
          Section 6 of <xref target="RFC3971"/> dictates the use of Public Key Infrastructure to ensure communication
          is genuine between hosts and routers, and that each router is authorized to provide router information. Trust
          anchors are used to determine whether a certificate presented by a router validates its role in SEND: if the
          router presents a certificate that is trusted by the anchor, then on-link hosts sharing the same trust anchor
          must consider it as legitimate. The same validation of certification paths can also be used to verify RSA
          Signature options between on-link hosts.
        </t>
        <t>
          Establishing certification paths that validate SEND traffic is done through the use of two new ICMP messages:
        </t>
        <ul spacing="compact">
          <li>Certification Path Solicitation (ICMP type 148). Solicits routers with a set of trust anchors and expects
            an advertisement including certificates authorized by one or more of the trust anchors.</li>
          <li>Certification Path Advertisement (ICMP type 149). Routers use these to respond to valid solicitations
            indicating the need for one or more certificate(s) from a set of specified Trust Anchor options.</li>
        </ul>
        <t>
          Future additions to this specification MAY invoke these ICMP options to integrate with public-key signatures
          appearing on Link Vouchers. This might include amendments to the ND Link Voucher option which would extend the
          field by some extra length to convey trust anchor or certification path information. Similar amendments might
          just consider adding trust anchor or certification path information to LVs and letting each neighbor use their
          own certificate stores to validate them.
        </t>
        <t>
          While this proposal seeks to AVOID the complexities introduced by certificates and trust anchors, this same
          supporting infrastructure might be crucial for first-contact trust assurance where RA-Guard or similar mechanisms
          cannot be used to protect the link from malicious VBs. This is probably a much more performant use of certification
          paths than SEND, simply because the trust of a public key only needs to be verified ONCE at each receiver when an
          initial LV, or LV handoff, is received and stored.
        </t>
        <t>
          Such an amendment to LV options is beyond the scope of this document. It is suggested as a possible future endeavor
          that could make VBAs a more secure, isolated, and end-to-end solution, instead of a specification which relies on
          first-come-first-serve trust.
        </t>
      </section>

      <section anchor="security-sessions">
        <name>Integrating Neighbor Discovery Sessions</name>
        <t>
          As noted in <xref target="summary-overview-adversaries-kill"/>, VBAs are vulnerable to Identity Assumption
          attacks where an active link-layer-address-to-IP binding could be hijacked by malicious hosts. This is
          accomplished by denying connectivity to the legitimate host owning a link-layer address, then assuming its
          link-layer address in its absence. The malicious host can then intercept all frames destined for the original
          node WITHOUT needing to perform a classic traffic redirection attack.
        </t>
        <t>
          Networks using SEND can also experience Identity Assumption attacks, but only in the short-term because SEND
          relies on CGAs <xref target="RFC3972"/> to enforce knowledge of a private cryptographic key in ND messages. SEND
          itself declares this problem in Section 9.1 <xref target="RFC3971"/>.
          When a new request for ND arrives -- such as during the NUD process -- impersonating nodes will not be able to sign
          ND responses because they do not know the original private key. These concerns are more considerable for VBAs than
          SEND for this very reason: VBAs do NOT require knowledge of some private value that is publicly verifiable.
        </t>
        <t>
          ND Session options <!-- ref --> are used to exchange session details using Zero-Knowledge
          Password Proof (ZKPP) techniques. These options do not interfere with the VBA verification process between two
          nodes, and act to further bolster confidence in neighbor verification over a long-term session. ZKPP allows a
          node to express knowledge of a particular password without exposing the password itself; this typically happens
          through a clever hashing mechanism known as 'reverse hash chain revealing'.
        </t>
        <t>
          An ND Session is a long-term exchange bound to one single instance of Address Resolution between a set of link-layer
          addresses and IP addresses. Changing any of those four variables will necessitate a new Session be formed. A per-session,
          random password is chosen on each session node, whose hash value is repeatedly iterated with a salt value consisting of
          session variables and then given to the session peer. Nodes can prove knowledge of their initial passwords in each ND
          message by slowly revealing each one-time-use 'ancestor' hash in the iteration chain, going back to the Root Hash. See
          the specification <!-- ref --> for more information about its inner workings.
        </t>
        <t>
          ZKPP-based sessions therefore provide strong protection against Identity Assumption attacks occurring in the middle
          of a communication between two neighbors. They are still susceptible to impersonations at the very start of the ND
          Session, but this would require a very opportunistic and reactive attacker, since Sessions can last up to days at a time
          without any update. Implementing ND Session options with VBAs, then, simply shims the ND Address Resolution process with
          Session options. Such implementations SHOULD always validate the underlying session BEFORE processing any VBA verifications.
        </t>
        <t>
          To summarize, ND Sessions reassure two communicating neighbors of each others' persistent identities; on-path attackers
          will not be able to provide ZKPP. Similarly, VBAs provide the link-layer-address-to-IP binding which enforces Address
          Resolutions always return the correct link-layer addresses for target IPs.
          ND Sessions MAY be integrated with VBAs, but are not a requirement and in practice will almost certainly add both
          extra complication and extra latency to ND Address Resolution exchanges. These are again considered a trade-off
          for allowing ND verifications to be end-to-end, instead of something requiring complex implementations or network
          infrastructure to be deployed.
        </t>
      </section>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3972.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6105.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7721.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6104.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7217.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3756.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8064.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8981.xml"/>
        <!-- Default KDF Definitions -->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8018.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9106.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7914.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4429.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7527.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9131.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.768.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5758.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6555.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3279.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4301.xml"/>
        <reference anchor="ITU.X690.2002" target="https://www.itu.int/rec/T-REC-X.690">
          <front>
            <title>Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER),
              Canonical Encoding Rules (CER), and Distinguished Encoding Rules (DER)</title>
            <author>
              <organization>International Telecommunications Union</organization>
            </author>
          </front>
        </reference>
      </references>
      <!-- <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
          </front>
        </reference>       
      </references> -->
    </references>

    <section anchor="appendix-code">
      <name>Code Snippets</name>
      <t>
        This section contains various code snippets used to provide example implementations of certain
        features specified in this document. All code is written in C, and some external dependencies,
        such as Argon and Scrypt development libraries, are assumed as being present on the compiling
        machine.
      </t>

      <section anchor="appendix-code-generation">
        <name>Address Generation Sample</name>
        <figure>
          <name>Sample Address Generation Code in C</name>
          <sourcecode type="c" markers="false" name="vbaGeneration.c">
            <![CDATA[
uint64_t compute_address_suffix(link_voucher_t *lv,
                                uint8_t *mac_address,
                                uint16_t iterations)
{
    /*
     * Initialize a storage buffer for the resulting hash.
     *   All hashes will be requested at 32 bytes in length,
     *   despite the algorithm only using the leading 64 bits.
     */
    size_t res_buffer_size = 32;
    uint8_t res_buffer[32] = {0};

    /*
     * The 'password' is always the 128-bit voucher seed. The salt
     *   is a combination of a LLADDR (MAC in this case) + 'vba'
     *   + the 64-bit subnet prefix (or left-most 64 bits of the
     *   unicast address that will be built). This example uses
     *   "fe80::" for the subnet prefix.
     *   All values are big-endian (network byte order).
     */
    uint8_t salt[VOUCHER_SALT_LENGTH_MAC] = {
            /* MAC (6 bytes) */
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            /* Static 'vba' (3 bytes) */
            'v', 'b', 'a',
            /* Subnet prefix (8 bytes */
            0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    memcpy(&salt[0], &mac_address[0], 6);
    /* memcpy(&salt[9], &subnet_prefix[0], 8); */

    /* In this case, the 'algo' member is a union. */
    switch (lv->algo->type) {
        case PBKDF2:
            PKCS5_PBKDF2_HMAC(lv->seed,
                              VOUCHER_SEED_LENGTH,
                              salt,
                              VOUCHER_SALT_LENGTH_MAC,
                              iterations * lv->algo->pbkdf2_factor,
                              EVP_sha256(),
                              res_buffer_size,
                              res_buffer);
            break;
        case ARGON2:
            argon2d_hash_raw((iterations >> 8) + 1,
                             lv->algo->argon_mem_size,
                             lv->algo->argon_parallelism,
                             lv->seed,
                             VOUCHER_SEED_LENGTH,
                             salt,
                             VOUCHER_SALT_LENGTH_MAC,
                             res_buffer,
                             res_buffer_size);
            break;
        case SCRYPT:
            /* https://www.tarsnap.com/scrypt.html */
            libscrypt_scrypt(lv->seed,
                             VOUCHER_SEED_LENGTH,
                             salt,
                             VOUCHER_SALT_LENGTH_MAC,
                             max(1 << (iterations & 0x00FF), 2)
                                 << lv->algo->scrypt_scaling, /* N */
                             max((iterations & 0xFF00) >> 4, 16)
                                 << lv->algo->scrypt_scaling, /* r */
                             SCRYPT_PARALLELIZATION,   /* p */
                             res_buffer,
                             res_buffer_size);
            break;
        default:
            fprintf(stderr, "Unknown algorithm type.\n");
            return -1;
    }

    /* Always use the first 64 bits of the resulting hash. */
    uint64_t hash_H = *((uint64_t *)&res_buffer[0]);

    /* Get the first two bytes of the current Link Voucher seed. */
    uint16_t first_seed_hextet = *((uint16_t *)&lv->seed[0]);
    
    /* Compute the 'Z' value and overwrite the first
        hextet of hash 'H' with it to form SUFFIX. */
    return ((uint64_t)~(iterations ^ first_seed_hextet) << 48)
             | (0x0000FFFFFFFFFFFF & hash_H);
}
            ]]>
          </sourcecode>
        </figure>
      </section>

      <section anchor="appendix-code-verification">
        <name>Address Verification Sample</name>
        <t>
          This snippet references methods from the Address Generation code in the above section.
        </t>
        <figure>
          <name>Sample Address Verification Code in C</name>
          <sourcecode type="c" markers="false" name="vbaVerification.c">
            <![CDATA[
bool verify_address_suffix(uint64_t suffix,
                           link_voucher_t *lv,
                           uint8_t* mac_address)
{
    /* First extract the 'L' value from 'Z' in the input SUFFIX. */
    uint16_t first_seed_hextet = *((uint16_t *)&lv->seed[0]);
    uint16_t iterations =
        (uint16_t)((~(suffix ^ first_seed_hextet) >> 48) & 0xFFFF);

    /* Now independently compute SUFFIX like the generator does. */
    uint64_t computed_suffix = compute_address_suffix(lv,
                                                      mac_address,
                                                      iterations);

    /* If the independent calculation yields the same suffix as the
        input, then the binding for this LV is legitimate. */
    return computed_suffix == suffix;
}
            ]]>
          </sourcecode>
        </figure>
      </section>
    </section>

    <section anchor="appendix-speed">
      <name>Testing Address Generation Speeds</name>
      <t>
        Three tables below the performance statistics of VBA generation across the three different KDFs supplied in this document.
        All tables show the mean values of address generation times across three different mid-tier devices (each having a GPU available).
      </t>
      <t>
        The runtime parameters of each VBA KDF were set at HIGH DIFFICULTIES for these tests. They were as follows:
      </t>
      <ul>
        <li><tt>PBKDF2_SHA256</tt>: an <tt>ITERATIONS_FACTOR</tt> of 256.</li>
        <li><tt>Argon2d</tt>: a <tt>MemorySize</tt> of 2,048 and a <tt>Parallelism</tt> of 32.</li>
        <li><tt>Scrypt</tt>: a <tt>SCALING_FACTOR</tt> of 5 (the maximum value permitted).</li>
      </ul>
      <t>
        The results in this section show that increasing the iterations count 'L' results in a somewhat linear order of increasing
        difficulty, except the Scrypt algorithm, which seems to flatten and taper toward the upper iterations range. Assumptions
        can be made of expected computation times relative to iterations counts, scaled up or down to certain difficulty levels.
      </t>
      <t>
        NOTE: these three table ARE NOT related to one another, nor should they be read comparatively -- parameters were
        chosen arbitrarily from an upper difficulty range for each KDF to evaluate their performance on mid-tier hardware.
        Address verification uses the same results because its process is synonymous to generation, so this benchmarking
        process is NOT repeated for VBA verification in this document.
      </t>

      <section anchor="appendix-speed-pbkdf2">
        <name>PBKDF2_SHA256</name>
        <table anchor="speed-pbkdf2">
          <name>Speed of Demanding PBKDF2_SHA256 Address Generation</name>
          <thead>
            <tr>
              <th>Iterations 'L'</th>
              <th>Time (ms)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>8,192</td><td>477</td></tr>
            <tr><td>16,384</td><td>956</td></tr>
            <tr><td>24,576</td><td>1,462</td></tr>
            <tr><td>32,768</td><td>2,026</td></tr>
            <tr><td>40,960</td><td>2,463</td></tr>
            <tr><td>49,152</td><td>2,923</td></tr>
            <tr><td>57,344</td><td>3,474</td></tr>
            <tr><td>65,535</td><td>3,910</td></tr>
          </tbody>
        </table>
        <t>* This table actually iterates the PBKDF2_SHA256 algorithm by <tt>L &times; SCALING_FACTOR</tt> (in this case, 256).
          So the amount of iterations in the calculation is actually scaled.</t>
      </section>

      <section anchor="appendix-speed-argon2d">
        <name>Argon2d</name>
        <table anchor="speed-argon2d">
          <name>Speed of Demanding Argon2d Address Generation</name>
          <thead>
            <tr>
              <th>Iterations 'L'</th>
              <th>Time (ms)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>8,192</td><td>124</td></tr>
            <tr><td>16,384</td><td>249</td></tr>
            <tr><td>24,576</td><td>362</td></tr>
            <tr><td>32,768</td><td>488</td></tr>
            <tr><td>40,960</td><td>655</td></tr>
            <tr><td>49,152</td><td>745</td></tr>
            <tr><td>57,344</td><td>860</td></tr>
            <tr><td>65,535</td><td>998</td></tr>
          </tbody>
        </table>
      </section>

      <section anchor="appendix-speed-scrypt">
        <name>Scrypt</name>
        <table anchor="speed-scrypt">
          <name>Speed of Demanding Scrypt Address Generation</name>
          <thead>
            <tr>
              <th>Iterations 'L'</th>
              <th>Time (ms)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>8,192</td><td>261</td></tr>
            <tr><td>16,384</td><td>552</td></tr>
            <tr><td>24,576</td><td>851</td></tr>
            <tr><td>32,768</td><td>1,117</td></tr>
            <tr><td>40,960</td><td>1,501</td></tr>
            <tr><td>49,152</td><td>1,990</td></tr>
            <tr><td>57,344</td><td>2,055</td></tr>
            <tr><td>65,535</td><td>2,283</td></tr>
          </tbody>
        </table>
      </section>

      <section anchor="appendix-speed-minimums">
        <name>Testing KDFs at Their Minimum Difficulties</name>
        <t>
          And lastly, the same mid-tier devices were given the challenge to perform the address generation
          procedure, but with the KDF parameters set to their LOWEST possible difficulties.
        </t>
        <ul>
          <li><tt>PBKDF2_SHA256</tt>: an <tt>ITERATIONS_FACTOR</tt> of 1.</li>
          <li><tt>Argon2d</tt>: a <tt>MemorySize</tt> of 8 and a <tt>Parallelism</tt> of 1.</li>
          <li><tt>Scrypt</tt>: a <tt>SCALING_FACTOR</tt> of 0.</li>
        </ul>
        <table anchor="speed-minimums">
          <name>Address Generation Speeds at Minimum Parameters</name>
          <thead>
            <tr>
              <th>Algorithm</th>
              <th>Iterations 'L'</th>
              <th>Time (ms)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td rowspan="3">PBKDF2_SHA256</td><td>8,192</td><td>1.9</td></tr>
            <tr><td>32,768</td><td>7.4</td></tr>
            <tr><td>65,535</td><td>14.7</td></tr>
            <tr><td rowspan="3">Argon2d</td><td>8,192</td><td>0.1</td></tr>
            <tr><td>32,768</td><td>0.4</td></tr>
            <tr><td>65,535</td><td>0.8</td></tr>
            <tr><td rowspan="3">Scrypt</td><td>8,192</td><td>1.6</td></tr>
            <tr><td>32,768</td><td>5.8</td></tr>
            <tr><td>65,535</td><td>12.9</td></tr>
          </tbody>
        </table>
        <t>
          From this chart, it is clear that selecting the Argon2d KDF and setting its parameters as low as possible
          results in the fastest VBA computation time by approximately a whole order of magnitude, at least
          according to the tested devices. For environments seeking to deploy VBAs with the smallest possible verification
          and/or generation delays, this option will drastically outperform the others.
        </t>
      </section>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The author would like to thank Dr. Jinhua Guo of the University of Michigan for his valuable,
        constructive criticisms and support of this document.
      </t>
    </section>
  </back>
</rfc>
