<?xml version="1.0" encoding="utf-8"?>
<!-- 
     draft-rfcxml-general-template-standard-00
  
     This template includes examples of the most commonly used features of RFCXML with comments 
     explaining how to customise them. This template can be quickly turned into an I-D by editing 
     the examples provided. Look for [REPLACE], [REPLACE/DELETE], [CHECK] and edit accordingly.
     Note - 'DELETE' means delete the element or attribute, not just the contents.
     
     Documentation is at https://authors.ietf.org/en/templates-and-schemas
-->
<?xml-model href="rfc7991bis.rnc"?>  <!-- Required for schema validation and schema-aware editing -->

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-puhl-6man-ndp-vba-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  consensus="true"
  version="3">
  <front>
    <title abbrev="ndp-vba">IPv6 Voucher-Based Address Generation &amp; Verification</title>
    <seriesInfo name="Internet-Draft" value="draft-puhl-6man-ndp-vba-00"/>
    <author fullname="Zack Puhl" initials="Z." surname="Puhl">
      <organization>University of Michigan</organization>
      <address>
        <postal>
          <city>Detroit</city>
          <region>Michigan</region>
          <country>US</country>
        </postal>
        <email>zpuhl@xmit.xyz</email>  
        <email>zpuhl@umich.edu</email>  
        <uri>https://xmit.xyz/</uri>
      </address>
    </author>
    <date year="2024"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance</workgroup>
    <keyword>ipv6</keyword>
    <keyword>ndp</keyword>
    <keyword>vba</keyword>
    <keyword>spoofing</keyword>
    <keyword>privacy</keyword>
    <abstract>
      <t>
        This document specifies an extensible IPv6 unicast address generation and verification methodology for local
        networks. Individual link-layer identifiers are bound to sets of deterministic output addresses, which
        maintain user privacy regardless of link-layer identifier stability. Vouchers distributed by Router
        Advertisements on-link are used to form a consensus between neighbors of the parameters used in the address
        derivation process. Cryptographic key derivation functions are used to generate pseudo-random addresses and
        to stretch address computation times. Host parameters can be used to derive any number of both stable
        and ephemeral, privacy-focused addresses for each on-link prefix and at the link-local scope. NDP
        exchanges can then verify the interface-identifier-to-IP bindings to prevent on-path attacks in local
        networks.
      </t>
    </abstract>
  </front>


  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        Voucher-Based Addressing (VBA) offers an alternative solution to
        the address ownership problem, enables extensible and private unicast address generation, and prevents
        on-path attacks in IPv6 local networks. Using a mutual key derivation function to map input components
        one-to-one to output ciphertexts, link-layer identifiers can be reliably coupled to sets
        of deterministically generated IPv6 addresses and subsequently verified by neighboring nodes. All verifications
        are decentralized and do not require public-key cryptography; only shared consensus on a distributed,
        pseudo-random value used to seed the address generation procedure. The same deterministic algorithm produces
        IPv6 address suffixes appearing statistically random to devices outside the local broadcast domain, who
        are by design unaware of all input parameters associated with the address.
      </t>
      <t>
        This document represents an application of cryptographic key-stretching methodologies to IPv6 address
        generation. The result is a secure, high-impact, low-complexity change bundled with various transition
        capabilities, effectively corroborating IPv6 address ownership to defeat malicious network address spoofing.
      </t>
      <t>
        This document introduces Voucher-Based Addressing (VBA) in IPv6 networks as an optional functionality for Neighbor Discovery Protocol (NDP) <xref target="RFC4861"/>.
      </t>
      <t>
        VBAs operate on the principle that active spoofing requires the impersonation <!-- TODO -->
      </t>

      <section anchor="intro-binding">
        <name>Link-Layer Binding Considerations</name>
        <t>
        </t>
      </section>
      
      <section anchor="intro-requirements">
        <name>Specification of Requirements</name>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
          all capitals, as shown here.
        </t>
      </section>
    </section>

    <section anchor="terms">
      <name>Terminology</name>
      <!-- TODO -->
      <t>
        Many of the terms in this document are defined in Section 2.1 of the most current NDP standard <xref target="RFC4861"/>.
      </t>
      <t>
        An alphabetical glossary of terms related to this document, but not necessarily defined herein, is specified in this
        section. Items appearing here may or may not be acronymized even in their first appearances in future sections (but
        never in section headers), so knowledge of them is assumed henceforth.
      </t>
      <dl newline="true">
        <dt>Voucher-Based Address (VBA)</dt>
        <dd>An IPv6 address generated by a mixture of Link Voucher details, network interface details, and subnet details.</dd>

        <dt>Link Voucher (LV)</dt> 
        <dd>A data payload intended to be distributed by a responsible node on-link. Details are statefully maintained
          on host network interfaces and used in both generating and verifying VBAs.</dd>

        <dt>Local On-link Voucher Multicast Address (LOVMA)</dt>
        <dd>A multicast group used by VBA-enabled hosts to get gratuitous information from the current Voucher Bearer or from
          other VBA-enabled neighbors.</dd>

        <dt>Voucher Bearer (VB)</dt>
        <dd>
          The on-link node solely responsible for dissemination of the LV and authorized by any potential link guarding to
          transmit Router Advertisements or Redirects with an LV attached.
        </dd>

        <dt>Voucher Status Report (VSR)</dt>
        <dd>A type of data payload sent by VBA-enabled nodes to the LOVMA. Shares information about the node's VBA-related
          preferences. Mainly used in optimizations and is an optional protocol feature.</dd>

        <dt>Interface Enforcement Mode (IEM)</dt>
        <dd>The operating mode of the VBA-enabled network interface controlling interface reactions to unverified neighbors.</dd>

        <dt>Neighbor</dt>
        <dd>Another connected node on the same link.</dd>

        <dt>Key Derivation Function</dt>
        <dd>Definition of the second term [REPLACE/DELETE]</dd>

        <dt>Link</dt>
        <dd></dd>

        <dt>Node</dt>
        <dd>A device that actively implements and uses IPv6 on the local network.</dd>

        <dt>Hextet</dt>
        <dd>A 16-bit aggregation; data that is 16 bits in size. Can also be called a 'chomp'.</dd>
      </dl>
    </section>

    <section anchor="summary">
      <name>Voucher-Based Addressing</name>
      <t>
        This section outlines the design goals of Voucher-Based Addressing. It includes concrete processes and
        procedures used by VBA-enabled network nodes to verify address ownership and to simultaneously create
        private, pseudo-random network addresses.
      </t>

      <section anchor="summary-overview">
        <name>Design Overview</name>
        <t>
          A Voucher-Based Address is defined as any IPv6 unicast address derived from on-link voucher information.
          The address derivation process is driven by a static, well-known procedure parameterized by a mixture of
          voucher details and public node information. This same derivation process is used by other on-link nodes
          to independently verify the link-layer binding of the address during the Neighbor Discovery Address
          Resolution process.
        </t>
        <t>
          Because deterministic address generation directly depends on the value of the link-layer identifier of the
          node, purported network and target link-layer addresses cannot be falsified in NDP exchanges. Address
          verification is a process parameterized by (1) data which identifies the node's network interface, and (2)
          data which lies OUTSIDE of the generating node's administration. Such information comprises a part of the
          Link Voucher details agreed upon by all neighbors.
        </t>
        <t>
          Consider the following dishonest transactions a node on a VBA-enabled network might consider:
        </t>
        <ul>
          <!-- TODO -->
          <li>Generating a false link-layer address. </li>
        </ul>
      </section>

      <section anchor="summary-generate">
        <name>Address Generation</name>
        <t>
          This section discusses the generation procedure and composition of a VBA.
        </t>
        <figure>
          <name>The Voucher-Based Address Generation Procedure</name>
          <artwork type="ascii-art" name="vbaGeneration.txt">
            <![CDATA[
Address composition:
          PREFIX    //      SUFFIX (64 bits)
    +------ ~ ------+-------------+---------------------+
    | 64-bit prefix | Z (16 bits) |     H (48 bits)     |
    +------ ~ ------+-------------+---------------------+

... where:
    PREFIX = The 64-bit subnet prefix. If the prefix is shorter
              than 64 bits, the rest of the 64-bit field MUST be
              initialized to 0.
    SUFFIX = The first 8 bytes from the result of a Key Derivation
              Function (KDF) 'K' iterated 'L' times. The leftmost
              hextet is replaced by the bitwise complement of 'Z'.

Formulas:
H      = K(L, Key, Salt)
         |---> K    = A KDF specified by the Link Voucher.
         |---> L    = A random, host-selected 'iterations count'.
         |---> Key  = The 128-bit Link Voucher seed value.
         `---> Salt = [LLID] || 'v' || 'b' || 'a' || [PREFIX]

Z      = ~(L ^ H[2..3])

SUFFIX = hextets{ Z, H[2..3], H[4..5], H[6..7] }
                        `--> (using 0-based indexing)
            ]]>
          </artwork>
        </figure>
        <t>
          The Interface Identifier (IID) for all VBAs, called a SUFFIX, embeds two important details for verification:
        </t>
        <ul>
          <li>
            <t>
              A 16-bit 'Z' value, calculated as a bitwise complement of the XOR of the 'L' value and the second hextet
              of the hash 'H'. This calculation uses this XOR computation to ensure the same iterations count 'L' between
              different KDF results will be unique and provide some resistance to tracking hosts between each generated
              hash. This is especially true if the host locally advertises a well-known or 'sticky' iterations count [<xref target="lovma-packets-vsr"/>].
            </t>
            <ul>
              <li>
                The 'L' value (also called 'iterations count' in this document) is an important value. This parameter
                controls how many times the KDF function is iterated to produce the resulting hash. Increasing this
                value increases both the work required to generate the VBA and the work required to find potential
                hash collisions.
              </li>
            </ul>
          </li>
          <li>
            48 bits from the resulting hash, or 'H' value, derived from the KDF after 'L' iterations. Implementations
            are REQUIRED to use the FIRST 8 bytes of the hash in formulating the SUFFIX value, replacing the first
            hextet with the 'Z' value as shown in the figure.
          </li>
        </ul>
        <t>
          The address generation algorithm is detailed procedurally as follows:
        </t>
        <ol>
          <li>A host connects to a VBA network and obtains Link Voucher [<xref target="addenda-voucher"/>] details.</li>
          <li>The 'L' value is chosen based on (1) host preference, (2) intended difficulty, or (3) randomly.</li>
          <li>The Link Voucher details contain instructions for which KDF to use and which 128-bit seed value to use.</li>
          <li>
            <t>
              The KDF Salt is a variable-length CONCATENATION of a few different values, in the order specified
              below. 'Raw' values indicate binary values, NOT hexademical string notations of the values.
            </t>
            <ul spacing="compact">
              <li>
                The raw link-layer identifier of the network interface for which addresses are being generated.
                Note that since the Salt value is a variable-length string, this is NOT REQUIRED to be a MAC
                address, but it MUST represent the link-layer address to which the IPv6 address will be bound.
              </li>
              <li>The string "vba".</li>
              <li>The raw PREFIX (subnet prefix) value. This MUST match the prefix for which the VBA will be generated.</li>
            </ul>
          </li>
          <li>
            <t>
              The final address SUFFIX is computed:
            </t>
            <ul spacing="compact">
              <li>
                The first 16 bits are the bitwise complement of an XOR between the iterations count 'L' and the
                second hextet of the generated KDF hash.
              </li>
              <li>
                The least significant 48 bits are 6 sequential bytes from the KDF hash, skipping the first two
                bytes in the sequence.
              </li>
            </ul>
          </li>
        </ol>
        <t>
          See [<!-- appendix ref -->] for sample code in the C programming language which might better
          demonstrate VBA address generation.
        </t>
      </section>

      <section anchor="summary-verify">
        <name>Address Verification</name>
        <t>
          This section provides a procedural overview of VBA address verification. Two important relative terms will
          need to be established for the sake of clarity:
        </t>
        <dl newline="true">
          <dt>Client Node</dt>
          <dd>The node resolving the link-layer address of a neighbor; sends the initial Neighbor Soliciation packet.</dd>
          <dt>Target Node</dt>
          <dd>The node supplying its target link-layer address in a responding Neighbor Advertisement.</dd>
        </dl>
        <t>
          VBA address verification MUST only performed during the Address Resolution phase of an NDP exchange, where
          enabled on the local interface. Verifying an address entails reconstructing the address generation procedure
          run by the target node and ensuring the produced address is equivalent to the one solicited.
        </t>
        <figure>
          <name>The Voucher-Based Address Verification Procedure</name>
          <artwork type="ascii-art" name="vbaVerification.txt">
            <![CDATA[
 ,-- [advertise] <---.
 V       (2)         |
|A|{LV}             |B|{LV}{MAC}
 |   |               |      |
 +---+-> [solicit] --' <====|=== (solicited-node)
 |   |      (1)             |
 |   |                      |
 |   +---------.            |
 |   |         |            |
 |   |  +~~~~~~V~~~~~~~~~~~~+~~~~~~~~~~~+
 `---+->| H := LV.K(        | [rebuild  |
 (3) |  |   L := Z'(B),     |  addr B]  |
     `--+-> LV.seed,   v----'           |
        |   makeSalt(MAC, prefix(B))    |
        | );                            |
        +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            |
            |      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
            `----> | [prefix(B) || suffix(Z(L, H), H)] === B |
                   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                        (4)  {????}
                              |  |
           DROP <-- false <---'  '---> true --> ACCEPT/CACHE
            ]]>
          </artwork>
        </figure>
        <t>
          The Link Voucher 'LV' MUST always be used from the state preserved on the verifying interface. Nodes
          SHALL NOT request the Link Vouchers of others for any reason. If the verification procedure fails due
          to a LV mismatch between hosts A and B, then there is either (1) a synchronization problem or (2)
          multiple on-link vouchers being distributed.
        </t>
        <t>
          In the above figure, the "Z'" (Z-prime) function returns the iterations count embedded in Host B's address.
          This function is the opposite of 'Z'; it uses an input address to determine 'L' rather than using
          an input 'L' to determine an output hextet. Despite the different inputs, the naming alludes to the
          opposite purposes for each function.
        </t>
        <dl newline="true">
          <dt>Z(L, H) = ~(L ^ H[2..3])</dt>
          <dd>Returns a hextet to insert into a generated address. A bitwise complement of an iterations count
            XOR'd to the second hextet of an output KDF hash 'H'.</dd>
          <dt>Z'(B) = ~(B[8..9] ^ B[10..11])</dt>
          <dd>Returns an iterations count derived from a full IPv6 address. In this case, 'B[8..9]' is equal to
            the length and position of the hextet calculated by the function 'Z' above.</dd>
        </dl>
        <t>
          See the figure below for a visualization of computing Z' from a Voucher-Based Address.
        </t>
        <figure>
          <name>Extracting the Embedded Iterations Count (Z')</name>
          <artwork type="ascii-art" name="embeddedIterations.txt">
            <![CDATA[
                                  SUFFIX
                       _____________/\____________
                      /                           \
Byte: 0      ..     7 8    9    10   11   12 .. 15
      +------ ~ ------+----+----+----+----+-- ~ --+
Addr: |  PREFIX (64)  |  Z (16) |     H (48)      |
      +------ ~ ------+----+----+----+----+-- ~ --+
                      \________/\________/
                           |         |
                        B[8..9]  B[10..11]

    Z'  =  L  =  NOT( B[8..9] XOR B[10..11] )
            ]]>
          </artwork>
        </figure>
        <t>
          See [<!-- appendix ref -->] for sample code in the C programming language which might better
          demonstrate VBA address verification.
        </t>
      </section>

      <section anchor="summary-interfaces">
        <name>Interface-level Configurations</name>
        <t>
          This section outlines different interface-level configurations and options which may or may not be
          required in VBA implementations.
        </t>

        <section anchor="summary-interfaces-state">
          <name>Preserving Voucher-Related State</name>
          <t>
            VBA-enabled interfaces for all nodes, regardless of their selected Interface Enforcement Modes, are
            REQUIRED to store the full state of the most current, validated Link Voucher. If a Link Voucher is not
            available on-link, then no stored LV state is required and the node MUST enter the Address Awareness
            Disabled state (see the next section). If a LV subsequently becomes available, the node MAY choose to
            enter a different state/mode based on the implementation.
          </t>
        </section>

        <section anchor="summary-interfaces-mode">
          <name>Interface Enforcement Modes</name>
          <t>
            Per-interface modes (IEMs) are able to granularly dictate the local NDP behaviors related to VBAs.
            This flexibility in per-interface behavior grants VBAs more transition and adoption capabilities.
            A tiny state machine diagram would represent all of these states as being transitionable to any
            other.
          </t>
          <t>
            Implementations MUST allow nodes to independently opt into any one of the following IEMs for EACH
            of their local interfaces:
          </t>

          <dl newline="true">
            <dt>AAD - Address Awareness Disabled</dt>
            <dd>The VBA-aware interface MUST NOT generate or verify any addresses, regardless of the incoming
              packets. It MUST NOT participate in any LOVMA traffic exchanges. In this mode, VBAs are ignored.
              This mode SHALL always be used by VBA-enabled interfaces on links without an established LV.</dd>

            <dt>AGO - Address Generation Only</dt>
            <dd>The address generation procedure is followed for unicast addresses. The NDP Address Resolution
              process MUST NOT be supplemented by VBA optimization or verification procedures.</dd>

            <dt>AGV - Address Generation &amp; Verification</dt>
            <dd>The address generation and verification procedures are followed as per this document. Address
              Resolution is REQUIRED to fail if the advertised target link-layer address cannot be successfully
              bound to the target IP address. This SHOULD be the canonical, default Enforcement Mode for VBAs.</dd>

            <dt>AGVL - Address Generation &amp; Verification with Levels</dt>
            <dd>Both address generation and verification procedures are employed, but verification failures MUST
              NOT be strictly enforced during NDP Address Resolution. Neighbors whose VBA(s) successfully verify
              MUST be marked or indicated locally as "Secured". A neighbor which fails to verify
              MUST be indicated as "Unsecured" and given less trust or authority than "Secured" responses.</dd>
          </dl>
          <t>
            For AGVL mode, the Secured and Unsecured distinction is inherited from SEND <xref target="RFC3971"/>.
            If an AGVL interface receives multiple Neighbor Advertisement responses, it MUST strongly prefer Secured
            NAs over Unsecured NAs to determine which link-layer address is legitimate during the Address Resolution
            process. If multiple Secured responses are received, each with different link-layer addresses, then there
            is a VBA collision and the behavior of the interface is undefined. In this rare case, the pool of Secured
            responses might be equally valid, so it is left to the implementation to decide the correct course of action.
          </t>
        </section>
      </section>
    </section>

    <section anchor="addenda">
      <name>Neighbor Discovery Protocol Options</name>
      <t>The NDP option formats specified in this section MUST be supported to enable VBA functionality.</t>

      <section anchor="addenda-voucher">
        <name>Link Voucher Option</name>
        <t>
          The Link Voucher (LV) option specifies the address generation (and consequent verification)
          parameters which on-link hosts should agree upon when generating their addresses.
        </t>
        <figure>
          <name>Structure of the NDP Link Voucher option</name>
          <artwork type="ascii-art" name="linkVoucherOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |     Type      |    Length     |   Pad Length  |   Expiration  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Reserved                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit Timestamp                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                      128-bit Voucher Seed                     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
 ...                     TLV Algorithm Settings                  ...
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
 ...                     DER-encoded Public Key                  ...
 ...                          & Signature                        ...
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
 ...                           Padding                           ...
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>63</dd>
          <dt>Length</dt><dd>The total length of the LV from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <!-- TODO: Add all parameter definitions per LV specification. -->
        </dl>

        <section anchor="addenda-voucher-senders">
          <name>Processing Rules for Senders</name>
          <t>
            Senders of Link Vouchers MUST maintain stateful information about their LVs at all times, so reliable and consistent
            LV details can be sent at any time. The rotation of stable LV information, such as the Seed value or Expiration details,
            SHOULD be signaled in advance using the LOVMA group <xref target="lovma-packets-pvr"/>. Transferral of LV responsibility
            to another LV identifier SHOULD use similar means <xref target="lovma-packets-vha"/>.
          </t>
          <t>The Sender's LV MUST always be unique on-link and NEVER be forwarded or duplicated copies of other LVs.</t>
          <t>
            Sending nodes wishing to distribute a Link Voucher MUST first check the local link for an already-active LV. This
            entails following a process of router discovery, then only assuming LV responsibility if no LV is already present.
          </t>
          <ol spacing="compact">
            <li>Send a Router Soliciation to the All Routers multicast group at FF02::2.</li>
            <li>Wait for an LV for at least 2 seconds before sending another Soliciation.</li>
            <li>
              <t>Repeat this process 2 more times.</t>
              <ul spacing="compact">
                <li>If an LV is received within a Router Advertisement response, accept and use the parameters of the received LV.
                  This condition means the sender MUST NOT send their own LV, nor should it propagate any instances of LV options.</li>
                <li>
                  <t>If no LV is received after the 3 total attempts, and...</t>
                  <ul spacing="compact">
                    <li>the Sender IS NOT a router: the Sender's LV may be distributed on the local link as an option attached
                      to an appropriate NDP Redirect packet.</li>
                    <li>the Sender IS a router: the Sender may attach its LV to an appropriate NDP Router Advertisement packet.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ol>
          <t>
            On-link nodes responsible for an LV (also known as Voucher Bearers (VBs) -- see the VB section <xref target="bearers"/>)
            MUST respond to Router Soliciation packets. This is true regardless of  whether the VB is using a Redirect or Router
            Advertisement to distribute its LV.
          </t>
          <t>
            Protecting the link from rogue LVs is crucial to securely maintain the full consensus of the local network.
            See the section on RA-Guard <xref target="bearers-vigilance"/> and LV Hijacking <xref target="security-usurp"/>
            for more details.
          </t>
        </section>

        <section anchor="addenda-voucher-receivers">
          <name>Processing Rules for Receivers</name>
          <!-- TODO -->
          <t>
            Receiving nodes MUST statefully maintain and update all LV information per-link, if and only if the received LV is
            successfully verified according to its cryptographic signature.
          </t>
          <t>A Link Voucher option appearing with any packet except NDP Router Advertisements or NDP Redirects MUST be ignored.</t>
          <t>
            Nodes acting as authorized Voucher Bearers <xref target="bearers"/> MUST disregard any received LV options on the links
            for which they are already the responsible VB.
          </t>
        </section>

        <section anchor="addenda-voucher-kdfs">
          <name>Algorithm Settings</name>
          <t>
            This section will discuss the default algorithms and KDF types that SHOULD be packaged with basic implementations
            of this specification.
          </t>
          <dl newline="true">
            <dt>PBKDF2</dt>
            <dd>
            </dd>
            <dt>Argon2d</dt>
            <dd>
            </dd>
            <dt>Scrypt</dt>
            <dd>
            </dd>
          </dl>
        </section>

        <section anchor="addenda-voucher-signatures">
          <name>Voucher Signatures</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-voucher-expirations">
          <name>Voucher Expirations</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="addenda-summary">
        <name>ND Voucher Summary Option</name>
        <t>
          The Voucher Summary (VS) option is included with Neighbor Solicitation and Advertisement packets to hint to
          recipients which active Link Voucher ID is being statefully used on the target or source interface.
        </t>
        <figure>
          <name>Structure of the NDP Voucher Summary option</name>
          <artwork type="ascii-art" name="voucherSummaryOption.txt">
            <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]>
          </artwork>
        </figure>
        <dl newline="true">
          <dt>Type</dt><dd>64</dd>
          <dt>Length</dt><dd>Set to 1. The total length of the VS from the Type through its end -- inclusive -- in units of 8 octets.</dd>
          <dt>IEM</dt>
          <dd>
            <t>
              A 3-bit identifier representing the current Interface Enforcement Mode of the sending interface (see
              <xref target="summary-interfaces-mode"/>).
            </t>
            <dl spacing="compact" newline="false">
              <dt>0</dt><dd>AAD</dd>
              <dt>1</dt><dd>AGO</dd>
              <dt>2</dt><dd>AGV</dd>
              <dt>3</dt><dd>AGVL</dd>
              <dt>4</dt><dd>Reserved</dd>
              <dt>5</dt><dd>Reserved</dd>
              <dt>6</dt><dd>Reserved</dd>
              <dt>7</dt><dd>Reserved</dd>
            </dl>
          </dd>
          <dt>Reserved</dt><dd>A 13-bit field reserved for future use. This MUST be initialized to zero by the sender and MUST
            be ignored by the receiver.</dd>
          <dt>VoucherID</dt><dd>The 64-bit ID of the statefully cached Link Voucher on the sending interface.</dd>
        </dl>

        <section anchor="addenda-summary-senders">
          <name>Processing Rules for Senders</name>
          <t>
          </t>
        </section>

        <section anchor="addenda-summary-receivers">
          <name>Processing Rules for Receivers</name>
          <t>
          </t>
        </section>
      </section>
    </section>

    <section anchor="behavioral">
      <name>Behavioral Neighbor Discovery Changes</name>
      <t>
      </t>

      <section anchor="behavioral-send">
        <name>Changes Adopted from SEND</name>
        <t>
        </t>

        <section anchor="behavioral-send-nonce">
          <name>Nonce Option</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-send-levels">
          <!-- See Section 8 of RFC 3971. -->
          <name>Secured &amp; Unsecured Distinctions</name>
          <t>
            Section x of the SEND RFC <xref target="RFC3971"/> defines a
          </t>
        </section>
      </section>

      <section anchor="behavioral-cache">
        <name>Protecting the Neighbor Cache</name>
        <t>
          The primary verification goal of VBAs results in a symmetric computation that can be costly for
          low-power nodes or other embedded systems. By requiring address verification ONLY when interacting
          with the local Neighbor Cache, nodes do not need to perform the entire verification procedure as
          frequently.
        </t>
        <t>
          This section discusses some behavioral NDP changes regarding the host's Neighbor Cache. The changes
          are aimed at a balanced mixture of optimization and security.
        </t>

        <section anchor="behavioral-cache-receiving">
          <name>Receiving Neighbor Solicitations</name>
          <!-- DO NOT EAGERLY CACHE WITHOUT VERIFYING. -->
          <t>
          </t>
        </section>

        <section anchor="behavioral-nud">
          <name>Neighbor Unreachability Detection</name>
          <t>
          </t>
        </section>

        <section anchor="behavioral-cache-unsolicited">
          <name>Receiving Unsolicited Traffic</name>
          <t>
            Any node receiving unsolicited traffic from a neighbor, for which no response is required from
            the receiver -- such as UDP-based applications -- does not need to interact with the VBA system
            at all. The receiving node MAY choose to validate the sender according to this specification.
            This would necessitate the neighbor verification process be conducted in reverse.
          </t>
          <t>
            If the sending neighbor is already in the receiver's neighbor cache, then the receiver SHOULD
            NOT verify the address of the sender.
          </t>
          <t>
            As stated in this document's introduction <xref target="intro"/>,
            VBA employment primarily supplies privacy-focused address generation and uses neighbor address
            verification to provide proof of address ownership. The goal is to prevent on-path attackers
            from illegally, ACTIVELY intercepting local network traffic. Therefore, receiving packets for
            which no response is necessary does not merit an explicit requirement that the sending neighbor
            be verified.
          </t>
        </section>
      </section>

      <section anchor="behavioral-dad">
        <name>Duplicate Address Detection</name>
        <t>
          When generating a VBA, the node MUST follow the ordinary means of Duplicate Address Detection (DAD)
          specified by the SLAAC RFC (section 5.4 of <xref target="RFC4862"/>). The DAD procedure SHOULD follow
          any other applicable DAD optimizations (<xref target="RFC4429"/>, <xref target="RFC7527"/>, etc.).
        </t>
        <t>
          Upon detecting a duplicate address, VBA-enabled nodes MUST by necessity to select another iterations
          count 'L' value to generate a non-conflicting address. This can become computationally expensive
          to recompute each new value based on the amount of address collisions, or in the case of denial of
          service attacks.
        </t>
        <t>
          To counter this weakness, implementations MUST employ one of two options based on the selected 'L' value:
        </t>
        <dl newline="true">
          <dt>L &gt;= 4</dt>
          <dd>Cache the 4 leading KDF computations (L-4 through L-1) during the DAD procedure.</dd>
          <dt>L &lt;  4</dt>
          <dd>Cache the result of the 'L' value only.</dd>
        </dl>
        <t>
          Implementations SHOULD always prefer the option where the 'L' value is &gt;= 4, because
          L-4 through L-1 are intermediate KDF results already required in order to produce the result at the final
          iterations count. Conversely, any 'L' value under 4 will simply cache 'L' then increment the KDF iterations
          by one for each DAD collision, up to 4 times.
        </t>
        <t>A figure representing this process visually is shown below:</t>
        <figure>
          <name>Using DAD with VBAs</name>
          <artwork type="ascii-art" name="duplicateAddressDetection.txt">
            <![CDATA[
COMPUTE & CACHE:
  N = Set of K(L', Key, Salt),
    where L' :=
      if L >= 4 :  { L-4, L-3, L-2, L-1, L },
      else      :  { L }

           (1)      +~~~~~~~~~~~~~~+
 |A|{B}------------>| Normal SLAAC | (B :  Duplicate!)
  |     v-----------|  DAD Process | (B':  Success!)
  |  [FAIL]  (2)    +~~~~~~~~~~~~~~+
  |                      ^
  |                      |
  `---> [cached (L-1)    | (3)
         generates B'] --'
            ]]>
          </artwork>
        </figure>
        <t>
          In the figure, (1) shows host 'A' engaged in DAD using the address 'B' generated with the iterations count 'L'.
          After the collision is detected in (2), step (3) shows the new address "B'" being immediately tried using the
          already-cached value 'L-1' as the input iterations count. The DAD process is then successful and there are no
          on-link duplicate addresses.
        </t>
        <t>
          To further cement this important optimization procedure, a written example process follows.
        </t>
        <ol>
          <li>A new network host has received Link Voucher details; the voucher specifies using PBKDF2.</li>
          <li>The host arbitrarily selects 0xFF04 as its input link-local iterations count.</li>
          <li>The host will iterate the PBKDF2 function through 0xFEFF.</li>
          <li>When retrieving the PBKDF2 cipher output for 0xFF00 (L - 4) iterations, it will cache this value.</li>
          <li>It will do the same for the next 3 iterations counts (0xFF01, 0xFF02, &amp; 0xFF03).</li>
          <li>It will compute the final PBKDF2 round at 0xFF04 iterations, and will use the result to generate
            a valid VBA <xref target="summary-generate"/>.</li>
          <li>When following the DAD procedure, a collision is detected.</li>
          <li>The host then falls immediately back to the L - 1 iterations count of 0xFF03 to generate the VBA.</li>
          <li>This new host address is completely different and does not register a DAD collision.</li>
          <li>The optimization has successfully removed the need to recompute the PBKDF2 algorithm up to some new
            iterations count, saving a significant amount of time in the VBA-enabled SLAAC process. Reducing the
            chosen 'L' value by 1 results in a completely different pseudo-random address.</li>
        </ol>
        <t>
          If all 5 attempted iterations counts result in DAD collisions, then the node MUST give up and use some other
          implementation-specific course of action to contact an administrator or log a system management error.
        </t>
        <t>
          Note that truly benign DAD collisions are a dangerous prospect for Voucher-Based Addressing. Address
          collisions imply that a separate link-layer identifier with the SAME iterations count has somehow
          generated a hash suffix collision, exposing the possibility for node impersonation in a rare occurrence.
          Some implementations MAY wish to find trusted ways to detect such an occurrence, possibly by means
          of intermediate device monitoring (such as switching hardware), and take action based on it.
        </t>
        <t>
          Nodes encountering a duplicate address will by necessity require a different iterations count to
          generate their current address. If the node uses a 'sticky' iterations count, then it is RECOMMENDED
          that it send a gratuitous VSR update to the LOVMA with the new count (<xref target="lovma-packets-vsr"/>).
        </t>
        <t>
          A discussion regarding denial of service attack vectors related to DAD in VBA networks is found in
          <xref target="security-dos-dad"/>.
        </t>
      </section>
    </section>

    <section anchor="lovma">
      <name>Local On-link Voucher Multicast Address</name>
      <t>
        The LOVMA group is defined for the express purpose of sharing gratuitous, independent VBA details between nodes.
        All nodes with VBA awareness, regardless of Interface Enforcement Mode (<xref target="summary-interfaces-mode"/>)
        are strongly RECOMMENDED to join this group. Nodes are NOT REQUIRED to make practical use of any LOVMA traffic.
      </t>
      <t>
        This multicast group is located at the IPv6 address FF02::ABBA. A helpful mnemonic to remember this address is to
        think of "ABBA" as the closest possible hexademical rendition of "a VBA".
      </t>

      <section anchor="lovma-constraints">
        <name>Constraints</name>
        <t>
          When utilizing the LOVMA for any purpose, experimental or deployed, implementations MUST regard these constraints:
        </t>
        <ul>
          <li>LOVMA traffic is considered unidirectional. Nodes SHOULD NOT send unicast responses in reply to multicast traffic.
            This recommended constraint acts to prevent asymmetric traffic volumes and potential denial of service vulnerabilites
            leveraging the LOVMA.</li>
          <li>All LOVMA datagrams MUST be User Datagram Protocol (UDP) <xref target="RFC768"/> packets.</li>
          <li>VBA-enabled nodes MUST NOT assume that other VBA-enabled nodes are subscribed to the LOVMA multicast group or
            receiving any of its related datagrams.</li>
          <li>Subscribing nodes MUST NOT offer any trust of LOVMA packets, unless a datagram validation procedure is explicitly
            declared for the extension protocol using the LOVMA.</li>
        </ul>
      </section>

      <section anchor="lovma-packets">
        <name>Defined Datagrams</name>
        <t>
          This section outlines and formalizes some initial datagrams which may be gratuitously sent to the LOVMA at any time.
        </t>

        <section anchor="lovma-packets-vsr">
          <name>Voucher Status Reports (VSRs)</name>
          <t>
          </t>
          <figure>
            <name>Structure of a VSR Datagram</name>
            <artwork type="ascii-art" name="lovmaVsr.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>

        <section anchor="lovma-packets-vci">
          <name>Voucher Capability Indications (VCIs)</name>
          <t>
            Nodes may notify the LOVMA about their potential candidacy as a link Voucher Bearer (<xref target="bearers"/>) by
            sending a VCI datagram. The VCI is an informational packet REQUIRED to be considered for election by the current VB.
          </t>
          <t>
            Receivers are typically intended to be the current VB, but any node MAY make use of VCI details. Nodes MUST NOT consider
            VCI packets as valid Link Vouchers. The current VB MAY maintain a state of unexpired VCI packets, especially when
            it intends to elect a new node responsible for the LV.
          </t>
          <figure>
            <name>Structure of a VCI Datagram</name>
            <artwork type="ascii-art" name="lovmaVci.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>

        <section anchor="lovma-packets-vha">
          <name>Voucher Handoff Advertisements (VHAs)</name>
          <t>
            The node responsible for the Link Voucher MAY at any time elect a new link Voucher Bearer (<xref target="bearers"/>)
            using the VHA datagram. This 'handoff' communication notifies VBA-enabled hosts of a change in VB and thus public-key
            information used to sign the new LV. If the public-key signature on the VHA is valid and nodes are 
          </t>
          <t>
            Candidate nodes considered for VB election MUST be gathered from either (1) manually configured details or (2) senders
            of recent, unexpired VCI notifications.
          </t>
          <t>
            When the elected node observes the VHA packet granting it VB responsibility, it MUST begin sending gratuitous Router
            Advertisements to the local network for which it is now a VB. Sending a RA to the local network always follows the receipt
            of a valid, unexpired VHA from the previous VB. After 2 minutes, the new VB MUST consider the LV parameters (including the
            public key) of the previous VB as invalid, and no longer trigger RAs based on receipt of VHAs.
          </t>
          <figure>
            <name>Structure of a VHA Datagram</name>
            <artwork type="ascii-art" name="lovmaVha.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>

        <section anchor="lovma-packets-pvr">
          <name>Preemptive Voucher Rotations (PVRs)</name>
          <t>
          </t>
          <figure>
            <name>Structure of a PVR Datagram</name>
            <artwork type="ascii-art" name="lovmaPvr.txt">
              <![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Type     |     Length    | IEM |        Reserved         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        64-bit VoucherID                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              ]]>
            </artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="bearers">
      <name>Voucher Bearers</name>
      <t>
        A Voucher Bearer is the on-link node responsible
      </t>
      <t>
        Any node MAY be elected to serve as the link's VB, whether by manual configuration or by a process of election and appointment
        from the current VB (see <xref target="lovma-packets-vci"/>). If the current VB is NOT a router or responsible for routing subnet
        traffic, then it MUST distribute the LV via an NDP Redirect packet with an LV option instead of an NDP RA packet. The Redirect is
        expected to behave similarly to the defined NDP process (<!-- NDP section ref -->).
      </t>

      <section anchor="bearers-vigilance">
        <name>Employing RA-Guard</name>
        <t>
        </t>
      </section>

      <section anchor="bearers-timeouts">
        <name>Timeouts or Expirations</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="optimizations">
      <name>Specification Optimizations</name>
      <t>
        This section discusses the various optimizations built into Voucher-Based Addressing.
      </t>

      <section anchor="optimizations-dad">
        <name>Duplicate Address Detection Caching</name>
        <t>
          The SLAAC DAD process is optimized to reduce the burden of regenerating another VBA from scratch.
          See <xref target="behavioral-dad"/> for how this optimization functions as part of the core VBA
          specification.
        </t>
      </section>

      <section anchor="optimizations-lovma">
        <name>Preemptive Notifications on the LOVMA</name>
        <t>
        </t>
      </section>

      <section anchor="optimizations-kdfs-et-al">
        <name>Key Derivation Function Parameters</name>
        <t>
        </t>
      </section>

      <section anchor="optimizations-summaries">
        <name>Voucher Summary Options</name>
        <t>
        </t>
      </section>
    </section>

    <section anchor="transitions">
      <name>Transition Mechanisms</name>
      <t>
      </t>
    </section>
    
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>
        This section includes discussions on various subjects related to the security of Voucher-Based Addresses.
        It also serves to clarify certain VBA processes or tangential protocol-related topics that may not have
        had adequate exploration in the rest of this document.
      </t>

      <section anchor="security-solutions">
        <name>How VBAs Balance Privacy &amp; Security</name>
        <t>
        </t>

        <section anchor="security-solutions-proof">
          <name>Proof of Address Ownership</name>
          <t>
          </t>
        </section>

        <section anchor="security-solutions-privacy">
          <name>Privacy-Focused Addresses</name>
          <t>
          </t>
        </section>
      </section>

      <section anchor="security-binding">
        <!-- From SEND:
            SEND does not compensate for an unsecured link layer.  For instance,
            there is no assurance that payload packets actually come from the
            same peer against which the NDP was run.
            Likewise, VBAs rely on the principle that link-lyer addresses MUST be unique on the same broadcast medium.
            VBAs offer great protection for unsecured L2 setups, but link-layer security would help to remediate further concerns.
        -->
        <name>Privacy of Link-Layer Bindings</name>
        <t>
        </t>
      </section>

      <section anchor="security-usurp">
        <name>Hijacking Link Vouchers</name>
        <t>
        </t>
      </section>

      <section anchor="security-dos">
        <name>Denial of Service</name>
        <t>
        </t>

        <section anchor="security-dos-dad">
          <name>Duplicate Address Detection</name>
          <!-- This spec leans on other DAD protection mechanisms. -->
          <t>
            The computational cost of generating VBAs can be abused by a malicious threat actor using DAD mechanisms.
          </t>
        </section>

        <section anchor="security-dos-grand">
          <name>Gratuitous Neighbor Discovery</name>
          <!-- RFC 9131 considerations. -->
          <t>
          </t>
        </section>
      </section>

      <section anchor="security-static">
        <name>Static Addressing</name>
        <t>
        </t>
      </section>

      <section anchor="security-collisions">
        <name>Hash Collisions</name>
        <t>
        </t>
      </section>

      <section anchor="security-fairness">
        <name>Computational Fairness</name>
        <t>
        </t>
      </section>

      <section anchor="security-pki">
        <name>Certifying Link Vouchers</name>
        <t>
        </t>
      </section>

      <section anchor="security-anycast">
        <name>Anycast Addresses</name>
        <t>
          Anycast addresses are allocated from the unicast address space and are thus indistinguishable to
          nodes establishing connections to them. NDP exchanges with these hosts may therefore respond with
          varying Target Link-Layer Address options and cause VBA verification to be unreliable.
          For this reason, it is NOT RECOMMENDED to utilize anycast addresses for on-link prefixes within
          VBA-enabled networks, because the ownership of the address cannot be bound to a particular
          link-layer identifier.
        </t>
        <t>
          The IPv6 Addressing Architecture RFC (<xref target="RFC4291"/>) outlines a Required Anycast Address
          in Section 2.6.1. VBA-enabled links SHOULD maintain compatibility with this requirement by disabling
          verification for on-link subnet anycast addresses. For example, a host using SLAAC to generate an
          address in the subnet 2001:db8:700::/64 SHOULD disable VBA expectations and verifications for the
          address 2001:db8:700::. Because VBA protections must be disabled for this target host, implementations
          SHOULD avoid using the subnet Required Anycast Address altogether.
        </t>
      </section>
    </section>
    
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>
        This document defines two new Neighbor Discovery Protocol option types and one new link-local multicast
        address.
      </t>
      <t>
        See <xref target="lovma"/> for information about the Local On-link Voucher Multicast Address subscribed
        to by VBA-enabled network interfaces.
      </t>
      <t>
        Assigned in the "Link-Local Scope Multicast Addresses" subregistry of the "IPv6 Multicast Address Space
        Registry":
      </t>
      <t>
        Address(es): FF02::ABBA<br />
        Description: Local On-link Voucher Multicast Address<br />
        Reference: draft-puhl-6man-ndp-vba-00
      </t>
      <t>
        Two new Neighbor Discovery Protocol options are defined in this document and must have new Option Type
        values assigned in the "IPv6 Neighbor Discovery Option Formats" subregistry of the "Internet Control
        Message Protocol version 6 (ICMPv6) Parameters" registry.
      </t>
      <ul>
        <li>The Link Voucher option, described in <xref target="addenda-voucher"/>.</li>
        <li>The Voucher Summary option, described in <xref target="addenda-summary"/>.</li>
      </ul>
    </section>
  </middle>


  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3971.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4861.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4862.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4291.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4429.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7527.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9131.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.768.xml"/>
        <!-- key-derivation crypto resources -->
      </references>
      <!-- <references>
        <name>Informative References</name>
        <reference anchor="exampleRefMin">
          <front>
            <title>Title [REPLACE]</title>
            <author initials="Initials [REPLACE]" surname="Surname [REPLACE]">
              <organization/>
            </author>
            <date year="2006"/>
          </front>
        </reference>
        <reference anchor="exampleRefOrg" target="http://www.example.com/">
          <front>
            <title>Title [REPLACE]</title>
            <author>
              <organization>Organization [REPLACE]</organization>
            </author>
            <date year="1984"/>
          </front>
        </reference>       
      </references> -->
    </references>
    
    <section anchor="appendices">
      <name>Appendices</name>

      <section anchor="appendices-a">
        <name>Appendix A</name>
        <t>
        </t>
      </section>
    </section>
 </back>
</rfc>
